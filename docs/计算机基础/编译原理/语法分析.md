---
title: 语法分析
index: 4
typora-root-url: ./..\..\..\..\IMG\docs\计算机\编译原理
---

在描述程序语言的语法结构时，需借助于上下文无关文法，而文法是描述程序语言的依据。

# 程序语言的定义

程序本质上是一定字符集上的字符串。

## 语法

语法：**一组规则**，用它可以形成和产生一个合适的程序。

词法规则：单词符号的形成规则

- 单词符号是语言中具有独立意义的最基本结构
- 一般包括：常数、标识符、基本字、算符、界符等
- 描述工具：有限自动机

语法规则：语法单位的形成规则

- 语法单位通常包括：表达式、语句、分程序、过程、函 数、程序等 ;
- 描述工具：上下文无关文法

**语法规则**和**词法规则**定义了程序的**形式结构**。

## 语义

语义：一组规则，用它可以定义一个程序的意义

语义分类：

1. **静态语义**：是一系列限定规则，并确定哪些合乎语法的程序是合适的。
2. **动态语义**(运行语义、执行语义)：表明程序要做什么，要计算什么。

描述方法：

- 自然语言描述：隐藏错误、二义性和不完整性
- 形式描述：操作语义 (PL/1)、指称语义 (ADA)、代数语义 (PASCAL)

## 程序语言的基本功能和层次结构

程序语言的基本功能：描述数据和对数据的运算

所谓程序，本质上是描述一定数据的处理过程

## 程序的层次结构

![](69.png)

## 标识符与名字

标识符：以字母开头的，由字母数字组成的字符串。

名字：由值（单元中的内容）和属性（类型和作用域）组成。

名字的性质的说明方式：

- 由说明语句来明确规定

- 隐含说明

  FORTRAN 以 I、J、K、…N 为首的名字代表整型，否则为实型

- 动态确定

  走到哪里，是什么，算什么

::: tip 标识符与名字的区别

标识符是语法概念，名字是语义概念

:::

![](70.png)

若一个标识符ABC，

- 绑定了一个人，那么ABC就是人名
- 绑定了一个国家，那么ABC就是国名

# 程序语言的语法描述

考虑一个**有穷字母表** $\Sigma$ 字符集，

- 其中每一个元素称为一个**字符(符号)**；

- 由 $\Sigma$ 中的字符所构成的一个有穷序列称为 $\Sigma$ 上的**字**(也叫**字符串**，**符号串**)；

- 不包含任何字符的序列称为**空字**，记为 $\varepsilon$ ；

- 用 $\Sigma ^*$ 表示 $\Sigma$ 上的所有**字的全体**，包含空字 $\varepsilon$ ；

  > 例如：
  >
  > 设 $\Sigma =\{a,b \}$ ，则 $\Sigma ^*=\{\varepsilon ,a,b,aa,ab,ba,\cdots \}$
  
- 对于字母表 $\Sigma$ 来说， $\Sigma ^*$ 上的任意一个子集都称为 $\Sigma$ 上的一个**语言**，记为 $L(L\subset  \Sigma ^*)$；

- 语言的每一个字符串称为语言 $L$ 的一个**语句**或句子；

::: info 重要约定

- 小写字母 $a, b, c,\cdots , r$ 表示**字符**
- 小写字母 $s, t, u,\cdots , z$ 表示**字符串**
- 大写字母 $A, B, C,\cdots , Z$ 表示**字符串集合**

:::

字符串的运算：

1. 字符串**相等**

   设 x、y 是 $\Sigma$ 上的两个字符串，若 x 与 y 的诸符号依次相等，则该两符号串相等，记为 $x = y$。

2. 字符串**长度**

   设 x 是 $\Sigma$ 上的字符串，字符串中包含符号的个数称为字符串 x 的长度，用 $\left | x \right |$ 表示。

   - $\left | \varepsilon \right |=0$
   - $\left | ax \right |=\left | xa \right   | = \left | x \right |+1 (a\in \Sigma)$

3. 字符串的**连结**

   设 x 与 y 是 $\Sigma$ 上的两个字符串，把 y 的所有符号相继写在 x 的符号之后所得到的字符串称为 x 与 y 的连结，用 $xy$ 表示。

   - $\left | xy \right |=\left | x \right |+\left | y \right |$
   - $\varepsilon x=x \varepsilon = x$

4. 字符串的**逆**

   设 x 是 $\Sigma$ 上的符号串，其逆为符号串 x 的倒置，记为 $\widetilde{x}$。

   - 若 $x=abcd$，则 $\widetilde{x}=dcba$
   - $\widetilde{\varepsilon} =\varepsilon$

5. 字符串的**前缀、后缀和子串**

   设 x、y、z 是 $\Sigma$ 上的符号串，则称 x 为符号串 xy 的前缀，y 是符号串  xy 的后缀。x、y、z、xy、yz 是符号串 xyz 的子串。

6. 字符串**集合的乘积**

   $\Sigma ^*$ 的子集 $U$ 和 $V$ 的**连接（积）**定义为 $UV=\{\alpha  \beta | \alpha \in U \& \beta \in V \}$

   > 例如：
   >
   > 设 $U = \{a,aa\}$ 和 $V = \{b,bb\}$ ，那么 $UV = \{ab, abb, aab, aabb\}$

7. **空集**

   不含任何元素的集合，记为 $\phi$

   - $\phi U=U\phi = \phi$
   - $\varepsilon \notin \phi$

8. 字符串的**幂**

   设 x 是 $\Sigma$ 上的符号串，则 x 的幂运算为 $x^0=\varepsilon$，$x^n=xx\cdots x(n>0)$。

   > 例如：
   >
   > 若 $x=ab$，则 $x^0=\varepsilon$，$x^1=ab$，$x^2=abab$

9. 字符串**集合的幂**

   $V$ 自身的 n 次积记为 $V^n=VV\cdots V$ （n个$V$相乘），规定 $V^0=\{\varepsilon \}$

   > 例如：
   >
   > 若 $V=\{ab,cd\}$，则 $V^0=\{\varepsilon \}$，$V^1=\{ ab,cd \}$，$V^2=\{abab,abcd,cdab,cdcd \}$

10. 集合A**的闭包与正规闭包**

    记 $V^* =V^1\cup V^2 \cup V^3\cup \cdots$ ，称 $V^*$ 是 $V$ 的**闭包**。

    记 $V^+=VV^*$ ，称 $V^+$ 是 $V$ 的**正规闭包**。

    大多数情况下，闭包和正规闭包没有太大区别。

    > 例如：
    >
    > 若 $U= \{a, aa  \}$，则 $U^* = \{\varepsilon ,a, aa, aaa, aaaa,\cdots \}$，$U^+=\{a, aa, aaa, aaaa,\cdots \}$

::: tip 

- $\phi$：一个集合，这个集合里面没有字
- $\varepsilon$：一个长度为0的字
- $\{\varepsilon \}$：一个集合，这个集合里面有一个字，但这个字的长度为0

:::

# 上下文无关文法

## 文法的定义

::: info **规则**（重写规则、产生式、生成式）

一个规则是一个二元组，通常写作 $\alpha ::= \beta$ 或 $\alpha \to \beta$ 。

$\alpha$ 称为规则的左部，$\beta$ 称为规则的右部，$\to$ 和 $::=$ 读作“ 定义为 ”，这是一条关于 $\alpha$ 的规则（产生式）。

:::

::: info 巴科斯范式 (BNF)

“ $\to$ ” 也可以用“ ::= " 表示， 这种表示称为巴科斯范式 (BNF)。

:::

**文法**： 描述语言的语法结构的形式规则。

一个上下文无关文法 G 是一个四元式 $G=(V_T ,V_N , S, P)$ ，其中

- $V_T$ ：**终结符**集合 ( 非空，有限 )
- $V_N$ ：**非终结符**集合 ( 非空，有限 ) ，且 $V_T \cap  V_N =\phi$
- S ：文法的**开始符号**，它是一个非终结符，至少要在一条规则中作为左部出现， $S\in V_N$
- P ：**产生式**集合 ( 非空，有限 ) ，每个产生式形式为 $P \to \alpha$ ,  $P\in V_N$ , $\alpha \in (V_T \cup V_N)^*$

$V=V_N\cup V_T$，称为文法G的字母表。

::: info 终结符

终结符是指语言不可再分的基本符号，通常是一个语言的字母表；

终结符代表了语法的最小元素，是一个个体记号。

:::

::: info 非终结符

非终结符也称语法变量，代表语法实体或语法范畴；

:::

如果$P\to \alpha _1$，$P\to \alpha _2$，$P\to \alpha _3$，... ，为了书写方便，可以缩写为
$$
P\to \alpha _1|\alpha _2|\alpha _3|\cdots
$$
其中，“$|$” 读成 “或”，每个 $\alpha _i$ 称为$P$的一个候选式。

表示一个文法时，不用将文法G的四元组显式地表示出来，通常只给出**开始符号**和**产生式**。

::: info 一般约定

- 第一条产生式的左部是识别符
- 用尖括号括起来的是非终结符（或者用大写字母表示）
- 不用尖括号括起来的是终结符（或者用小写字母表示）
- 将G也写成G[S]，其中S是识别符

::: 

## 文法产生的语言

::: warning 推导

![](71.png)

在下面的内容中， " + "，“ * ” 应该放在$\Rightarrow$的上面，但由于Markdown文档没有相关的公式，因此只能写成$\Rightarrow ^+$这样的形式。

:::

设文法$G[S]=(V_T ,V_N , S, P)$，且$\alpha , \beta \in (V_T\cup V_N)^*$ ，

如果存在产生式$A\to \delta$ , $(\delta  \in (V_T\cup V_N)^*)$，则称$\alpha A \beta$ 可**直接推导**到 $\alpha \delta \beta$，$\alpha A \beta \Rightarrow \alpha \delta \beta$，或 $\alpha \delta \beta$ **直接规约**到 $\alpha A \beta$。

> 例：
>
> $G$：$S\to 0S1$，$S\to 01$
>
> $S\Rightarrow 0S1 \Rightarrow 00S11 \Rightarrow 000S111\Rightarrow 00001111$

通常，

- $\alpha _1\Rightarrow ^+\alpha _n$表示从$\alpha _1$出发，经过**一步或若干**步，可以推出$\alpha _n$。
- $\alpha _1\Rightarrow ^*\alpha _n$表示从$\alpha _1$出发，经过**0步或若干**步，可以推出$\alpha _n$。

---

**句型**：由文法的开始符$S$出发，经过0步或有限步推导出来的符号串$\alpha$（$S\Rightarrow ^* \alpha$，$\alpha \in (V_T\cup V_N)^*$）

**句子**：由文法的开始符$S$出发，经过1步或有限步推导出来的符号串$\alpha$，且该字符串全部由终结符组成（$S\Rightarrow ^+ \alpha$，$\alpha \in V_T^*$）

**语言**：由对应的文法$G$所产生的句子的全体，记为$L[G]$，$L[G]=\{\alpha |S\Rightarrow ^+ \alpha ,\alpha \in V_T^* \}$

> 例：
>
> 1. 证明$(i*i+i)$是文法$G(E)$ ： $E \to i | E+E | E*E | (E)$ 的一个句子。
>
>    ![](72.png)
>
> 2. 文法 $G_1 (A)$ ： $A \to c|Ab$ ，$G_1(A)$的语言是什么 ?
>
>    $L(G_1)=\{c ， cb ， cbb ，\cdots \}$
>
>    ![](73.png)
>
> 3. 文法 $G_2 (S)$： $S \to AB$，$A \to aA|a$，$B \to bB|b$，$G_2 (S)$的语言是什么 ?
>
>    $L(G_2 )=\{a^mb^n|m , n>0\}$
>
>    ![](74.png)
>

**递归规则**：是指在规则的左部和右部具有相同的非终结符的规则。

- 右递归：$A\to \cdots A$
- 左递归：$A\to  A\cdots$
- 规则递归：$A\to \cdots A\cdots$

**文法的递归性**：是指文法中任一非终结符，若能建立一个推导过程，在推导所得的符号串中又出现了该非终结符本身。

- 文法右递归：$A\Rightarrow ^+ \cdots A$
- 文法左递归：$A\Rightarrow ^+  A\cdots$
- 文法递归：$A\Rightarrow ^+ \cdots A\cdots$

当一个语言是无穷集合时，则定义该语言的文法一定是递归的；程序设计语言都是无穷集合，描述它的文法必定是递归的。

>例：
>
>1. 给出产生语言为 $\{a^nb^n |n\geqslant 1\}$ 的文法
>
>   ![](75.png)
>
>2. 给出产生语言为 $\{a^mb^n |1\leqslant n\leqslant  m\leqslant 2n\}$ 的文法
>
>   ![](76.png)
>

::: info 计算思维的典型方法——递归

问题的解决又依赖于类似问题的解决，只不过后者的复杂程度或规模较原来的问题更小，一旦将问题的复杂程度和规模化简到足够小时，问题的解法其实非常简单。

::: 

若$L(G_1)$＝$L(G_2)$，则称文法$G_1$和$G_2$是**等价**的。

> 例：
>
> 文法$G[A]$：$A\to 0R$，$A\to 01$，$R\to A1$和文法$G[S]$：$S\to 0S1$，$S\to 01$等价于$L(G)=\{n^n1^n|n\geqslant 1\}$

# 形式语言

一种不考虑含义的符号语言。

## 定义

序列的集合称为形式语言。

具体讲：每个形式语言都是某个字母表上按某种规则构成的所有符号的集合。即：任何一个字母表上符号串的集合均可定义为一个形式语言。

对形式语言的描述有两种方法：

- 当语言为有穷集合时，用**枚举**的方法。
- 当语言为无穷集合时，常用**文法**描述的方法。

## 分类

[乔姆斯基](https://www.chomsky.info)于1956年建立形式语言体系，他把文法分成四种类型：0 ，1 ，2 ，3 型。

- **0 型文法** ( 短语文法，图灵机 )

  产生式形如：$\alpha \to \beta$

  其中：$\alpha \in (V_T \cup V_N)^*V_N(V_T \cup V_N)^*$，即至少含有一个非终结符；$\beta \in (V_T \cup V_N)^*$

- **1 型文法** ( 上下文有关文法，线性界限自动机 )

  产生式形如：$\alpha \to \beta$

  其中： $|\alpha| \leqslant |\beta|$，仅 $S\to \varepsilon$ 例外

- **2 型文法** ( 上下文无关文法，非确定下推自动机 )

  产生式形如：$A \to \beta$

  其中：$A\in V_N$；$\beta \in (V_T \cup V_N)^*$

- **3 型文法** ( 正规文法，有限自动机 )

  1. 左线性文法

     产生式形如： $A \to B\alpha$ 或 $A \to \alpha$

     其中：$\alpha \in V_T^*$； $A ,B\in V_N$

  2. 右线性文法

     产生式形如： $A \to \alpha B$ 或 $A \to \alpha$

     其中：$\alpha \in V_T^*$； $A ,B\in V_N$

## 联系和区别

由四类文法的定义可知，4个文法类的定义**是逐渐增加限制的**。

- 1~3型文法都属于0型文法；
- 2、3型文法如果存在形如$A\to \varepsilon$的产生式，则不属于1型文法，如不存在则属于1型文法；
- 3型文法属于2型文法；

区别：

- 1型文法中不允许有形如$A\to \varepsilon$的产生式存在，而2、3型文法允许；
- **0、1型文法**的产生式**左部**存在**含有终结符号的符号串**或**两个以上的非终结符**，而**2、3型文法**的产生式**左部**只允许是**单个的非终结符号**；

# 推导

从一个句型到另一个句型的推导往往不唯一，可以分为

- **最左推导**：任何一步$\alpha  \Rightarrow  \beta$都是对$\alpha$中的最**左**非终结符进行替换，例如 $E+E$$\Rightarrow$$i+E$$\Rightarrow$$i+i$ 
- **最右推导**：任何一步$\alpha  \Rightarrow  \beta$都是对$\alpha$中的最**右**非终结符进行替换，例如 $E+E$$\Rightarrow$$E+i$$\Rightarrow$$i+i$

一般称**最右推导**为**规范推导**，**规范推导的逆过程**便是**规范规约**（最左规约）。

# 语法树

## 语法树

给定文法G，对于G的任何句型都能构造与之关联的**语法树**（推导树、语法分析树、分析树）。

这棵树满足下列4个条件：

1. 每个结点都用G的一个终结符或非终结符标记；
2. 根的标记是开始符号；
3. 内部结点一点是非终结符。如果某内部结点A有n个分支，它的所有子结点从左到右标记为$n_1,n_2,\cdots ,n_n$，则$A\to n_1,n_2,\cdots ,n_n$一定是文法G的一个产生式；
4. 如果某结点标记为$\varepsilon$，则它必须为叶结点且其是父结点的唯一子结点；

::: info 内部结点

内部结点是指非树叶结点，内部结点也包括根结点。

:::

语法树可以**表示一个句型的推导过程**。

> 例：
>
> 1. 文法$G(E)$ ： $E \to i | E+E | E*E | (E)$ 的句子 $(i*i+i)$ 的语法树
>
>    ![](77.png)
>
> 2. 下图的推导树是文法G的句型aabbaa的推导过程。
>
>    把aabbaa叫做推导树的结果，把推导树叫做句型aabbaa的语法树。
>
>    ![](79.png)

## 文法的二义性

若一个文法存在**某个句子对应两棵不同的语法树**，或者说，若一个文法存在**某个句子有两个不同的最左推导或最右推导**，则称这个文法是**二义**的。

> 例：
>
> ![](78.png)
>
> <br>
>
> ![](80.png)

## 二义性的消除

对于二义性文法的句子，当编译程序对它的结构进行语法分析时，会产生多种不同的解释，由于语法结构的这种不确定性，必然导致语义处理上的不确定性。

**文法的二义性和语言的二义性是两个不同的概念**。

对于一个二义性的文法$G$，如果能找到一个非二义性的文法$G'$，使得$L(G')=L(G)$，则称**该二义性文法的二义性是可以消除的**。如果找不到$G'$，则二义性文法的描述的语言为**先天二义性**的。

::: info 总结

如果一个语言的每一个文法都是二义的，那么这个语言是先天二义性的。

:::

文法二义性消除的两种方法：

1. 不改变文法中原有的语法规则，仅加进一些语法的非形式规定。例如加进运算符的优先顺序和结合规则等。

2. 构造一个等价的无二义性文法。通过添加新的非终结符来消除文法中的二义性。

   > 例：将文法G改写为无二义性的文法$G'$
   >
   > ![](81.png)

::: tip

二义性问题是不可判定问题，即不存在一个算法能在有限步骤内，确切地判定一个文法是否是二义的。

:::

::: info 描述程序设计语言时，对于上下文无关文法的限制

1. 不含 $P\to P$ 形式的产生式；
2. 每个非终结符 $P$ 必须能推出终结符号串；

:::

# 语法分析

语法分析的任务：**分析一个文法的句子结构**。

语法分析器的功能：按照文法的产生式，识别输入符号串是否为一个句子。

![](83.png)

语法分析的方法通常分为两类，即**自上而下**分析方法和**自下而上**分析方法。

- 自上而下分析法：**从文法的开始符号出发**，根据文法的规则进行推导，最终推导出给定的句子来。

  ![](84.png)

- 自下而上分析法：**从给定的输入串开始**，根据文法规则逐步进行归约，直至归约到文法的开始符号为止。

  ![](85.png)

# 自上而下的语法分析

自上而下就是从文法的开始符号出发，向下推导，推出句子。

## 递归下降分析法

递归下降分析法是一种自上而下的分析方法，文法的每个非终结符对应一个递归过程。

### 多个产生式候选带来的问题

#### 回溯

分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“回溯”。

![](86.png)

#### 文法左递归问题

一个文法是含有左递归的，如果存在非终结符 P1

![](87.png)

### 构造不带回溯的自上而下分析算法

#### 消除文法的左递归性

假定关于非终结符 P 的规则为 $P\to P\alpha|\beta$，我们可以把 P 的规则等价地改写为 $P\to \beta P'$和$P'\to \alpha P'|\varepsilon$

![](89.png)

假定 P 关于的全部产生式是 $P\to P\alpha _1|\cdots |P\alpha _m |\beta _1|\cdots |\beta _n$，那么消除 P 的直接左递归性就是把这些规则改写成：$P\to \beta _1P'|\cdots |\beta _nP'$ ， $P'\to \alpha _1P'|\cdots  |\alpha _mP'|\varepsilon$

> 直接左递归的消除
>
> ![](90.png)
>
> 间接左递归的消除
>
> ![](91.png)
>
> <br>
>
> ![](92.png)

#### 克服回溯

回溯发生的原因在于候选式**存在公共的左因子**，如：$A\to \alpha \beta _1∣\alpha \beta _2$ 。此时如果输入串待分析的字符串前缀为 $\alpha$，则选用哪个候选式以寻求与输入串匹配就难以确定。

倘若候选式不含公共左因子，则推导出的首字符能与输入串匹配的那个候选式便是惟一的匹配。

![](93.png)

![](94.png)

## LL(1)分析法

LL(1)分析法又称预测分析法，是一种不带回溯的非递归自上而下分析法。

LL(1)的含义是：

- 第一个L表明自上而下分析是从左至右扫描输入串的；
- 第二个L表明分析过程中将用最左推导；
- “1”表明只需向右查看一个符号就可决定如何推导（即可知用哪个产生式进行推导）。

> 类似地，也可以有LL(k)文法，也就是向前查看k个符号才能确定选用哪个产生式，不过LL(k)(k>1)在实际中极少使用。

### 表驱动的LL(1)分析器

LL(1)分析法的基本思想是根据输入串的当前输入符号来唯一确定选用某条产生式来进行推导；当这个输入符号与推导的第一个符号相同时，再取输入串的下一个符号，继续确定下一个推导应选的规则；如此下去，直到推导出被分析的输入串为止。

一个LL(1)分析器由一张**LL(1)分析表**（也称预测分析表）、一个**先进后出分析栈**和一个**控制程序**(表驱动程序)组成。

![](95.png)

关于LL(1)分析器的说明：

1. 输入串是待分析的符号串，它以界符 ‘#’ 作为结束标志。

   $\ \in V_T$但不是文法符号，是由分析程序自动添加的。

2. 分析栈中存放分析过程中的文法符号。

   分析开始时栈底先放入一个‘#’ ，然后再压入文法的开始符号；当分析栈中仅剩‘#’ ，输入串指针也指向串尾的‘#’时，分析成功。

3. 分析表用一个矩阵（或二维数组）M表示，它概括了相应文法的全部信息。

   矩阵的每一行与文法的一个非终结符相关联，而每一列与文法的一个终结符或界符‘#’相关联。

   分析表元素M[A,a]中的内容为一条关于A的产生式，表示当A面临输入符号a时当前推导所应采用的候选式；当元素内容为空白（空白表示“出错标志”）时，则表明A不应该面临这个输入符号a，即输入串含有语法错误。

4. 控制程序根据分析栈顶符号x和当前输入符号a来决定分析器的动作。

   - 若x＝a＝‘#’ ，则分析成功，分析器停止工作。

   - 若x＝a ≠ ‘#’ ，即栈顶符号x与当前扫描的输入符号a匹配；则将x从栈顶弹出，输入指针指向下一个输入符号，继续对下一个字符进行分析。

   - 若x为一非终结符A，则查M[A,a]：

     若M[A,a]中为一个A的产生式，则将A自栈顶弹出，并将M[A,a]中的产生式右部符号串按逆序逐一压入栈中；如果M[A,a]中的产生式为$A\to \varepsilon$，则只将A自栈顶弹出。

     若M[A,a]中为空，则发现语法错误，调用出错处理程序进行处理。

![](96.png)

![](97.png)

### LL(1)分析表的构造

![](98.png)

![](99.png)

![](100.png)

**FIRST集构造方法**：对文法中的每一个非终结符X构造FIRST(X)，其方法是连续使用下述规则，直到每个集合的FIRST不再增大为止。

1. 若 $X\in V_T$  ，则 FIRST(X) ＝ {X}。

2. 若 $X\in V_N$  ，且有产生式$X\to a \cdots$，则把 a 加入到 FIRST(X) 中；若$X\to \varepsilon$也是一条产生式， 则把$\varepsilon$也加到 FIRST(X) 中。

3. 若有$X\to Y \cdots$，且$Y\in V_N$，则将FIRST(Y)中的所有非$\varepsilon$元素都加入到FIRST(X)中。

4. 若有$X\to Y_1Y_2\cdots Y_k$，且$Y_1 \sim Y_i$都是非终结符，
   - 若$Y_1\sim Y_{i-1}$的候选式都有$\varepsilon$存在，则把FIRST($Y_j$)($j=1,2,\cdots,i$)的所有非$\varepsilon$元素都加入到FIRST(X)中；
   - 若$Y_1\sim Y_k$均含有$\varepsilon$产生式时，应把$\varepsilon$也加到FIRST(X)中。

::: tip

对终结符a而言，FIRST('a')={a}，因而无需构造。

:::

> ![](101.png)

**FOLLOW集构造方法**：对文法的每个非终结符A构造FOLLOW(A)的方法是连续使用下述规则，直到每个FOLLOW不再增大为止。

1. 对文法开始符号S，置#于FOLLOW(S)中（由语句括号“#S#”中的S#得到）。
2. 若有$A\to \alpha B\beta$（$\alpha$可为空），则将$FIRST(\beta)$除了$\{\varepsilon \}$加入到FOLLOW(B)中。  
3. 若有$A\to \alpha B$或$A\to \alpha B\beta$，且$\beta \Rightarrow ^* \varepsilon$（即$\varepsilon \in FIRST(\beta)$），则把FOLLOW(A)加到FOLLOW(B)中（此处的$\alpha$也可为空)



::: tip

FOLLOW集合不存在$\varepsilon$

:::

> ![](102.png)
>
> 视频：https://www.bilibili.com/video/BV11t411V74n?t=2384.1&p=14
>
> ![](88.png)

**构造分析表M**

构造文法 G 的分析表 M[A,a] ，就是确定每个产生式 $A\to \alpha$ 在表中的位置。

1. 对文法G[S]的每个产生式 $A\to \alpha$ 执行以下2、3步。
2. 对每个终结符$a\in FIRST(A)$，把 $A\to \alpha$ 加入到M[A,a]中，其中$\alpha$为含有首字符a的候选式或为惟一的候选式。
3. 若$\varepsilon \in FIRST(A)$，则对任何属于FOLLOW(A)的终结符b，将$A\to \varepsilon$加入到M[A,b]中。
4.  把所有无定义的M[A,a]标记为“出错”。

> https://www.bilibili.com/video/BV11t411V74n?t=1980.8&p=16
>
> 根据上面G(E)的FIRST集和FOLLOW集，构造分析表
>
> ![](103.png)

## LL(1) 文法与二义性

如果一个文法是左递归或二义的，那么 M 至少含有一个多重定义入口。

如果一个文法的分析表 M **不含多重定义入口**，则称它是一个LL(1)文法，它所定义的语言恰好就是它的分析表所能识别的全部句子。

一个上下文无关文法是**LL(1)文法的充分必要条件**是：对每一个非终结符A的任何两个不同产生式$A\to \alpha │\beta$，有下面的条件成立：

1. $FIRST(\alpha )\cap FIRST(\beta )＝\phi$；

   意味着A的每个候选式都不存在相同的首字符，它避免了在分析表的同一栏目内出现多个产生式的情况，即避免了多重入口。

2. 假若$\beta  \Rightarrow ^* \varepsilon$，则有$FIRST(\alpha)∩FOLLOW(A)＝\phi$；

   避免了在分析表的同一栏目内出现$A\to \alpha$和$A\to \varepsilon$（同样是避免多重入口）。

   > 例如文法$G[S]$：$S\to Aa|b$ $A\to a|\varepsilon$，有$FIRST(A)=\{a,\varepsilon \}$，$ FOLLOW(A)＝\{a \}$；
   >
   > 此时文法对应的中M[A, a] 栏里必然有两个产生式$A\to \alpha$和$A\to \varepsilon$存在，即形成了多重入口，$FIRST('a')\cap FIRST(A)\neq \phi$；

::: tip

LL(1)文法首先是**无二义**的，其次是**不含左递归**和**消除回溯**的。

:::

# 自下向上的语法分析

自下向上的语法分析与自顶向下的语法分析相比，它无需消除左递归和回溯；

对某些二义文法，也可以采用自下向上分析方法，因此，自下向上分析的适用范围更大。

## 自下而上分析的基本问题

自下而上分析法就是从输入串开始，逐步进行归约，直到归约到文法的开始符号。

::: info 归约

根据文法的产生式规则，把产生式的右部替换成左部符号。

:::

自下而上分析法是一种“**移进—归约**”法，这是因为在自下而上分析过程中采用了一个先进后出的分析栈。

把输入符号自左至右逐个移进分析栈，并且**边移入边分析**，一旦栈顶的符号串形成某个句型的句柄就进行一次归约，即用相应产生式的左部非终结符替换当前句柄。

接下来继续查看栈顶是否形成新的句柄，若为句柄则再进行归约；若栈顶不是句柄则继续向栈中移进后续输入符号。不断重复这一过程，直到将整个输入串处理完毕。

若此时分析栈只剩有文法的开始符号则分析成功，即确认输入串是文法的一个句子；否则，即认为分析失败。

![](104.png)

### 短语

> https://www.bilibili.com/video/BV11t411V74n?t=1769.4&p=17

1. **短语**

   设 $\alpha A \delta$ 是文法$G[s]$的一个句型，如果有：$S\Rightarrow ^* \alpha A\delta$且$A\Rightarrow ^+\beta$

   则称$\beta$**是句型$\alpha \beta \delta$关于非终结符$A$的一个短语**，或称$\beta$**是$\alpha \beta \delta$的一个短语**。

   特别是有$A\to \beta$产生式时，$\beta$为句型$\alpha \beta \delta$的一个**直接短语**或**简单短语**。

   > 例：文法$G(E)$ ： $E \to i | E+E | E*E | (E)$ 
   >
   > - 由$E\Rightarrow ^*E+E*E\Rightarrow E+E*i$，可知$i$是$E+E*i$的一个短语，并且是直接短语。
   > - 由$E\Rightarrow ^*E+E\Rightarrow ^+ E+E*i$，可知$E*i$是$E+E*i$的一个短语，但不是直接短语。
   > - $E+E*i$是$E+E*i$自身的短语。

2. **句柄**

   一个句型的**最左直接短语**称为该句型的句柄。

   一个句型的**直接短语可能不止一个**，但最**左直接短语则是唯一**。

3. **素短语**

   素短语是指这样一种短语，它至少包含一个终结符，并且除自身之外，不再包含其它更小的素短语。

   最左素短语则是指处于句型最左边的那个素短语。

语法树的某个内部结点连同它的所有后代组成了一棵**子树**，只含有单层分枝的子树称为**简单子树**。

子树与短语的联系十分密切，在子树中

1. **短语**

   子树的末端结点组成的符号串是相对于子树根的短语；

   由内部结点向下生长的全部树叶自左至右的排列。

   每个内部结点都有一个短语，也可能多个内部结点的短语是同一个。

2. **直接短语**

   简单子树的末端结点组成的符号串是相对于简单子树根的直接短语；

   内部结点直接一步生长出来的结点全部由树叶组成（即以该内部结点为根的子树是简单子树），该全部树叶自左至右的排列即为直接短语。

3. **句柄**

   最左简单子树的末端结点组成的符号串为句柄； 

4. **素短语**

   子树的末端结点组成的含终结符的符号串，且在该子树中不再含有终结符的更小子树。

![](82.png)

![](114.png)

::: tip 比较

- 直接短语是在短语的基础上增加了只能向下生长一步且向下生长一步所产生的结点都是树叶结点这一限制；
- 句柄是在直接短语的基础上增加了“最左”这一限制；

::: 

### 规范归约

假定$\alpha$是文法 G 的一个句子，有一个序列 $\alpha _n,\alpha _n-1,\cdots,\alpha _0$，如果此序列满足：

1. $\alpha _n = a$
2. $\alpha _0 =S$，$S$是文法的开始符号
3. 对任何 $i$， $0 \leqslant i \leqslant n$ ，$\alpha _{i-1}$ 是从 $\alpha _i$ 经把句柄替换成为相应产生式左部符号而得到的

则称次序列是$\alpha$的一个**规范归约**。

由规范推导推出的句型称为**规范句型**。

::: tip 为什么要叫规范归约

因为规范归约得到的分析树一定是与语法树一致的。

:::

## 算符优先分析法

考虑二义文法文法 $G(E)：E \to i| E+E|E-E|E*E|E/E|(E)$，它的句子有几种**不同的规范归约**。

> ![](105.png)

归约即计算表达式的值。归约顺序不同， 则计算的顺序也不同，结果也不一样。

如果规定算符的优先次序，并按这种规定进行归约，则归约过程是唯一的。所谓算符优先分析法就是定义算符 ( 终结符 ) 之间的某种优先关系，借助于这种关系寻找“可归约串”和进行归约。起决定作用的是相继两个算符 ( 终结符 ) 之间的优先关系。

定义任何两个可能相继出现的终结符 a 与 b 的三种优先关系：

- 𝑎 ⋖ 𝑏：𝑎的优先级低于𝑏
- 𝑎 ≖ 𝑏：𝑎的优先级等于𝑏
- 𝑎 ⋗ 𝑏：𝑎的优先级高于𝑏

::: tip

a⋖b 并不意味着 b⋗a ，如( ⋖ + 和 + ⋖  (

::: 

### 算符优先文法

一个文法，如果它的任一产生式的右部都不含两个相继 ( 并列 ) 的非终结符，即不含 $...QR...$ 形式的产生式右部，则我们称该文法为**算符文法**。

![](106.png)

::: tip

**算符优先文法**首先应是一个**算符文法**。

:::

### 算符优先关系表 

如果能把终结符之间的优先关系都找出来，那么我们就能得到一张二维表。

![](107.png)

### 构造优先关系表

![](111.png)

为了找出所有满足关系“ ⋖ ”和“ ⋗ ”的终结符对，我们需要对G[S]的每个非终结符P构造两个集合FIRSTVT(P)和LASTVT(P)：

![](108.png)

::: tip

与LL(1)文法相比，

- FIRST(A)是推导出的第一个终结符集，而FIRSTVT是首先遇到的终结符集；
- FOLLOW(A)是指紧跟非终结符A后的终结符集，而LASTVT是最后遇到的终结符集。

:::

**FIRSTVT集的构造方法**：

![](109.png)

**LASTVT集的构造方法**：

![](110.png)

> 其它例子：https://www.bilibili.com/video/BV11t411V74n?t=1942.8&p=19
>
> ![](112.png)
>
> <br>
>
> ![](113.png)
>
> <br>
>
> ![](107.png)

### 算符优先分析算法的设计

由于算符优先分析法**不是一种规范归约的分析方法**，它仅在终结符之间定义了优先关系而未对非终结符定义优先关系，这样就无法使用优先关系表去识别由单个非终结符组成的可归约串。

因此，算符优先分析法实际上不是用句柄来刻画“可归约串”，而是用**最左素短语**来刻画“可归约串”。

![](115.png)

 查找最左素短语的方法：

1. 最左子串法

   ![](116.png)

2. 语法树法

   ![](117.png)

算符优先分析法特点

- 优点 : 简单，快速；
- 缺点 : 可能错误接受非法句子，能力有限；

### 优先函数

用优先关系表来表示每对终结符之间的优先关系时，存在的缺点是存储量大、查找费时。

因此使用优先函数，对终结符a、b之间的优先关系比较转换为两个优先函数值的比较。好处是节省空间和便于进行比较运算。

![](118.png)

::: tip 

- 对应一个优先关系表的优先函数不是惟一的；只要存在一对，就存在无穷多对。

- 许多优先关系表不存在对应的优先函数。

  ![](119.png)

::

根据优先关系表构造优先函数的两种方法：

1. 关系图法

   ![](120.png)

2. 直接构造

   ![](121.png)

## LR分析法

LR分析法是一种**自底向上进行规范归约的语法分析方法**，LR指“自左向右扫描和自底向上进行归约”。

LR分析法的一个主要缺点是，若用手工构造分析器则工作量相当大，因此必须求助于自动产生LR分析器的产生器。

### LR分析器的工作原理

规范归约的关键问题是寻找句柄 。

LR 分析方法：把已移入符号栈的内容及根据产生式推测未来可能遇到的输入符号综合抽象成**状态**；由栈顶的状态和现行的输入符号唯一确定每一步工作。

![](122.png)

LR分析器的核心是一张分析表

![](123.png)

- ACTION[s, a]：当状态 s 面临输入符号 a 时 ，应采取什么动作。
- GOTO[s, X]：状态 s 面对文法符号 X 时，下一状态是什么。
- $s_j$：移进，指把下一状态j和现行输入符号a移进栈，下一输入符号变成现行输入符号。
- $r_j$：归约，指按文法的第j个产生式进行归约；
- acc：表示分析成功；
- 空白格：出错

![](124.png)

输入串i+i*i的归约过程用语法树表示，如下图所示。

![](125.png)

从分析过程可以看出，每次归约恰好是语法树中的句柄，这种归约过程实际上就是修剪语法树的过程，直到归约到树根（也即文法开始符E）为止。

因此，LR分析法解决了在语法分析过程中寻找每一次归约的句柄问题。

---

我们主要关心的问题是**如何由文法构造LR分析表**。

对于一个文法，如果能够构造一张分析表，使得它的每个入口均是惟一确定的，则称这个文法为**LR文法**。

一个文法如果能用一个每步最多向前检查k个输入符号的LR分析器进行分析，则这个文法就称为**LR(k)文法**。

对于一个文法，如果它的任何“移进—归约”分析器都存在这样的情况：尽管栈的内容和下一个输入符号都已了解，但仍无法确定是“移进”还是“归约”，或者无法从几种可能的归约中确定其一，则该文法是**非LR(1)的**。

::: tip

LR文法肯定是无二义的，一个二义文法决不会是LR文法；但是，LR分析技术可以进行适当修改以适用于分析一定的二义文法。

:::

介绍四种分析表的构造方法，它们是：

1. LR(0)表构造法：这种方法局限性很大，但它是建立一般LR分析表的基础。
2. SLR(1)表(即简单LR表)构造法：这种方法较易实现又极有使用价值。
3. LR(1)表(即规范LR表)构造法：这种表适用大多数上下文无关文法，但分析表体积庞大。
4. LALR表(即向前LR表)构造法：该表能力介于SLR(1)和LR(1)之间。

### LR(0)分析器

#### LR(0)项目集规范族的构造

- 字的前缀，是指该字的任意首部，例如字abc的前缀有ε、a、ab或abc。
- 活前缀，是指**规范句型的一个前缀**，这种前缀**不含句柄之后的任何符号**。

在LR分析工作过程中的任何时候，栈里的文法符号(自栈底而上)$X_1X_2...X_m$应该构成活前缀，把输入串的剩余部分匹配于其后即应成为**规范句型**（如果整个输入串确为一个句子的话）。

规范归约过程中，保证分析栈中总是活前缀 ，就说明分析采取的移进—归约动作是正确的。

---

项目表示我们在分析过程中看到了产生式多大部分。

文法G的每个产生式的右部添加一个圆点称为G的LR(0)项目。

- 圆点“ • ”指出了分析过程中扫描输入串的当前位置；
- 圆点“ • ”前的部分为已经扫描过的符号串，构成了一个活前缀；
- 圆点“ • ”后的部分为待扫描的符号串；

![](126.png)

![](127.png)

由于产生式的项目与识别NFA的状态相对应，因此可以用项目来构造NFA。

![](128.png)

因为在NFA中发生状态转换的非终结符B不可能由输入串（由终结符组成）提供，而必须由NFA的归约来产生，这就要启动另一路NFA来识别（归约出）所需要的非终结符B。

例如，若非终结符B的产生式为$B\to ef$，则在含项目$A\to a•Bc$的状态中就应加入项目$B\to •ef$，称为A的闭包项。也即，要获得非终结符B，就必须先识别B的产生式，这就意味着在识别A的NFA中嵌入了识别B的NFA。

![](129.png)

如果闭包项$B\to •ef$中的e是另一个非终结符R，即闭包项为$B\to •Rf$的话，则$B\to •Rf$仍然是一个待约项目，也即在图中还应加入识别R的闭包项。

如此下去，**不断在同一个状态中加入闭包项直至没有新的“待约项”出现为止**。这样，就把**识别活前缀的NFA确定化，形成了一个识别产生式的DFA**，此时的状态也可能不再是含有一个项目，而是含有多个项目，我们称其为**项目集**。

构成识别一个文法活前缀的DFA的项目集（状态）的全体称为这个文法的LR(0) **项目集规范族**。

![](130.png)

![](131.png)

![](132.png)

#### LR(0)分析表的构造

::: tip 拓广文法

![](133.png)

:::

假若一个文法 G 的拓广文法 G‘ 的活前缀识别自动机中的每个状态 ( 项目集 ) 不存在下述情况：

1. 既含移进项目又含归约项目
2. 含有多个归约项目

则称 G 是一个 LR(0) 文法。

对于LR(0)文法，我们可直接从它的项目集规范族C和活前缀自动机的状态转换函数GO构造出LR分析表。

![](134.png)

![](135.png)

由于假定LR(0)文法规范族的每个项目集不含冲突项目，因此按上述方法构造的分析表的每个入口都是惟一的(即不含多重定义)。

我们称如此构造的分析表是一张LR(0)表，使用LR(0)表的分析器叫做一个LR(0)分析器。

> ![](136.png)
> <br>
> ![](137.png)
>
> <br>
> ![](138.png)

项目集的**构造原则**是：只要紧随在“ • ”之后的符号是非终结符，则该非终结符所有以“ • ”开头的项目全都纳入到该项目集；如果这些新纳入的项目中，又在“ • ”后紧随出现新的非终结符，则这些新的非终结符所有以“• ”开始的项目也全部纳入该项目集。

::: tip 检查所构造的DFA是否完整

对一个项目集来说，除了归约项目之外，对于其余移进项目，“ • ”之后有多少个不同的首字符(包括非终结符)，就要引出多少条有向边到不同的项目集(也可能有一条有向边到此项目集自身)。

:::

掌握了上述构造原则和方法后，则可在写出拓广文法后就直接画出该文法的DFA，而无需再列出LR(0) 的所有项目和构造LR(0) 项目集规范族。

### SLR(1)分析器

### LR(1)分析器

### LALR(1)分析器
