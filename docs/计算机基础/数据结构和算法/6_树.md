---
title: 树
index: 6
---

## 树的定义

树：由 $n(n>=0)$ 个结点的有限集。当$n = 0$时，称为**空树**。

在任意**一棵非空树中应满足**：

1. 有且仅有一个特定的称为根的结点。
2. 当 $n>1$ 时，其余结点可分为 $m(m>0)$ 个**互不相交的有限集合** $T_1,T_2,\cdots,T_m$ 其中每个集合本身又是一棵树，并且称为根的**子树**。

<img src="../../../images/计算机/数据结构和算法/4.png"/>

非空树的**特性**：

1. 有且仅有一个根节点。
2. 树的**根结点没有前驱**，除根结点外的所有结点**有且只有一个前驱**。
3. 树中所有结点都可以**有零个或多个后继**。
4. 没有后继的结点称为**叶子结点**（或终端结点）。
5. 有后继的结点称为**分支结点**（或非终端结点）。

树的定义是递归的，即在树的定义中又用到了其自身，**树是一种递归的数据结构**。树作为一种逻辑结构，同时也是一种分层结构，因此树适合于表示具有层次结构的数据。

树中的某个结点（除根结点外）最多只和上一层的一个结点有直接关系，根结点没有直接上层结点，因此在$n$个结点的树中有$n-1$条边。 而树中每个结点与其下一层的零个或多个结点都有直接关系。

## 树的基本概念

<img src="../../../images/计算机/数据结构和算法/3.png" style="zoom:50%;" />

- 祖先结点：根结点 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的祖先。如：K 结点的祖先结点是 H、D、A。
- 子孙结点：一个结点下面所有的结点都为子孙结点。如：B 结点的子孙结点是 E、F、J。
- 双亲结点（父节点）：一个结点的直接前驱结点。如：B 结点的双亲结点是 A。
- 孩子节点：一个结点的直接后继结点。如：B 结点的孩子结点是 E、F。
- 兄弟节点：一个结点的前驱的其他后继结点。如：E 结点的兄弟结点是 F。
- 堂兄弟节点：除兄弟节点外的同一层结点。如：E 结点的兄弟结点是 G、H、I。
- **路径**：树中两个结点之间的路径是由这**两个结点之间所经过的结点序列**构成的，由于树中的分支是有向的，即从双亲指向孩子，所以**树中的路径是从上向下的， 同一双亲的两个孩子之间不存在路径**。
- **路径长度**：路径长度是路径上**所经过的边的个数**。
- **结点的层次（深度）**：从树根开始定义，**从上往下数**，默认根结点为第 1 层，它的子结点为第 2 层，以此类推。
- **结点的高度**：从叶结点开始**自底向上**逐层累加的。
- **树的高度**（深度）：总共多少层。
- **结点的度**：树中一个结点的孩子个数。
- **树的度**：各结点的度的最大值。
- m 叉树：每个结点最多只能有 m 个孩子。
- 有序树：从逻辑上看，树中结点的各子树从左到右是有次序的，不能互换。
- 无序树：从逻辑上看，树中结点的各子树从左到右是无次序的，可以互换。、
- 森林：森林是$m(m>=0)$棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给$m$棵独立的树加上一个结点，并把这$m$棵树作为该结点的子树，则森林就变成了树。

![](https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png)

## 常见考点

1. 结点数 = 总度数 + 1

2. 度为 $m$ 的树、$m$ 叉树的区别

   |                度为 $m$ 的树                |                   $m$ 叉树                   |
   | :-----------------------------------------: | :------------------------------------------: |
   | 任意结点的度小于等于 $m$（最多 $m$ 个孩子） | 任意结点的度小于等于 $m$$（最多 $m$ 个孩子） |
   | 至少有一个结点的度等于 $m$（有 $m$ 个孩子） |          允许所有结点的度都小于 $m$          |
   |      一定是非空树，至少有 $m+1$ 个结点      |                  可以是空树                  |

3. 度为 $m$ 的树中第 $i$ 层至多有 $m^{i-1}$ 个结点。（$i>=1$）

   $m$ 叉树第 $i$ 层至多有 $m^{i-1}$ 个结点。（$i>=1$）

   <img src="../../../images/计算机/数据结构和算法/5.png" style="zoom: 80%;" />

4. 高度为 $h$ 的 $m$ 叉树至多有 $\frac{(m^h-1)}{(m-1)}$ 个结点。

   如上图，由等比数列求和公式 $\frac{a_1\times(1-q^n)}{1-q}$ 可得

5. 高度为 h 的 m 叉树至少有 h 个结点；

   高度为 h 、度为 m 的树至少有 h+m-1 个结点。

   <img src="../../../images/计算机/数据结构和算法/6.png" style="zoom: 80%;" />

6. 具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\lceil \log_m(n(m-1)+1) \rceil$（向上取整）。

   高度最小的情况即所有结点都有 $m$ 个孩子

   $\frac{(m^{h-1}-1)}{(m-1)}<n<=\frac{(m^h-1)}{(m-1)}$

   $m^{h-1}<n(m-1)+1<=m^h$

   $h -1< \log_m(n(m-1)+1)<=h$

## 题目

1. 一棵有 $n$ 个结点的树的所有结点的度数之和为（<span style="color:red;">A</span>）。

   A. n-1	B. n	C. n+1	D. 2n

2. 树的路径长度是从树根到每个结点的路径长度的（<span style="color:red;">A</span>）。

   A.总和	B.最小值	C.最大值	D.平均值

   > 树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是树的高度减1。

3. 度为4、高度为h的树，（<span style="color:red;">A</span>）。

   A.至少有h+3个结点	B.至多有4h-1个结点	C.至多有4h个结点	D.至少有h+4个结点

4. 在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结 点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是（<span style="color:red;">B</span>）。

   A. 41	B. 82	C. 113	D. 122

## 二叉树的概念

与树相似，二叉树也以递归的形式定义。

二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树是 $n(n>=0)$ 个结点的有限集合： 

- 或者为空二叉树，即 $n=0$。
- 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树 又分别是一棵二叉树。

![](https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_definition.png)

二叉树是**有序树**，左右子树不能颠倒，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。

<br>

二叉树与度为2的有序树的区别：

1. 度为2的树至少有3个结点，而二叉树可以为空。
2. 度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子, 则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言的，而是确定的。

<br>

二叉树的5种基本形态：

![](../../../images/计算机/数据结构和算法/7.png)

## 特殊二叉树

### 满二叉树

一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。

对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右。

<img src="../../../images/计算机/数据结构和算法/53.png" style="zoom: 40%;" />

<br>

<img src="../../../images/计算机/数据结构和算法/54.png" style="zoom: 50%;" />

特点：

1. 只有最后一层有叶子结点
2. 不存在度为1的结点
3. 对于编号为 $i$ 的结点，若有双亲，则其双亲为质 $\lfloor i/2 \rfloor$ , 若有左孩子，则左孩子为 $2i$ ，若有右孩子，则右孩子为 $2i+1$ 。



### 完全二叉树

高度为 $h$、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二 叉树中编号为 $1 \sim  n$ 的结点一 一对应时，称为完全二叉树。

满二叉树是是一种特殊的完全二叉树，但完全二叉树不一定是满二叉树

<img src="../../../images/计算机/数据结构和算法/55.png" style="zoom: 40%;" />

<br>

<img src="../../../images/计算机/数据结构和算法/54.png" style="zoom: 50%;" />

特点：

1. 只有最后两层可能有叶子结点
2. 最多只有一个度为1的结点，且该结点只有左孩子而无右孩子
3. $i\le \lfloor n/2 \rfloor$ 为分支结点，$i >  \lfloor n/2 \rfloor$为叶子结点
4. 若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $n/2$）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。

### 二叉排序树

左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点 的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。

![](../../../images/计算机/数据结构和算法/8.png)

### 平衡二叉树

树上任意一个结点的左子树和右子树的深度之差不超过1。

![](../../../images/计算机/数据结构和算法/9.png)

## 二叉树常考性质

1. 非空二叉树上中度为0、1、2的结点个数分别为$n_0,n_1,n_2$，则 $n_0=n_2+1$。（叶子结点比二分支结点多一个）

   ![](../../../images/计算机/数据结构和算法/10.png)

2. 二叉树第 $i$ 层最多由 $2^{i-1}$ 个结点（$i\ge1$）；m叉树第 $i$ 层最多由 $m^{i-1}$ 个结点（$i\ge1$）

3. 高度为 $h$ 的2叉树至多有 $2^h-1$ 个结点。（刚好是满二叉树）；高度为 $h$ 的 $m$ 叉树至多有 $\frac{(m^h-1)}{(m-1)}$ 个结点。

4. 具有 $n(n>0)$ 个结点的完全二叉树的高度 $h$ 为 $\lceil \log_2(n+1) \rceil$或 $\lceil \log_2(n) \rceil +1$。

   当该完全二叉树是满二叉树时：

   ![](../../../images/计算机/数据结构和算法/11.png)

   当该完全二叉树不是满二叉树时：

   ![](../../../images/计算机/数据结构和算法/12.png)

5. 对于完全二叉树，可以由结点数 $n$ 推出度为0、1、2的结点的个数为$n_0,n_1,n_2$。

   ![](../../../images/计算机/数据结构和算法/13.png)

   $n_0+n_2=2n_2+1$是奇数，$2k=n_0+n_1+n_2=n_1+2n_2+1$，因此 $n_1$ 只能是奇数1。

## 二叉树的存储结构

### 顺序存储结构

二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。

**完全二叉树和满二叉树采用顺序存储比较合适**，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地**节省存储空间**，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。

但对于一般二叉树树而言，采用顺序存储会浪费极大空间。

![](../../../images/计算机/数据结构和算法/14.png)

```cpp
#define MaxSize 100
struct TreeNode {
    int val;// 结点中的数据元素
    bool isEmpty;// 结点是否为空
};
```

### 链式存储结构

由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。

二叉链表至少包含3个域：数据域data、左指针域Ichild、右指针域rchild。实际上在不同的应用中，还可以增加某些指针域，如增加指向父结点的指针后，变为三叉链表的存储结构。

![](../../../images/计算机/数据结构和算法/15.png)

```cpp
typedef struct BiTNode {
    int val;
    struct BiTNode *lChild, *rChild;
} BiTNode, *BiTree;
```





## 二叉树的遍历

### 先中后序遍历

二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。

按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点 在何时被访问。

![](../../../images/计算机/数据结构和算法/16.png)

![](../../../images/计算机/数据结构和算法/17.png)

```cpp
// 先序遍历
void PreOrder(BiTree T) {
  if (T != nullptr) {
    visit(T);// 访问根节点
    PreOrder(T->lChild);// 递归遍历左子树
    PreOrder(T->rChild);// 递归遍历右子树
  }
}
```

```cpp
// 中序遍历
void PreOrder(BiTree T) {
  if (T != nullptr) {
    PreOrder(T->lChild);// 递归遍历左子树
    visit(T);// 访问根节点
    PreOrder(T->rChild);// 递归遍历右子树
  }
}
```

```cpp
// 后序遍历
void PreOrder(BiTree T) {
  if (T != nullptr) {
    PreOrder(T->lChild);// 递归遍历左子树
    PreOrder(T->rChild);// 递归遍历右子树
    visit(T);// 访问根节点
  }
}
```

![](../../../images/计算机/数据结构和算法/18.png)

### 层序遍历

![](../../../images/计算机/数据结构和算法/19.png)

```cpp
typedef struct BiTNode {
    int val;
    struct BiTNode *lChild, *rChild;
} BiTNode, *BiTree;

typedef struct LinkNode {
    BiTNode data;
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void LevelOrder(BiTree T) {
  LinkQueue Q;
  InitQueue(Q);// 初始化队列
  BiTree p;
  EnQueue(Q, T);// 根节点入队
  while (!isEmpty(Q)){
    DeQueue(Q,p);// 对头结点出队
    if (p->lChild != nullptr){
      EnQueue(Q, p->lChild);// 左孩子入队
    }
    if (p->rChild != nullptr){
      EnQueue(Q, p->rChild);// 有孩子入队
    }
  }
}
```

### 由遍历序列构造二叉树

若只给出一颗二叉树的 前/中/后/层  序遍历序列中的一种，不能唯一确定一颗二叉树。

![](../../../images/计算机/数据结构和算法/20.png)

![](../../../images/计算机/数据结构和算法/21.png)

![](../../../images/计算机/数据结构和算法/22.png)

唯一地确定一棵二叉树：

1. 先序序列+**中序序列**
2. 后序序列+**中序序列**
3. 层序序列+**中序序列**

::: tip

- 由遍历序列构造二叉树的核心就是：找到根节点，根据根节点在中序序列划分左右子树，找到左右子树的根节点，继续划分左右子树。
- 必须要有中序遍历序列

:::

## 线索二叉树

传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继

![](../../../images/计算机/数据结构和算法/23.png)

从根结点出发，进行中序遍历，定义指针 q 记录当前访问的结点，指针 pre 记录上一个访问的结点。

```cpp
void vistit(BiTNode T){
  pre = q;
  q = T;
  if(q == p){
    // 此时 pre 指向的结点就是 p 的前驱
  }
  if(pre == p){
    // 此时 pre 指向的结点就是 p 的后继
  }
}
```

缺点：找前驱、后继很不方便；必须从根开始进行一次遍历。

---

### 线索二叉树的概念

为了加快查找结点前驱和后继的速度，因此引入线索二叉树这个概念。

在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针，线索二叉树就是利用这些空指针来存放指向其前驱或后继的指针。这样就可以像遍历单链表那样方便地遍历二叉树。

::: tip 

**含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针**。

每个叶结点都有2个空指针，每个度为1的结点都有1个空指针，空指针总数为 $2n_0+n_1$，又 $n_0=n_2+1$，所以空指针总数为 $n_0+n_1+n_2+1=n+1$。

:::

![](../../../images/计算机/数据结构和算法/24.png)

### 线索二叉树的存储结构

![](../../../images/计算机/数据结构和算法/25.png)

### 三种线索二叉树的对比

![](../../../images/计算机/数据结构和算法/26.png)

### 二叉树的线索化

中序线索化

 ```cpp
 typedef struct ThreadNode {
     int val;
     struct ThreadNode *lChild, *rChild;
     int lTag, rTag;
 } ThreadNode, *ThreadTree;
 
 // 当前访问结点的前驱
 ThreadNode *pre = nullptr;
 
 void visit(ThreadNode *q) {
   // 左子树为空，建立当前结点前驱线索
   if (q->lChild == nullptr) {
     q->lChild = pre;
     q->lTag = 1;
   }
   // 建立前驱结点的后继结点
   if (pre != nullptr && pre->rChild == nullptr) {
     pre->rChild = q;
     pre->rTag = 1;
   }
   pre = q;
 }
 
 // 中序遍历
 void InThread(ThreadTree T) {
   if (T != nullptr) {
     InThread(T->lChild);
     visit(T);
     InThread(T->rChild);
   }
 }
 
 // 中序线索化二叉树
 void CreateThread(ThreadTree T) {
   pre = nullptr;
   if (T != nullptr) {
     InThread(T);
     // 处理遍历后的最后一个结点
     if (pre->rChild == nullptr) {
       pre->rTag = 1;
     }
   }
 }
 ```

先序线索化

```cpp
// 其他代码一样

// 先序遍历
void PreThread(ThreadTree T) {
  if (T != nullptr) {
    visit(T);
    if (T -> lTag == 0){
    	InThread(T->lChild);// lTag不是前驱线索
    }
    InThread(T->rChild);
  }
}

// 先序线索化二叉树
void CreateThread(ThreadTree T) {
  pre = nullptr;
  if (T != nullptr) {
    PreThread(T);
    // 处理遍历后的最后一个结点
    if (pre->rChild == nullptr) {
      pre->rTag = 1;
    }
  }
}
```

### 在线索二叉树中找前驱和后继

- 中序线索二叉树找中序后继

  ![](../../../images/计算机/数据结构和算法/27.png)

- 中序线索二叉树找中序前驱

  ![](../../../images/计算机/数据结构和算法/28.png)

- 先序线索二叉树找先序后继

  ![](../../../images/计算机/数据结构和算法/29.png)

- 先序线索二叉树找先序前驱

  由于每个结点只有指向左右孩子的指针，因此无法找到前驱。

  ![](../../../images/计算机/数据结构和算法/30.png)

  要找到前驱可以使用三叉链表，即在结点中添加一个指向父节点的指针

  ![](../../../images/计算机/数据结构和算法/31.png)

- 后序线索二叉树找后序前驱

  ![](../../../images/计算机/数据结构和算法/32.png)

- 后序线索二叉树找后序后继

  ![](../../../images/计算机/数据结构和算法/33.png)

  仍然是使用三叉链表

  ![](../../../images/计算机/数据结构和算法/34.png)

---



![](../../../images/计算机/数据结构和算法/35.png)

## 题目

1. 在下列关于二叉树遍历的说法中，正确的是（<span style="color:red;">C</span>）。

   A. 若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点

   B. 若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点

   C. 若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点

   D. 若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点

   > 二叉树中序遍历的最后一个结点一定是从根开始沿右子女指针链走到底的结点，设用P指示。
   >
   > 若结点p不是叶结点（其左子树非空），则前序遍历的最后一个结点在它的左子树中，选项A、B 错；
   >
   > 若结点p是叶结点，则前序与中序遍历的最后一个结点就是它，选项C正确。
   >
   > 若中序遍历的最后一个结点p不是叶结点，它还有一个左子女g，结点g是叶结点，那么结点g是前序遍历的 最后一个结点，但不是中序遍历的最后一个结点，选项D错

2. 设n，m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是（<span style="color:red;">C</span>）。

   A. n在m右方	B. n是m祖先	C. n在m左方	D. n是m子孙

   > 中序遍历时，先访问左子树，再访问根结点，后访问右子树。n在m前的3种可能性如图所示，从中看出n总是在m的左方。
   >
   > ![](../../../images/计算机/数据结构和算法/36.png)

3. 设n，m为一棵二叉树上的两个结点，在后序遍历时，n在m前的条件是（<span style="color:red;">D</span>）。

   A. n在m右方	B. n是m祖先	C. n在m左方	D. n是m子孙

   > 若n是m的子孙，设m在N的位置，则n无论是在m的左子树还是在右子树，在后序遍历的过程中n都在m之前访问。选项C要成立，就要加上两个结点位于同一层这个条件。

4. 在二叉树中有两个结点m和n，若m是n的祖先，则使用（<span style="color:red;">C</span>）可以找到从m到n的路径。

   A. 先序遍历	B. 中序遍历	C. 后序遍历	D. 层次遍历

   > 在后序遍历退回时访问根结点，就可以从下向上把从n到m的路径上的结点输出。
   >
   > 若采用非递归的算法，则当后序遍历访问到n时，栈中把从根到n的父指针的路径上的结点都记忆下来， 也可以找到从m到n的路径。

5. 一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（<span style="color:red;">C</span>）。

   A.所有的结点均无左孩子	B.所有的结点均无右孩子	C.只有一个叶结点	D.是任意一棵二叉树

   > 非空树的先序序列和后序序列相反，即“根左右”与“左右根”顺序相反，因此树只有根结点，或者根结点只有左子树或右子树，以此类推，其子树有同样的性质。
   >
   > 因此，树中所有非叶结点的度均为1，即二叉树仅有一个叶结点。

6. 某二又树的先序序列和后序序列正好相反，则该二叉树一定是（<span style="color:red;">B</span>）。

   A. 空或只有一个结点	B. 高度等于其结点数	C. 任意一个结点无左孩子	D. 任意一个结点无右孩子

   > 非空二叉树的先序序列和后序序列相反，即"根左右”与“左右根”顺序相反，因此树只有根结点，或根结点只有左子树或右子树，以此类推，其子树具有同样的性质，任意结点只有一个孩子，才能满足先序序列和后序序列正好相反。树形应为一个长链，因此选择选项B。

7. 已知一棵二叉树的后序序列为应DABEC，中序序列为DEBAC，则先序序列为（<span style="color:red;">D</span>）。

   A. ACBED	B. DECAB	C. DEABC	D. CEDBA

   > ![](../../../images/计算机/数据结构和算法/37.png)

8. 已知一棵二叉树的层次序列为ABCDEF，中序序列为BADCFE，则先序序列为（<span style="color:red;">B</span>）。

   A. ACBEDF	B. ABCDEF	C. BDFECA	D. FCEDBA

   > ![](../../../images/计算机/数据结构和算法/38.png)

9. 线索二叉树是一种（<span style="color:red;">C</span>）结构。

   A. 逻辑	B. 逻辑和存储	C. 物理	D. 线性

   > 二叉树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即它是二叉树在计算机内部的一种存储结构，所以是一种物理结构。

10. 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是（<span style="color:red;">D</span>）。

    A. 不确定	B. 0个	C. 1个	D. 2个

    > 对左子树为空的二叉树进行先序线索化，根结点的左子树为空并且也没有前驱结点(先遍历根结点)，先序遍历的最后一个元素为叶结点，左、右子树均为空且有前驱无后继结点，故线索化后，树中空链域有2个。

11. 在线索二叉树中，下列说法不正确的是（<span style="color:red;">D</span>）。

    A. 在中序线索树中，若某结点有右孩子，则其后继结点是它的右子树的最左下结点

    B. 在中序线索树中，若某结点有左孩子，则其前驱结点是它的左子树的最右下结点

    C. 线索二叉树是利用二叉树的n + 1个空指针来存放结点的前驱和后继信息的

    D. 每个结点通过线索都可以直接找到它的前驱和后继

    > 不是每个结点通过线索都可以直接找到它的前驱和后继。
    >
    > 在先序线索二叉树中查找一个结点的先序后继很简单，而查找先序前驱必须知道该结点的双亲结点。同样，在后序线索二叉树中查找一个结点的后序前驱也很简单，而查找后序后继也必须知道该结点的双亲结点，二叉链表中没有存放双亲的指针。

12. （<span style="color:red;">C</span>）的遍历仍需要栈的支持。

    A.前序线索树	B.中序线索树	C.后序线索树	D.所有线索树

    > 后序线索树遍历时，最后访问根结点，若从右孩子x返回访问父结点，则由于结点x的右孩子不一定为空（右指针无法指向其后继），因此通过指针可能无法遍历整棵树。
    >
    > 如下图所示，结点中的数字表示遍历的顺序，图（c）中结点6的右指针指向其右孩子5，而不指向其后序后继结点 7，因此后序遍历还需要栈的支持，而图（a）和图（b）均可遍历。
    >
    > ![](../../../images/计算机/数据结构和算法/39.png)

13. 若一棵二叉树的前序遍历序列为a,e,b,d,c，后序遍历序列为b,c,d,e,a，则根结点的孩子结点（<span style="color:red;">A</span>）。

    A. 只有e	B. 有e、b	C. 有e、c	D. 无法确定

    > 前序序列和后序序列不能唯一确定一棵二叉树，但可以确定二叉树中结点的祖先关系：当两个结点的前序序列为XY、后序序列为YX时，则X为Y的祖先。
    >
    > 考虑前序序列a, e, b, d, c，后序序列b, c, d, e, a，可知a为根结点，e为a的孩子结点；此外，由a的孩子结点的前序序列e,b,d,c和后序序列b,c,d,e，可知e是bcd的祖先，故根结点的孩子结点只有e。 故选选项A。
    >
    > ![](../../../images/计算机/数据结构和算法/40.png)

14. 先序序列为a,b,c,d的不同二叉树的个数是（<span style="color:red;">B</span>）。

    A. 13	B. 14	C. 15	D. 16

    > 根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：前序序列和中序 序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序。因为前序序列和中序序列可 以唯一地确定一棵二叉树，所以题意相当于“以序列a,b,c,d为入栈次序，则出栈序列的个数为？”，对于n个不同元素进栈，出栈序列的个数为$\frac{1}{n+1}C^n_{2n}=14$

15. 要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是（<span style="color:red;">B</span>）。

    A. 只有左子树	B. 只有右子树	C. 结点的度均为1	D. 结点的度均为2 

    > 先序序列先父结点，接着左子树，然后右子树。中序序列先左子树，接着父结点，然后右子树，递归进行。若所有非叶结点只有右子树，则先序序列和中序序列都是先父结点，然后右子树，递归进行，因此选项B正确。

## 树的存储结构

树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存 储方式，都要求能唯一地反映树中各结点之间的逻辑关系。

### 双亲表示法

这种存储结构采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。

根结点下标为0，其伪指针域为-1。

![](../../../images/计算机/数据结构和算法/41.png)

```cpp
#define MAX_TREE_SIZE 100
typedef struct{
  int data; // 数据
  int parent; // 双亲位置域
}PTNode;
typedef struct{
  PTNode nodes[MAX_TREE_SIZE];
  int n; // 结点数
}PTree;
```



相关操作：

- 插入结点

  直接在数组后面新增数据元素，无需按逻辑上的次序存储。

- 删除结点

  - 将需要删除的节点的指针域设为 -1，表示没有双亲。

    缺点：数组之间的空数据导致遍历数组的速度变慢。

  - 把后面的结点都前进一位，保证前面的存储单元都是有效的。



<br>

该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快地得到每个结点的双亲结点，但求结点的孩子时则需要遍历整个结构。

<br>

::: tip

区别**树的顺序存储结构**与**二叉树的顺序存储结构**。

- 在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。
- 在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。

二叉树属于树，因此二叉树都可以用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。

:::



### 孩子表示法

 孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构。

![](../../../images/计算机/数据结构和算法/42.png)

```cpp
struct CTNode{
  int child; // 孩子节点在数组中的位置
  struct CTNode *next; // 下一个孩子
}
typedef struct{
  int data;
  struct CTNode *firstChild;// 第一个孩子
}CTBox;
typedef struct{
  CTBox nodes[MAX_TREE_SIZE];
  int n ,r;// 结点数和根的位置
}CTree;
```

这种存储结构寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指 针域所指向的n个孩子链表。

### 孩子兄弟表示法

孩子兄弟表示法又称**二叉树表示法**，即以二叉链表作为树的存储结构。

孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，以及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。 

![](../../../images/计算机/数据结构和算法/43.png)

这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查 找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。

## 树、森林与二叉树的转换

### 树 → 二叉树

- 规则：

  每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。

- 画法：

  1. 在兄弟结点之间加一连线；
  2. 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；
  3. 以树根为轴心，顺时针旋转45。

具体图片可查看 [树的存储结构-孩子兄弟表示法](#孩子兄弟表示法)

### 森林 → 二叉树

- 规则：

  先将森林中的每棵树转换为二叉树，由于任意一棵和 树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树 对应的二叉树当作第-棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右 子树……以此类推，就可以将森林转换为二叉树。

- 画法：

  1. 将森林中的每棵树转换成相应的二叉树；
  2. 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；
  3. 以第一棵树的根为轴心顺时针旋转45。

![](../../../images/计算机/数据结构和算法/44.png)

### 二叉树 → 森林

- 规则：

  若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成 树，就得到了森林。二叉树转换为树或森林是唯一的。

![](../../../images/计算机/数据结构和算法/45.png)

## 树和森林的遍历

### 树的遍历

1. **先根遍历**

   若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其**遍历序列与这棵树相应二叉树的先序序列相同**。

   ![](../../../images/计算机/数据结构和算法/46.png)

2. **后根遍历**

   若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其**遍历序列与这棵树相应二叉树的中序序列相同**。

   ![](../../../images/计算机/数据结构和算法/47.png)

3. **层次遍历**

   与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。 

   ![](../../../images/计算机/数据结构和算法/48.png)

### 森林的遍历

1. 先序遍历森林

   若森林为非空，则按如下规则进行遍历：

   - 访问森林中第一棵树的根结点。 
   - 先序遍历第一棵树中根结点的子树森林。 
   - 先序遍历除去第一棵树之后剩余的树构成的森林。

   ![](../../../images/计算机/数据结构和算法/49.png)

   ![](../../../images/计算机/数据结构和算法/50.png)

2. 中序遍历森林

   森林为非空时，按如下规则进行遍历：

   - 中序遍历森林中第一棵树的根结点的子树森林。
   - 访问第一棵树的根结点。
   - 中序遍历除去第一棵树之后剩余的树构成的森林。

   ![](../../../images/计算机/数据结构和算法/51.png)

   ![](../../../images/计算机/数据结构和算法/52.png)
   
   ::: tip
   
   部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，如遇到这两种称谓，那么都可以理解为同一种遍历方法。
   
   :::
   
   

## 题目

1. 下列关于树的说法中，正确的是（<span style="color:red;">D</span>）。

   I. 对于有 n 个结点的二叉树，其高度为 $\log_2n$

   II. 完全二叉树中，若一个结点没有左孩子，则它必是叶结点

   III. 高度为 h （h>0）的完全二叉树对应的森林所含的树的个数一定是 h

   IV. 一棵树中的叶子数一定等于与其对应的二叉树的叶子数

   A. I 和 III	B. IV	C. I 和 II	D. II

   > - 若n个结点的二叉树是一棵单支树，则其高度为n。
   > - 完全二叉树中最多存在一个度为1的结点且只有左孩子，若不存在左孩子，则一定也不存在右孩子，因此必是叶结点。
   > - 只 有满二叉树才具有性质III
   > - 在树转换为二叉树时，若有几个叶结点具有共同的双亲，则转换成二叉树后只有一个叶结点。若树中的任意两个叶结点都不存在相同的双亲，则树中的叶子数才有可能与其对应的二叉树中的叶子数相等。

2. 设F是一个森林，B是由F变换来的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（<span style="color:red;">C</span>）个。

   A. n - 1	B. n	C. n + 1	D. n + 2

   > 根据森林与二叉树转换规则“左孩子右兄弟”。二叉树B中右指针域为空代表该结点没有兄弟结点。森林中每棵树的根结点从第二个开始依次连接到前一棵树的根的右孩子，因此最后一棵树的根结点的右指针为空。另外，每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空，故树B中右指针域为空的结点有n+1个。

3. 已知一棵有2011个结点的树，其叶结点个数为116，该树对应的二叉树中无右孩子的结点个数是（<span style="color:red;">D</span>）。

   A. 115	B. 116	C. 1895	D. 1896

   > 树转换为二叉树时，树的每个分支结点的所有子结点中的最 右子结点无右孩子，根结点转换后也没有右孩子，因此，对应二叉 树中无右孩子的结点个数=分支结点数 + 1 = 2011 - 116 + 1 = 1896。
   >
   > 通常本题应采用特殊法求解，设题意中的树是如下图所示的结构，则对应的二叉树中仅有前115个叶结点有右孩子，故无右孩子的结点个数= 2011-115 = 1896。
   >
   > ![](../../../images/计算机/数据结构和算法/69.png)

4. 若$T_1$是由有序树$T$转换而来的二叉树，则$T$中结点的后根序列就是$T_1$中结点的（<span style="color:red;">B</span>）序列。

   A.先序	B.中序	C.后序	D.层序

5. 将森林转换为对应的二叉树，若在二叉树中，结点 $u$ 是结点 $v$ 的父结点的父结点，则在原来的森林中，$u$ 和 $v$ 可能具有的关系是（<span style="color:red;">B</span>）。

   I.父子关系	II.兄弟关系	III.  $u$ 的父结点与 $v$ 的父结点是兄弟关系

   A,只有 II	B. I 和 II	C. I 和 III	D. I、II 和 III

   > 森林与二叉树的转换规则为“左孩子右兄弟”。在最后生成的二叉树中，父子关系在对应的森林关系中可能是兄弟关系或原本就是父子关系。
   >
   > - 若结点 $v$ 是结点 $u$ 的第二个孩子结点，在转换时，结点 $v$ 就变成结点 $u$ 的第一个孩子的右孩子，符合要求。
   > - 结点 $u$ 和 $v$ 是兄弟结点的关系，但二者之中还有一个兄弟结点 $k$，转换后结点 $v$ 就变为结点 $k$ 的右孩子，而结点 $k$ 则是结点 $u$ 的右孩子，符合要求。
   > - 结点 $v$ 的父结点要么是原先的父结点，要么是兄弟结点。若结点 $u$ 的父结点与 $v$ 的父结点是兄弟关系，则转换之后不可能出现结点 $u$ 是结点 $v$ 的父结点的父结点的情形。

6. 将森林F转换为对应的二叉树T，F中叶结点的个数等于（<span style="color:red;">C</span>）。

   A.T中叶结点的个数	B. T中度为1的结点个数

   C. T中左孩子指针为空的结点个数	D. T中右孩子指针为空的结点个数

   > 将森林转化为二叉树相当于用孩子兄弟表示法来表示森林。在变化过程中，原森林某结点的第一个孩子结点作为它的左子树，它的兄弟作为它的右子树。森林中的叶结点由于没有孩子结点，转化为二叉树时，该结点就没有左结点，所以F中叶结点的个数等于T中左孩子指针为空的结点个数，选择选项C。

7. 若森林F有15条边、25个结点，则F包含树的个数是（<span style="color:red;">C</span>）。

   A. 8	B. 9	C. 10	D. 11

   > 树有一个很重要的性质，即在n个结点的树中有n-1条边，"那么对于每棵树，其结点数比边数多1”。假设森林中的每棵树结点数之和为 $i_1+i_2+\cdots+i_n = 25$，边数之和为 $(i_1-1)+(i_2-1)+\cdots+(i_n-1)=i_1+i_2+\cdots+i_n -n = 25 -n =15$，即一共有10棵树。

8. 已知森林F及与之对应的二叉树T，若F的先根遍历序列是a, b, c, d, e, f，中根遍历序列是b, a, d,f, e, c，则T的后根遍历序列是（<span style="color:red;">C</span>）。

   A. b, a, d, f, e, c	B. b, d, f, e, c, a	C. b, f, e, d, c, a	D. f, e, d, c, b, a

   > 森林F的先根遍历序列对应于其二叉树T的先序遍历序列，森林F的中根遍历序列对应于其二叉树T的中序遍历序列。即T的先序遍历序列为a, b, c, d, e, f，中序遍历序列为b, a, d,f, e, c。 根据二叉树T的先序序列和中序序列可以唯一确定它的结构。

## 哈夫曼树

::: info 相关概念

- 结点的**权**

  有某种现实含义的数值。

- **结点的带权路径长度**

  从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积。

- **树的带权路径长**

  树中所有叶结点的带权路径长度之和，记为 
  $$
  WPL=\sum_{i=1}^{n} w_il_i
  $$

	![](../../../images/计算机/数据结构和算法/56.png)

::: 

### 哈夫曼树的定义

在含有n个带权叶结点的二叉树中，其中**带权路径长度（WPL）最小的二叉树**称为哈夫曼树，也称**最优二叉树**。

![](../../../images/计算机/数据结构和算法/57.png)

### 哈夫曼树的构造

给定n个权值分别为$W_1,W_2,\cdots,W_n$的结点，构造哈夫曼树的算法描述如下：

1. 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。
2. 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
3. 从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
4. 重复步骤2. 和3. ，直至F中只剩下一棵树为止。

![](../../../images/计算机/数据结构和算法/58.png)

除上图的构造的哈夫曼树外，还可以如下图构造哈夫曼树

![](../../../images/计算机/数据结构和算法/59.png)



### 哈夫曼树的特点

1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。 
2. 构造过程中共新建了n-1个结点（双分支结点），因此哈夫曼树的结点总数为2n-1。
3. 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。
4. 哈夫曼树并不唯一，但WPL必然相同且为最优。

### 哈夫曼编码

> [5.5_1_哈夫曼树](https://www.bilibili.com/video/BV1b7411N798/?p=52)

::: info 相关概念

- 固定长度编码：在数据通信中，若对每个字符**用相等长度的二进制位表示**。
- 可变长度编码：在数据通信中，允许对不同字符**用不等长的二进制位表示**。

可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。

前缀编码：没有一个编码是另一个编码的前缀。

::: 

哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。 

由哈夫曼树得到哈夫曼编码：

- 将字符集中出现的每一个字符当作一个叶子结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。
- 将字符的编码解释为从根至该字符的路径上边标记的序列，“左”边为0，“右”边为1。

![](../../../images/计算机/数据结构和算法/60.png)

![](../../../images/计算机/数据结构和算法/61.png)

![](../../../images/计算机/数据结构和算法/62.png)

![](../../../images/计算机/数据结构和算法/63.png)

## 并查集

> [5.5_2_并查集](https://www.bilibili.com/video/BV1b7411N798/?p=53)

::: info

![](../../../images/计算机/数据结构和算法/64.png)

:::

### 定义

并查集是一种简单的集合表示。

![](../../../images/计算机/数据结构和算法/65.png)

![](../../../images/计算机/数据结构和算法/66.png)

通常用树（森林）的**双亲表示**作为并查集的存储结构，每个子集合以一棵树表示。

所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数。

### 实现

1. `Initial(S)`

   将集合S中的每个元素都初始化为只有一个单元素的子集合。 

2. `Union(S, Rootl, Root2)`（并）

   把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并。

3. `Find(S, x)`（查）

   查找集合S中单元素x所在的子集合，并返回该子集合的根结点。

```cpp
#define SIZE 13

int UFSets[SIZE];// 集合元素数组

// 初始化并查集
void Initial(int S[]) {
  for (int i = 0; i < SIZE; i++) {
    S[i] = -1;
  }
}

int Find(int S[], int x) {
  while (S[x] >= 0) {
    x = S[x];
  }
  return x;
}

void Union(int S[], int Root1, int Root2) {
  if (Root1 == Root2)return;
  S[Root2] = Root1;
}
```

### 时间复杂度

- `Find()` 查操作的最坏时间复杂度为 $O(n)$。

  ![](../../../images/计算机/数据结构和算法/67.png)

- `Union()` 并操作的时间复杂度为 $O(1)$。

### 优化

核心：降低树的高度

- `Union` 操作优化

  目的：降低 `Find()` 的时间复杂度。

  1. 用根节点的绝对值表示树的结点总数
  2. `Union` 操作，让小树合并到大树

  ```cpp
  void Union(int S[], int Root1, int Root2) {
    if (Root1 == Root2)return;
    // Root2 结点更少
    if (S[Root2] > S[Root1]) {
      // 累加结点总数
      S[Root1] += S[Root2];
      // 小树合并到大树
      S[Root2] = Root1;
    } else {
      S[Root2] += S[Root1];
      S[Root1] = Root2;
    }
  }
  ```

  使用该方法构造的树高不超过 $\left \lfloor \log_2n \right \rfloor +1$

  优化后，`Find` 操作最坏时间复杂度度为 $O(\log_2n)$，`Union` 最坏时间复杂度为 $O(n\log_2n)$

  ---

  

- `Find` 操作优化（压缩路径）

  先找到根节点，再将查找路径上的所有结点都挂到根结点下。

  ```cpp
  int Find(int S[], int x) {
    int root = x;
    // 循环找到根
    while (S[x] >= 0) {
      root = S[x];
    }
    // 压缩路径
    while (x != root) {
      // 存储 x 的父节点
      int t = S[x];
      // x 直接挂到根节点下
      S[x] = root;
      // 将 x 指向父节点
      x = t;
    }
    return root;
  }
  ```

  每次 `Find` 操作，先找根，在压缩路径，可使树的高度不超过 $O(\alpha (n))$ 。$\alpha (n)$ 是一个增长很缓慢的函数，对于常见的n值，通常 $\alpha(n) \le  4$，因此优化后的并查集的 `Find`、`Union` 操作时间开销都很低。

  `Find ` 最坏时间复杂度为 $O(\alpha (n))$，`Union` 最坏时间复杂度为 $O(n\alpha (n))$

---

<br>

![](../../../images/计算机/数据结构和算法/68.png)

## 题目

1. 给定整数集合{3,5,6,9,12}，与之对应的哈夫曼树是（<span style="color:red;">C</span>）。

   ![](../../../images/计算机/数据结构和算法/70.png)

   > 首先，3和5构造为一棵子树，其根权值为8，然后该子树与6构造为一棵新子树，根权值 为14，再后9与12构造为一棵子树，最后两棵子树共同构造为一棵哈夫曼树。

2. 一棵哈夫曼树共有215个结点，对其进行哈夫曼编码，共能得到（<span style="color:red;">B</span>）个不同的码字。

   A. 107	B. 108	C. 214	D. 215

   > - 解法1：在哈夫曼树中，叶节点数 - 叶节点数 = 1，因此叶结点数为(215 + 1)/2=108，所以共有108个不同的码字。
   > - 解法2：在哈夫曼树中只有度为0和2的结点，结点总数$n = n_0 + n_2$，且$n_0=n_2+1$，由题知  $n=215, n_0= 108$。

3. 若度为m的哈夫曼树中，叶结点个数为n，则非叶结点的个数为（<span style="color:red;">C</span>）。

   A. $n-1$	B. $\left \lfloor n/m \right \rfloor -1$	C. $\left \lceil  (n-1)/(m-1) \right \rceil$	D. $\left \lceil n/(m-1)-1 \right \rceil$

   > 一棵度为$m$的哈夫曼树应只有度为0和$m$的结点，设度为$m$的结点有$n_m$个，度为0的结点有$n_0$个，又设结点总数为$N$，$N=n_0+n_m$。因有$N$个结点的哈夫曼树有$N-1$条分支，则$mn_m-N-1=n_m+n_0-1$，整理得$(m-1)n_m=n_0-1$，$n_m=(n_0-1)/(m-1)$。

4. 并查集中最核心的两个操作是：①查找，查找两个元素是否属于同一个集合；②合并, 如果两个元素不属于同一个集合，且所在的两个集合互不相交，则合并这两个集合。假 设初始长度为 10 （0~9）的并查集，按 1-2、3-4、5-6、7-8. 8-9、1-8、0-5、1-9 的顺序进行查找和合并操作，最终并查集共有（<span style="color:red;">C</span>）个集合。

   A. 1	B. 2	C. 3	D. 4

   > 初始时，0〜9各自成一个集合。查找1-2时，合并｛1｝和｛2｝；查找3-4时，合并｛3｝和｛4｝； 查找5-6时，合并｛5｝和｛6｝；查找7-8时，合并｛7｝和｛8｝；查找8-9时，合并｛7，8｝和｛9｝；查找 1-8时，合并｛1，2｝和｛7，8，9｝；查找0-5时，合并｛0｝和(5, 6)；查找1-9时，它们属于同一个集 合。最终的集合为｛0，5，6｝、｛1，2，7，8，9｝和｛3，4｝，因此答案选择选项C。

5. 下列选项给出的是从根分别到达两个叶结点路径上的权值序列，能属于同一棵哈夫曼树的是（<span style="color:red;">D</span>）。

   A. 24, 10, 5 和 24, 10, 7	B. 24,10, 5 和 24, 12, 7

   C. 24, 10, 10 和 24, 14, 11	D. 24, 10, 5 和 24, 14, 6

   > 在哈夫曼树中，左右孩子权值之和为父结点权值。
   >
   > 仅以分析选项A为例：若两个10分别属于两棵不同的子树，则根的权值不等于其孩子的权值和，不符；若两个10属同棵子树，则其权值不等于其两个孩子（叶结点）的权值和，不符。
   >
   > 选项B、C选项的排除方法一样。
