---
title: 排序
index: 9
---

> https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

## 排序的基本概念

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/266.png)

**排序**，就是重新排列表中的元素，使表中的元素满足**按关键字有序**的过程。

排序的确切定义如下：

输入：$n$个记录$R_1,R_2,\cdots,R_n$，对应的关键字为$k_1,k_2,\cdots,k_n$。

输出：输入序列的一个重排$R_1^{'},R_2^{'},\cdots,R_n^{'}$，使得$k_1^{'}\leqslant k_2^{'}\leqslant \cdots,k_n^{'}$（其中$\leqslant$可以换成其他的比较大小的符号）。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/264.png)

**算法的稳定性**：若待排序表中有两个元素$R_i$和$R_j$，其对应的关键字相同即$key_i= key_j$，且在排序前$R_i$在$R_j$的前面，若使用某一排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/265.png)

::: tip

算法的稳定性与算法优劣无关。

稳定的排序算法不一定比不稳定的好，取决于实际需求。

:::

根据数据元素是否完全在内存中，可将排序算法分为两类：

1. **内部排序**：在排序期间元素**全部存放在内存中**的排序；
2. **外部排序**：在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。

::: tip

**大多数**的内部排序算法只适用于顺序存储的线性表。

:::

## 题目

1. 下述排序方法中，不属于内部排序方法的是（<span style="color:red;">C</span>）。

   A.插入排序 B.选择排序 C.拓扑排序 D.冒泡排序

   > 拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于这里所提到的内部排序范畴，也不满足前面排序的定义。

2. 对任意 7 个关键字进行基于比较的排序，至少要进行（<span style="color:red;">A</span>）次关键字之间的两两比较。

   A. 13 B. 14 C. 15 D. 6

   > 对于任意序列进行基于比较的排序，求至少的比较次数应考虑最坏情况。对任意 n 个关键字排序的比较次数至少为$\left \lceil \log_2{(n!)} \right \rceil $。将 n=7 代入公式，答案为 13。
   >
   > 在基于比较的排序方法中，每次比较两个关键字后，仅出现两种可能的转移。假设整个排序过程至少需要做 t 次比较，则显然会有$2^t$种情况。 由于 n 个记录共有$n!$种不同的排列，因而必须有$n!$种不同的比较路径，于是有$2^t \geqslant  n!$，即$t \geqslant  \log_2{(n!)}$。 考虑到 t 为整数，故为$\left \lceil \log_2{(n!)} \right \rceil $。

## 插入排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/267.png)

### 直接插入排序

空间复杂度：$O(1)$

最好时间复杂度：$O(n)$

最坏时间复杂度：$O(n^2)$

```cpp
// 直接插入排序
void InsertSort(int A[], int n) {
  for (int i = 1; i < n; i++) {
    if (A[i] < A[i - 1]) {
      int temp = A[i];
      int j;
      for (j = i - 1; j >= 0 && A[j] > temp; j--) {
        A[j + 1] = A[j];
      }
      A[j + 1] = temp;
    }
  }
}
```

```cpp
// 直接插入排序（带哨兵）
void InsertSort(int A[], int n) {
  for (int i = 2; i < n; i++) {
    if (A[i] < A[i - 1]) {
      A[0] = A[i];
      int j;
      for (j = i - 1; A[0] < A[j]; j--) {
        A[j + 1] = A[j];
      }
      A[j + 1] = A[0];
    }
  }
}
```

### 折半插入排序

先用折半查找找到插入的位置，再移动元素

因为改进的只是比较的次数，而移动次数未发生变化，所以折半插入排序的时间复杂度仍为$O(n^2)$

```cpp
void InsertSort(int A[], int n) {
  int low, high, mid;
  for (int i = 2; i <= n; i++) {
    A[0] = A[i];
    low = 1;
    high = i - 1;
    while (low <= high) {
      mid = (low + high) / 2;
      if (A[mid] > A[0]) {
        high = mid - 1;
      } else {
        low = mid + 1;
      }
    }
    for (int j = i - 1; j >= high + 1; j--) {
      A[j + 1] = A[j];
    }
    A[high + 1] = A[0];
  }
}
```

### 希尔排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/273.png)

又称缩小增量排序

思想：先将待排序表分割成若干形如$L[i, i + d,i + 2d,\cdots,i + kd]$的“特殊” 子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。

空间复杂度：$0(1)$。

时间复杂度：和增量序列$d$有关，无法用数学手段证明确切的时间复杂度，最坏时间复杂度$O(n^2)$，当 n 在某个范围内时，可达$O(n^{1.3})$

希尔排序算法仅适用顺序表，不适用于链表。

---

示例：

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/268.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/269.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/270.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/271.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/272.png)

```cpp
void a(int A[], int n) {
  int d, i, j;
  // A[0]只是暂存单元，不是哨兵，当就<=0时，插入位置已到
  for (d = n / 2; d >= 1; d = d / 2) {
    for (i = d + 1; i < n; i++) {
      // 需要将A[i]插入有序增量子表
      if (A[i] < A[i - d]) {
        // 暂存在A[0]
        A[0] = A[i];
        for (j = i - d; j > 0 && A[0] < A[j]; j -= d) {
          A[j + d] = A[j];
        }
        A[j + d] = A[0]
      }
    }
  }
}
```

```cpp
void ShellSort(int num[], int length) {
  // 设置增量gap
  for (int gap = length / 2; gap > 0; gap /= 2) {
    // 根据增量划分子序列
    for (int i = gap; i < length; i++) {
      // 对子序列进行插入排序
      int insertVal = num[i];
      int insertIndex = i - gap;
      while (insertIndex >= 0 && insertVal < num[insertIndex]) {
        num[insertIndex + gap] = num[insertIndex];
        insertIndex -= gap;
      }
      num[insertIndex + gap] = insertVal;
    }
  }
}
```

## 题目

1. 对有 n 个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数 是（<span style="color:red;">D</span>）；在最好情况下所需的比较次数是（<span style="color:red;">A</span>）。

   A. n - 1 B. n + 1 C. n/2 D. n(n-1)/2

   > - 待排序表为反序时，直接插入排序需要进行 n(n-1)/2 次比较
   > - 待排序表为正序时，只需进行 n-1 次比较

2. 对 5 个不同的数据元素进行直接插入排序，最多需要进行的比较次数是（<span style="color:red;">B</span>）。

   A. 8 B. 10 C. 15 D. 25

   > 直接插入排序在最坏的情况下要做 n(n-1)/2 次关键字的比较

3. 在待排序的元素序列基本有序的前提下，效率最高的排序方法是（<span style="color:red;">A</span>）。

   A. 直接插入排序 B. 简单选择排序 C. 快速排序 D. 归并排序

   > 由于这里的序列基本有序，使用直接插入排序算法的时间复杂度接近$O(n)$，而使用其他算法 的时间复杂度均大于$O(n)$

4. 数据序列｛ 8, 10 , 13 , 4 , 6 , 7 , 22 , 2 , 3 ｝只能是（<span style="color:red;">C</span>）两趟排序后的结果。

   A. 简单选择排序 B. 起泡排序 C. 直接插入排序 D. 堆排序

   > 冒泡排序和选择排序经过两趟排序后，应该有两个最大（或最小）元素放在其最终位置；插入排序经过两趟排序后，前 3 个元素应该是局部有序的。只有可能是插入排序。

   ::: tip

   在排序过程中，**每趟都能确定一个元素在其最终位置**的有**冒泡排序、简单选择排序、 堆排序、快速排序**，其中前三者能形成全局有序的子序列，后者能确定枢轴元素的最终位置。

   :::

5. 若数据元素序列｛ 11 , 12 , 13 , 7 , 8 , 9 , 23 , 4 , 5 ｝是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是（<span style="color:red;">B</span>）。

   A. 冒泡排序 B. 插入排序 C. 选择排序 D. 2 路归并排序

   > - 每趟冒泡和选择排序后，总会有一个元素被放置在最终位置上。显然，这里｛11 , 12｝和｛4 , 5｝所处的位置并不是最终位置，因此不可能是冒泡和选择排序。
   > - 2 路归并算法经过第二趟后应该是 每 4 个元素有序的，但｛11,12,13,7｝并非有序，因此也不可能是 2 路归并排序。

6. 有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，（<span style="color:red;">A</span>）算法不会出现此种情况。

   A. 希尔排序 B. 堆排序 C. 冒泡排序 D. 快速排序

   > 由于希尔排序是基于插入排序算法而提出的，它不一定在每趟排序过程后将某一元素放置到最终位置上。

7. 在下列算法中，（<span style="color:red;">C</span>）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上。

   A. 堆排序 B. 冒泡排序 C. 直接插入排序 D. 快速排序

   > 在直接插入排序中，若待排序列中的最后一个元素应插入表中的第一个位置，则前面的有序子序列中的所有元素都不在最终位置上。

8. 折半插入排序算法的时间复杂度为（<span style="color:red;">C</span>）。

   A. $O(n)$ B. $O(n\log _2n)$ C. $O(n^2)$ D. $O(n^3)$

   > 虽然折半插入排序是对直接插入排序的改进，但它改进的只是比较的次数，而移动次数未发生变化，时间复杂度仍为$O(n^2)$。

9. 以下排序算法中， 稳定的是（<span style="color:red;">C</span>）。

   A. 快速排序 B. 堆排序 C. 直接插入排序 D. 简单选择排序

   > 基于插入、交换、选择的三类排序方法中，通常简单方法是稳定的(直接插入、折半插入、 冒泡)，但有一个例外就是简单选择，复杂方法都是不稳定的(希尔、快排、堆排)。

## 交换排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/274.png)

交换：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

### 冒泡排序

> 代码可查看[冒泡排序](./排序算法/冒泡排序)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/275.png)

空间复杂度：$O(1)$

最好时间复杂度：$O(n)$

最坏时间复杂度：$O(n^2)$

### 快速排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/279.png)

思想：在待排序表$L[1...n]$中任取一个元素 pivot 作为枢轴（或称基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分$L[1...k-1]$和$L[k+1...n]$，使得$L [1...k-1]$中的所有元素小于 pivot，$L[k+1...n]$中的所有元素大于或等于 pivot，则 pivot 放在了其最终位置$L (k)$，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

```cpp
int Partition(int A[], int low, int high) {
  int pivot = A[low];// 第一个元素做为枢轴
  while (low < high) {// 用low，high搜索枢轴的最终位置
    while (low < high && A[high] >= pivot)high--;
    A[low] = A[high];// 比枢轴小的元素移动到左端
    while (low < high && A[low] <= pivot)low++;
    A[high] = A[low];// 比枢轴大的元素移动到右端
  }
  A[low] = pivot;// 枢轴元素存放到最终位置
  return low;// 返回存放枢轴的最终位置
}

void QuickSort(int A[], int low, int high) {
  if (low < high) {// 递归跳出条件
    int pivot = Partition(A, low, high);// 划分
    QuickSort(A, low, pivot - 1);// 划分左子表
    QuickSort(A, pivot + 1, high);// 划分右子表
  }
}
```

性能分析：

- **递归层数**

  快速排序的时间空间效率都与递归层数有关。

  ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/278.png)

- **时间**

  快速排序的运行时间与划分是否对称有关。

  快速排序的最坏情况发生在两个区域分别包含个元素和 0 个元素时（例如第一次选取的枢轴是这个数组中的最大值或最小值），这种最大限度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到**最坏时间复杂度**$O(n^2)$。

  在最理想的状态下，即`Partition()`可能做到最平衡的划分，得到的两个子问题的大小都 不可能大 n/2，可以得到**最好时间复杂度**$O(n\log_2n)$。

  平均时间复杂度$O(n\log_2n)$

  ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/276.png)

  ::: tip 优化思路

  尽量选取一个可以将数据中分的枢轴元素

  1. 选取头中尾三个位置的元素，取中间值作为枢轴元素；
  2. 随机选取一个元素做为枢轴元素

  :::

- **空间**

  由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量与递归调用的最大深度一致。

  **最好空间复杂度**为$O(\log_2n)$；最坏情况下，因为要进行 n-1 次递归调用，所以栈的**最坏空间复杂度**为$O(n)$；

  平均情况下，栈的深度为$O(\log_2n)$。

  ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/277.png)

## 题目

1. 快速排序算法在（<span style="color:red;">D</span>）情况下最不利于发挥其长处。

   A.要排序的数据量太大 B.要排序的数据中合有多个相同值 C.要排序的数据个数为奇数 D.要排序的数据已基本有序

   > - 当待排序数据为基本有序时，每次选取第 n 个元素为基准，会导致划分区间分配不均匀，不 利于发挥快速排序算法的优势。
   > - 当待排序数据分布较为随机时，基准元素能将序列划分为两个长度大致相等的序列，这时才能发挥快速排序的优势。

2. 就平均性能而言，目前最好的内部排序方法是（<span style="color:red;">D</span>）。

   A.冒泡排序 B.直接插入排序 C.希尔排序 D.快速排序

   > 选项 A、B 的平均性能都会达到$O(n^2)$，而希尔排序虽然大大降低了直接插入排序的时间复杂度，但其平均性能不如快速排序。
   >
   > 另外，虽然众多排序算法的平均时间复杂度也是$O(n\log _2n)$，但快速排序算法的常数因子是最小的。

3. 数据序列 F={2, 1,4, 9, 8, 10, 6, 20}只能是下列排序算法中的（<span style="color:red;">A</span>）两趟排序后的结果。

   A.快速排序 B.冒泡排序 C.选择排序 D,插入排序

   > 若为插入排序，则前三个元素应该是有序的，显然不对。而冒泡排序和选择排序经过两趟排序后应该有两个元素处于最终位置(最左/右端)，无论是按从小到大还是从大到小排序，数据序列中都没有两个满足这样的条件的元素，因此只可能选择选项 A。

4. 对下列关键字序列用快排进行排序时，速度最快的情形是（<span style="color:red;">A</span>），速度最慢的情形是（<span style="color:red;">D</span>）。

   A. { 21,25 ,5 , 17 ,9 ,23 ,30 }

   B. { 25 ,23 ,30, 17 ,21 ,5 ,9 }

   C. { 21 ,9 ,17 ,30 ,25 ,23 ,5 }

   D. { 5 ,9, 17 ,21,23 ,25 , 30 }

   > 当每次的枢轴都把表等分为长度相近的两个子表时，速度是最快的；当表本身已经有序或逆序时，速度最慢。
   >
   > 选项 D 中的序列已按关键字排好序，因此它是最慢的，而选项 A 中第一趟枢轴值 21 将表划分为两个子表｛9 , 17 , 5｝和｛25 ,23 , 30｝，而后对两个子表划分时，枢轴值再次将它们等分，所以该序列是快速排序最优的情况，速度最快。其他选项可以类似分析。

5. 对下列 4 个序列，以第一个关键字为基准用快速排序算法进行排序，在第一趟过程中移动记录次数最多的是（<span style="color:red;">B</span>）

   A. 92, 96, 88, 42, 30, 35, 110, 100 B. 92, 96, 100, 110, 42, 35, 30, 88

   C. 100, 96, 92, 35, 30, 110, 88, 42 D. 42, 30, 35, 92, 100, 96, 88, 110

   > 以选项 A 为例：由于枢轴值为 92，因此 35 移动到第一个位置，96 移动到第六个位置，30 移动到第二个位置，再将枢轴值移动到 30 所在的单元，即第五个位置，所以选项 A 中序列移动的次数为 4。
   >
   > 同样，可以分析出选项 B 中序列的移动次数为 8，选项 C 中序列的移动次数为 4，选项 D 中序列的移动次数为 2。

6. 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一 “趟”。下列序列中，不可能是快速排序第二趟结果的是（<span style="color:red;">D</span>）。

   A. 5, 2, 16, 12, 28, 60, 32, 72 B. 2, 16, 5, 28, 12, 60, 32, 72 C. 2, 12, 16, 5, 28, 32, 72, 60 D. 5, 2 , 12, 28, 16, 32, 72, 60

   > 对尚未确定最终位置的所有元素都处理一遍才是一趟，所以此时要对前后两块子表各做一次快速排序才是一 “趟”，如果只对一块子表进行了排序，而未处理另一块子表，就不能算是完整的一趟。
   >
   > - 选项 A，第一趟匹配 72，只余一块无序序列，第二趟匹配 28，选项 A 可能。
   > - 选项 B，第一趟匹配 2，第二趟匹配 72，B 可能。
   > - 选项 C，第一趟匹配 2，第二趟匹配 28 或 32，选项 C 可能。
   > - 选项 D，无论是先匹配 12 还是先匹配 32，都会将序列分成两块，那么第二趟必须有两个元素匹配，所以选项 D 不可能。

7. 下列序列中，（<span style="color:red;">C</span>）可能是执行第一趟快速排序后所得到的序列。

   I. {68, 11, 18, 69, 23,93,73}

   II. {68, 11,69, 23, 18,93,73}

   III. {93,73,68, 11,69,23, 18}

   IV. {68,11,69,23,18,73,93}

   A. I、IV B. II、III C. IIL、IV D. 只有 IV

   > 显然，若按从小到大排序，则最终有序的序列是｛11,18,23,68,69,73,93｝；
   >
   > 若按从大到小排序，则最终有序的序列是｛93,73,69, 68,23,18,11｝。对比可知
   >
   > - 选项 I、II 中没有处于最终位置的元素，故选项 I、II 都不可能。
   > - 选项 III 中 73 和 93 处于从大到小排序后的最终位置，而且 73 将序列分割成大于 73 和小于 73 的两部分，故选项 III 是有可能的。
   > - 选项 IV 中 73 和 93 处于从小到大排列后的最终位置，73 也将序列分割成大于 73 和小于 73 的两部分。

8. 采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中，正确的是（<span style="color:red;">D</span>）。

   A. 递归次数与初始数据的排列次序无关

   B. 每次划分后，先处理较长的分区可以减少递归次数

   C. 每次划分后，先处理较短的分区可以减少递归次数

   D. 递归次数与每次划分后得到的分区的处理顺序无关

   > 递归次数与各元素的初始排列有关。
   >
   > - 若每次划分后分区比较平衡，则递归次数少；
   > - 若分区不平衡，递归次数多。
   >
   > 递归次数与处理顺序是没有关系的。

## 选择排序

选择排序：每一趟在待排序元素中选取关键字最小（最大）的元素加入有序子序列

### 简单选择排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/280.png)

思想：假设排序表为$L[1\cdots n]$，第$i$趟排序即从$L[i\cdots n]$中选择关键字最小的元素与$L(i)$交换，每一趟排序可以确定一个元素的最终位置，这样经过趟排序就可使得整个排序表有序。

```cpp
void swap(int &a, int &b) {
  int t = a;
  a = b;
  b = t;
}

void SelectSort(int A[], int n) {
  for (int i = 0; i < n - 1; i++) {
    int min = i;
    for (int j = i + 1; j < n; j++) {
      if (A[j] < A[min]) {
        min = j;
      }
    }
    if (min != i) {
      swap(A[min], A[i]);
    }
  }
}
```

- 空间复杂度：$O(1)$

  仅使用常数个辅助单元，故空间效率为$O(1)$

- 时间复杂度：$O(n^2)$

  无论有序、逆序、乱序，都需要 n-1 趟处理。

- 稳定性：不稳定

适用于顺序表和链表。

### 堆排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/284.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/286.png)

n 个关键字序列$L[1\cdots n]$满足下面某一条性质，称为**堆**（Heap）

- 大根堆（大顶堆）：$L(i)\geqslant L(2i)$ 且 $L(i)\geqslant L(2i + 1) (1\leqslant i\leqslant n/2)$
- 小根堆（小顶堆）：$L(i)\leqslant L(2i)$ 且 $L(i)\leqslant L(2i+ 1) (1\leqslant i\leqslant n/2)$

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/281.png)

可以将堆**视为一棵完全二叉树**

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/282.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/283.png)

<img src="../../../images/计算机/数据结构和算法/54.png" style="zoom: 50%;" />

堆排序思路：

1. **调整为大根堆**：

   首先将存放在$L[1\cdots n]$中的 n 个元素建成大根堆，从后往前把所有非终端结点都检查一遍，查看是否满足大根堆的要求，即检查当前结点是否满足根$\geqslant$左、右，如果不满足，则将当前结点与更大的结点进行互换。

2. **输出堆顶元素**：

   由于堆顶元素就是最大值，将堆顶元素加入有序子序列，通常是与待排序序列的最后一个元素交换。然后将待排序元素序列再次调整为大根堆。

::: tip

在顺序存储的 n 个结点的完全二叉树中，非终端结点的编号是$i\leqslant \left \lfloor n/2 \right \rfloor$。

:::

实现：

```cpp
// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len) {
  // A[0]暂存子树根节点
  A[0] = A[k];
  // 沿key较大的子结点向下筛选
  for (int i = 2 * k; i < len; i *= 2) {
    if (i < len && A[i] < A[i + 1]) {
      i++;// 取key值较大的子节点下标
    }
    if (A[0] >= A[i]) {
      break;// 筛选结束
    } else {
      A[k] = A[i];// 将A[i]调整到双亲结点上
      k = i;// 修改k值以便继续向下筛选
    }
  }
  A[k] = A[0];// 被筛选结点的值放入最终位置
}

// 建立大根堆
void BuildMaxHeap(int A[], int len) {
  // 从后往前调整所有非终端结点
  for (int i = len / 2; i > 0; i--) {
    HeadAdjust(A, i, len);
  }
}

void swap(int &a, int &b) {
  int t = a;
  a = b;
  b = t;
}

// 堆排序
void HeapSort(int A[], int len) {
  BuildMaxHeap(A, len);// 建立初始堆
  for (int i = len; i > 1; i--) {
    // 堆顶元素和堆底元素交换
    swap(A[i], A[1]);
    // 把剩余元素调整成大根堆
    HeadAdjust(A, 1, i - 1);
  }
}
```

- 时间复杂度：$O(n\log_2n)=O(n)+O(n\log_2n)$

  建立初始堆的时间复杂度为$O(n)$；排序的时间复杂度为$O(n\log_2n)$

- 空间复杂度：$O(1)$

堆排序是不稳定的。

---

**在堆中插入元素**

进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/285.png)

**在堆中删除元素**

被删除元素用堆底元素替代，然后让该元素不断下坠，直到无法下坠为止。

## 题目

1. 简单选择排序算法的比较次数和移动次数分别为（<span style="color:red">C</span>）。

   A. $O(n)$，$O(\log _2n)$ B. $O(\log _2n)$，$O(n^2)$ C. $O(n^2)$，$O(n)$ D. $O(n\log _2n)$，$O(n)$

2. 设线性表中每个元素有两个数据项$k_1$和$k_2$，现对线性表按以下规则进行排序：先看数据项$k_1$，$k_1$值小的元素在前，大的元素在后；在化$k_1$相同的情况下，再看$k_2$，$k_2$值小的在前，大的元素在后。满足这种要求的排序方法是（<span style="color:red">D</span>）。

   A. 先按$k_1$进行直接插入排序，再按$k_2$进行简单选择排序

   B. 先按$k_2$进行直接插入排序，再按$k_1$进行简单选择排序

   C. 先按$k_1$进行简单选择排序，再按$k_2$进行直接插入排序

   D. 先按$k_2$进行直接插入排序，再按$k_1$进行直接插入排序

   > 直接插入排序算法是稳定的，而简单选择排序算法是不稳定的。

3. 若只想得到 1000 个元素组成的序列中第 10 个最小元素之前的部分排序的序列，用（<span style="color:red">D</span>）方法最快。

   A.冒泡排序 B.快速排序 C. 希尔排序 D.堆排序

   > 希尔排序和快速排序要等排序全部完成之后才能确定最小的 10 个元素。冒泡排序需要从后向前执行 10 趟冒泡才能得到 10 个最小的元素，而堆排序只需调整 10 次小根堆，调整时间与树高成正比。显然堆排序所需的时间更短。
   >
   > **通常，取一大堆数据中的 n 个最大（最小）的元素时，都优先采用堆排序。**

4. 有一组数据(15, 9, 7, 8,20,-1,7, 4)，用堆排序的筛选方法建立的初始小根堆为（<span style="color:red">C</span>）。

   A. -1, 4, 8, 9, 20, 7, 15, 7 B. -1, 7, 15, 7, 4, 8, 20, 9 C. -1, 4, 7, 8, 20, 15, 7, 9 D. A，B，C 均不对

   > ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/326.png)

5. 向具有 n 个结点的堆中插入一个新元素的时间复杂度为（<span style="color:red">C</span>），删除一个元素的时间复杂 度为（<span style="color:red">C</span>）。

   A. $O(1)$ B. $O(n)$ C. $O(\log _2n)$ D. $O(n\log _2n)$

   > 在向有 n 个元素的堆中插入一个新元素时，需要调用一个向上调整的算法，比较次数最多等于树的高度减 1，由于树的高度为$\left \lfloor \log _2n \right \rfloor+1$，所以堆的向上调整算法的比较次数最多等于$\left \lfloor \log _2n \right \rfloor$。
   >
   > 注意，调整堆和建初始堆的时间复杂度是不一样的。

6. 构建 n 个记录的初始堆，其时间复杂度为（<span style="color:red">A</span>）；对 n 个记录进行堆排序，最坏情况下其 时间复杂度为（<span style="color:red">D</span>）。

   A. $O(n)$ B. $O(n^2)$ C. $O(\log _2n)$ D. $O(n\log _2n)$

   > 建堆过程中，向下调整的时间与树高力有关，为$O(h)$。
   >
   > 每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为 n 的序列上建堆，其时间复杂度为$O(n)$。
   >
   > 无论是在最好情 况下还是在最坏情况下，堆排序的时间复杂度均为$O(n\log _2n)$。

7. 已知序列 25, 13, 10, 12, 9 是大根堆，在序列尾部插入新元素 18，将其再调整为大根堆，调整过程中元素之间进行的比较次数是（<span style="color:red">B</span>）。

   A. 1 B. 2 C. 4 D. 5

   > 首先 18 与 10 比较，交换位置，再与 25 比较，不交换位置。共比较了 2 次。
   >
   > ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/327.png)

8. 将关键字 6, 9, 1, 5, 8, 4, 7 依次插入到初始为空的大根堆 H 中，得到的 H 是（<span style="color:red">B</span>）。

   A. 9, 8, 7, 6, 5, 4, 1 B. 9, 8, 7, 5, 6, 1, 4 C. 9, 8, 7, 5, 6, 4, 1 D. 9, 6, 7, 5, 8, 4, 1

   > ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/328.png)

## 归并排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/288.png)

归并：将两个或两个以上的有序表合并成一个新的有序表。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/287.png)

```cpp
// A[low...mid],A[mid...high]各自有序
void Merge(int A[], int low, int mid, int high) {
  int i, j, k;
  int B[low + high + 1];// 辅助数组
  for (k = low; k <= high; k++) {
    B[k] = A[k];// 将A中的元素复制到B中
  }
  for (i = low, j = mid + 1, k = i; i < mid && j <= high; k++) {
    // 将较小值复制到A中
    A[k] = B[i] <= B[j] ? B[i++] : B[j++];
  }
  while (i <= mid)A[k++] = B[i++];
  while (j <= high)A[k++] = B[j++];
}

void MergeSort(int A[], int low, int high) {
  if (low < high) {
    int mid = (low + high) / 2;
    MergeSort(A, low, mid);
    MergeSort(A, mid + 1, high);
    Merge(A, low, mid, high);
  }
}
```

```cpp
// 归并排序
void Merge(int num[], int l, int mid, int r) {
  // 储存排序结果的辅助数组（也可以不使用辅助数组，直接在原数组进行排序，但更麻烦）
  int res[l + r + 1], resIndex = 0;
  // 排序
  int lIndex = l, rIndex = mid + 1;
  while (lIndex <= mid && rIndex <= r) {
    res[resIndex++] = num[lIndex] < num[rIndex] ? num[lIndex++] : num[rIndex++];
  }
  while (lIndex <= mid) {
    res[resIndex++] = num[lIndex++];
  }
  while (rIndex <= r) {
    res[resIndex++] = num[rIndex++];
  }
  // 修改原数组
  for (int i = l, j = 0; i <= r && j < resIndex; i++, j++) {
    num[i] = res[j];
  }
}

void MergeSort(int num[], int l, int r) {
  if (l >= r) {
    return;
  } else {
    int mid = (l + r) / 2;
    MergeSort(num, l, mid);
    MergeSort(num, mid + 1, r);
    Merge(num, l, mid, r);
  }
}
```

时间复杂度：$O(n\log_2n)$

空间复杂度：$O(n)$

归并排序是稳定的。

## 基数排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/293.png)

基数排序**不基于比较和移动**进行排序，而基于关键字各位的大小进行排序。

假设长度为$n$的线性表中每个结点$a_j$的关键字由$d$元组（$k^{d-1}_j,k^{d-2}_j,k^{d-3}_j,\cdots ,k^{1}_j,k^{0}_j$）组成。$k^{d-1}_j$称为最高位关键字（最主位关键字）；$k^{0}_j$称为最低位关键字（最次位关键字）；其中，$0\leqslant k_j^i\leqslant r-1$，（$0\leqslant j<n,0\leqslant i \leqslant d - 1$），$r$称为基数。

为实现多关键字排序，通常有两种方法：

1. 最高位优先（MSD）法：按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。
2. 最低位优先（LSD）法：按关键字位权重递增依次进行排序，最后形成一个有序序列。

基数排序得到递减序列过程：

1. 初始化，设置$r$个空队列，$Q_{r-1}，Q_{r-2},\cdots,Q_0$
2. 按照各个关键字位的权重的递增的次序（个、十、百…），对 d 个关键字分别进行“分配”和“收集”。
   - 分配：顺序扫描各个元素，若当前出来的关键字位=x，则将元素插入$Q_x$队尾；
   - 收集：把$Q_{r-1}，Q_{r-2},\cdots,Q_0$各个队列的结点依次出队

::: tip

如果想要得到递增序列，只需在收集时按照$Q_0,Q_{1}\cdots,Q_{r-1}$的顺序进行出队即可

:::

示例：

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/289.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/290.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/291.png)

---

- 空间复杂度

  需要$r$个辅助队列，所以空间复杂度为$O(r)$

- 时间复杂度

  基数排序需要进行$d$趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$，所以基数排序的时间复杂度为$O(d(n + r))$，它与序列的初始状态无关。

- 稳定性

  基数排序是稳定的

---

基数排序擅长解决的问题：

1. 数据元素的关键字元素可以方便的拆分为 d 组，且 d 较小；（反例：给 5 个人的身份证号排序）
2. 每组关键字的取值范围不大，即 r 较小；（反例：给人名排序）
3. 数据元素个数 n 较大；（擅长：给十亿人的身份证号排序）

应用示例

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/292.png)

## 题目

1. 在下列排序算法中，平均情况下空间复杂度为$O(n)$的是（<span style="color:red;">D</span>）；最坏情况下空间复杂度为$O(n)$的是（<span style="color:red;">C</span>）。

   I.希尔排序 II. 堆排序 III.冒泡排序 IV.归并排序 V. 快速排序 VI.基数排序

   A. I、IV、VI B. II、V C. IV、V D. IV

   > 归并排序算法在平均情况下和最坏情况下的空间复杂度都会达到$O(n)$，快速排序只在最坏情况下才会达到$O(n)$，平均情况下为$O(\log _2n)$。

2. 2 路归并排序中，归并趟数的数量级是（<span style="color:red;">B</span>）。

   A. $O(n)$ B. $O(\log _2n)$ C. $O(n\log _2n)$ D. $O(n^2)$

   > 对于 N 个元素进行 k 路归并排序时，排序的趟数 m 满足$m=\left \lceil \log _kN \right \rceil$，所以，本题中即为$\left \lceil \log _2n \right \rceil$。

3. 将两个各有 N 个元素的有序表合并成一个有序表，最少的比较次数是（<span style="color:red;">A</span>），最多的比较次数是（<span style="color:red;">B</span>）。

   A. N B. 2N-1 C. 2N D. N-1

   > 注意到当一个表中的最小元素比另一个表中的最大元素还大时，比较的次数是最少的，仅比较 N 次；而当两个表中的元素依次间隔地比较时，即$a_1<b_1<a_2<b_2<\cdots$时，比较的次数是最多的，为 2N-1 次。

4. 对给定的关键字序列 110, 119, 007, 911, 114, 120, 122 进行基数排序, 第 2 趟分配收集后得到的关键字序列是（<span style="color:red;">C</span>）。

   A. 007, 110, 119, 114, 911, 120, 122

   B. 007, 110, 119, 114, 911, 122, 120

   C. 007, 110, 911, 114, 119, 120, 122

   D. 110, 120, 911, 122, 114, 007, 119

   > 基数排序的第 1 趟排序是按照个位数字的大小来进行的，第 2 趟排序是按照十位数字的大小来进行的。
   >
   > ![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/329.png)

## 内部排序算法的比较及应用

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/319.png)

## 题目

1. 排序趟数与序列的原始状态无关的排序方法是（<span style="color:red">B</span>）。

   I.直接插入排序 II.简单选择排序 III.冒泡排序 IV.基数排序

   A. I、III B. I、II、IV C. I、II、III D. I、IV

   > - 交换类的排序，其趟数和原始序列状态有关，故冒泡排序与初始序列有关。
   > - 直接插入排序： 每趟排序都插入一个元素，所以排序趟数固定为 n-1。
   > - 简单选择排序：每趟排序都选出一个最小（或最大）的元素，所以排序趟数固定为 n-1。
   > - 基数排序：每趟排序都要进行"分配”和“收集”，排序趟数固定为 d。

2. 若序列的原始状态为{1, 2, 3, 4, 5, 10, 6, 7, 8, 9}，要想使得排序过程中的元素比较次数最少，则应该采用（<span style="color:red">A</span>）方法。

   A.插入排序 B,选择排序 C.希尔排序 D.冒泡排序

   > 选择排序和序列初态无关，直接排除。初始序列基本有序时，插入排序比较次数较少。本题 中，插入排序仅需比较 n -1+ 4 次，而希尔排序和冒泡排序的比较次数均远大于此。

3. 下列排序方法中，若将顺序存储更换为链式存储，则算法的时间效率会降低的是（<span style="color:red">D</span>）。

   I.插入排序 II.选择排序 III.起泡排序 IV.希尔排序 V.堆排序

   A,仅 I、II B.仅 II、III C.仅 III、IV D.仅 IV、V

   > 插入排序、选择排序、起泡排序的原本时间复杂度是$O(n^2)$，更换为链式存储后的时间复杂度还是$O(n^2)$。希尔排序和堆排序都利用了顺序存储的随机访问特性，而链式存储不支持这种性质，所以时间复杂度会增加，因此选择选项 D。

4. 选择一个排序算法时，除算法的时空效率外，下列因素中，还需要考虑的是（<span style="color:red">D</span>）。

   I.数据的规模 II.数据的存储方式 III.算法的稳定性 IV.数据的初始状态

   A.仅 III B.仅 I、II C.仅 II、III、IV D. I、II、III、IV

   > - 当数据规模较小时可选择复杂度为$O(n^2)$的简单排序方法，当数据规模较大时应选择复杂度为$O(n\log _2n)$的排序方法，当数据规模大到内存无法放下时需选择外部排序方法，说法 I 正确。
   > - 数据的存储方式主要分为顺序存储和链式存储，有些排序方法(如堆排序)只能用于顺序存储方式，说法 II 正确。
   > - 若对数据稳定性有要求，则不能选择不稳定的排序方法，说法 III 正确。
   > - 当数据初始基本有序时，直接插入排序的效率最高，冒泡排序和直接插入排序的时间复杂度都是 $O(n)$，而归并排序的时间复杂度依旧是$O(n\log _2n)$，说法 IV 正确。
   >
   > 所以选择选项 D。

## 外部排序

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/304.png)

前面介绍过的排序方法都是在内存中进行的（称为内部排序）。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/294.png)

外部排序：将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/295.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/296.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/297.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/298.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/299.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/300.png)

……

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/301.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/302.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/303.png)

::: tip

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/305.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/306.png)

:::

## 败者树

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/307.png)

败者树是树形选择排序的一种变体， **可视为一棵完全二叉树**。k 个叶结点分别是当前参加比较的元素，非叶子结点用来记忆左右子树中的"失败者”，而让胜者往上继续进行比较，一直到根结点。

> [8.7*2*败者树](https://www.bilibili.com/video/BV1b7411N798?t=371.2&p=97)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/308.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/309.png)

## 置换-选择排序

> [8.7*3*置换-选择排序](https://www.bilibili.com/video/BV1b7411N798?t=159.3&p=98)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/310.png)

## 最佳归并树

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/318.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/311.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/312.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/313.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/314.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/315.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/316.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/计算机/数据结构和算法/317.png)
