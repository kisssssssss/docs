---
title: 并发控制
index: 11
typora-root-url: ./..\..\..\..\..\IMG\docs\计算机\数据库系统概论
---

允许多个用户同时使用的数据库系统称为**多用户数据库系统**。例如飞机定票数据库系统，银行数据库系统。它们的特点是在同一时刻并发运行的事务数可达数百上千个 。

多事务执行方式：

1. **事务串行执行**

   每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行。

   不能充分利用系统资源，发挥数据库共享资源的特点。

   ![](182.png)

2. **交叉并发方式**

   在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行。

   单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率。

   ![](181.png)

3. **同时并发方式**

   多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行。

   最理想的并发方式，但受制于硬件环境。

# 并发控制概述

事务是并发控制的基本单位。

并发控制机制的任务：

- 对并发操作进行正确调度
- 保证事务的隔离性
- 保证数据库的一致性

> 例：飞机订票系统中的一个活动序列：
>
> 1. 甲售票点(事务T1)读出某航班的机票余额A，设A=16；
> 2. 乙售票点(事务T2)读出同一航班的机票余额A，也为16；
> 3. 甲售票点卖出一张机票，修改余额A为15，把A写回数据库；
> 4. 乙售票点也卖出一张机票，修改余额A为15，把A写回数据库；
>
> 结果明明卖出两张机票，数据库中机票余额只减少1 。
>
> 这种由并发操作引起的情况称为数据库的不一致性。在并发操作情况下，对T1、T2两个事务的操作序列的调度是随机的。

并发操作带来的数据不一致性包括：

1. **丢失修改**

   两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失。

   上面飞机订票例子就属此类。

2. **不可重复读**

   事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。

   不可重复读包括三种情况：

   - 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时，得到与前一次不同的值。
   - 事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录消失了。 
   - 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。

   后两种不可重复读有时也称为幻影现象。

3. **读“脏”数据**

   事务T1修改某一数据，并将其写回磁盘。事务T2读取同一数据后，T1由于某种原因被撤销。
   这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，T2读到的数据就为“脏”数据，即不正确的数据。

产生这三类数据不一致性的主要原因就是并发操作破坏了事务的隔离性。

并发控制机制就是**要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰**，从而避免造成数据的不一致性。

对数据库的应用有时允许某些不一致性，可以降低对一致性的要求以减少系统开销。

并发控制的主要技术有：

1. 封锁
2. 时间戳
3. 乐观控制法
4. 多版本并发控制

# 封锁

封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。

加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

封锁是实现并发控制的一个非常重要的技术。

一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。

基本封锁类型：

- **排它锁**（Exclusive Locks，简记为X锁）

  又称为**写锁**。

  若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。

  保证其他事务在T释放A上的锁之前不能再读取和修改A。

- **共享锁**（Share Locks，简记为S锁）

  又称为**读锁**。

  若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。

  保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

---

![](183.png)

最左边一列表示事务T1已经获得的数据对象上的锁的类型，其中横线表示没有加锁。最上面一行表示另一事务T2对同一数据对象发出的封锁请求。

T2的封锁请求能否被满足用矩阵中的Y和N表示，

- Y表示事务T2的封锁要求与T1已持有的锁相容，封锁请求可以满足
- N表示T2的封锁请求与T1已持有的锁冲突，T2的请求被拒绝

# 封锁协议

在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为**封锁协议**。 例如：何时申请X锁或S锁，持锁时间，何时释放。

对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。

三级封锁协议：

1. **一级封锁协议**

   事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。

   一级封锁协议可**防止丢失修改**，并保证事务T是可恢复的。

   在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

2. **二级封锁协议**

   一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

   可以**防止丢失修改和读“脏”数据**，但由于读完数据后即可释放S锁，所以它不能保证可重复读。

3. **三级封锁协议**

   一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

   可**防止丢失修改、读脏数据和不可重复读**。

三级协议的主要区别在于什么操作需要申请封锁以及何时释放锁（即持锁时间）。

不同的封锁协议使事务达到的一致性级别不同，封锁协议级别越高，一致性程度越高。

![](184.png)

# 活锁和死锁

封锁技术可以有效地解决并行操作的一致性问题，但也带来死锁和活锁等问题。

## 活锁

事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……

T2有可能永远等待，这就是**活锁**的情形。

采用**先来先服务**的策略来避免活锁。当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

## 死锁

事务T1封锁了数据R1，T2封锁了数据R2。T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。

这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成**死锁**。

解决死锁的两类方法：
1. **死锁的预防**

   产生死锁的原因是两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待。

   预防死锁的发生就是要破坏产生死锁的条件。

   预防死锁的方法：

   - **一次封锁法**

     要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。

     存在的问题：

     - 降低系统的并发度

     - 难于事先精确确定封锁对象

       数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象。

   - **顺序封锁法**

     预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。

     存在的问题：

     - 维护成本

       数据库系统中封锁的数据对象极多，并且不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。

     - 难以实现

       事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁。

2. **死锁的诊断与解除**

   死锁的诊断：

   - **超时法**

     如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。

     优点：实现简单。

     缺点：有可能误判死锁；时限若设置得太长，死锁发生后不能及时发现。

   - **等待图法** 

     用事务等待图动态反映所有事务的等待情况。

     并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。

     事务等待图是一个有向图G=(T，U)，T为结点的集合，每个结点表示正运行的事务，U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2。

     > ![](185.png)

   解除死锁：选择一个处理死锁代价最小的事务，将其撤消，释放此事务持有的所有的锁，使其它事务能继续运行下去。

# 并发调度的可串行性

数据库管理系统对并发事务不同的调度可能会产生不同的结果。

## 可串行化调度

多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为**可串行化调度**。

**可串行性**是并发事务正确调度的准则。按照这个准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是**正确调度**。

> 例：
>
> 现在有两个事务，分别包含下列操作：
>
> - 事务T1：读B；A=B+1；写回A
> - 事务T2：读A；B=A+1；写回B
>
> 现给出对这两个事务不同的调度策略
>
> ![](186.png)
>
> <br />
>
> ![](187.png)
>
> <br />
>
> ![](188.png)
>
> <br />
>
> ![](189.png)

## 冲突可串行化调度

**冲突操作**是指不同的事务对同一数据的读写操作和写写操作，除了读写和写写操作，其他操作是不冲突操作。

不同事务的冲突操作和同一事务的两个操作是不能交换的。

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是**冲突可串行化的调度**。

![](190.png)

若一个调度是冲突可串行化，则一定是可串行化的调度。可用这种方法判断一个调度是否是冲突可串行化的。

冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。

![](191.png)

# 两段锁协议

数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性。

两段锁协议：指所有事务必须分两个阶段对数据项加锁和解锁

- 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。
- 在释放一个封锁之后，事务不再申请和获得任何其他封锁。

“两段”锁的含义：事务分为两个阶段

- 第一阶段是获得封锁，也称为扩展阶段

  事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁。

- 第二阶段是释放封锁，也称为收缩阶段

  事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。

事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。

若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议。

两段锁协议与防止死锁的一次封锁法的区别：

- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议。
- 两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此**遵守两段锁协议的事务可能发生死锁**。

# 封锁的粒度

封锁对象的大小称为**封锁粒度**。

封锁的对象：逻辑单元，物理单元。

封锁粒度与系统的并发度和并发控制的开销密切相关。

- 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小。
- 封锁的粒度越小，并发度较高，但系统开销也就越大。

选择封锁粒度应该同时考虑封锁开销和并发度两个因素，适当选择封锁粒度。例如：

- 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
- 需要处理大量元组的用户事务：以关系为封锁单元
- 需要处理少量元组的用户事务：以元组为封锁单位

## 多粒度封锁

**多粒度封锁**是在一个系统中同时支持多种封锁粒度供不同的事务选择。

**多粒度树**：以树形结构来表示多级封锁粒度；根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度。

![](192.png)

多粒度封锁中允许多粒度树中的每个结点被独立地加锁。对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。

在多粒度封锁中一个数据对象可能以两种方式封锁：

- 显式封锁：直接加到数据对象上的封锁
- 隐式封锁：是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁

显式封锁和隐式封锁的效果是一样的。

系统检查封锁冲突时，不仅要检查显式封锁，还要检查隐式封锁。

对某个数据对象加锁，系统要检查

- 该数据对象有无显式封锁与之冲突

- 所有上级结点

  检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）。

- 所有下级结点

  看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突。

## 意向锁

引进意向锁目的是提高对某个数据对象加锁时系统的检查效率。

如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。

对任一结点加基本锁，必须先对它的上层结点加意向锁。例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁 。

常用的意向锁：

1. 意向共享锁 (Intent Share Lock，简称**IS锁**)

   如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。

   例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁。

2. 意向排它锁 (Intent Exclusive Lock，简称**IX锁**)

   如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。
   例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁 。

3. 共享意向排它锁 (Share Intent Exclusive Lock，简称**SIX锁**)

   如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁。

   例：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

![](193.png)

锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。

![](194.png)

具有意向锁的多粒度封锁方法，申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。

具有意向锁的多粒度封锁方法，提高了系统的并发度，减少了加锁和解锁的开销，在实际的数据库管理系统产品中得到广泛应用。