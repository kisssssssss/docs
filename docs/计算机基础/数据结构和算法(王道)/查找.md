---
title: 查找
index: 8
typora-root-url: ./..\..\..\..\IMG\docs\计算机\数据结构和算法
---



# 查找的基本概念

- 查找

  在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：查找成功、查找失败。

- 查找表(查找结构)

  用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。

  对查找表经常进行的操作一般有4 种：

  1. 查询某个特定的数据元素是否在查找表中：
  2. 检索满足条件的某个特定的数据元素的各种属性；
  3. 在查找表中插入一个数据元素；
  4. 从查找表中删除某个数据元素；

- 静态查找表

  若一个查找表无须动态地修改元素， 则此类查找表称为静态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；

- 动态查找表

  若一个查找表需要动态地插入或删除元素，则此类查找表称为动态查找表。适合动态查找表 的查找方法有二叉排序树的查找、散列查找等。

- 关键字

  数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。

- 平均查找长度

  在查找过程中，一次查找的长度是指**需要比较的关键字的次数**称为查找长度，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为
  $$
  ASL =\sum^{n}_{i=1}P_iC_i
  $$
  式中，n是查找表的长度；$P_i$是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即$P_i=1/n$；$C_i$是找到第i个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。

# 顺序查找

> [7.2_1_顺序查找](https://www.bilibili.com/video/BV1b7411N798?p=70)

![](156.png)

顺序查找又称线性查找，通常用于线性表，它对顺序表和链表都是适用的。

- 对于顺序表，可通过数组下标递增来顺序扫描每个元素；
- 对于链表，可通过指针next来依次扫描每个元素；

顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。

---

- 一般线性表的顺序查找

  ```cpp
  typedef struct {// 查找表的数据结构，顺序表
      int *elem;// 动态数组基址
      int TableLen;// 表的长度
  } SSTable; 
  // 第一种
  int Search_Seq1(SSTable ST, int key) {
    int i；
    for (i = 0; i < ST.TableLen && ST.elem[i] != key; i++);
    return i == ST.TableLen ? -1 : i;
  }
  // 第二种
  int Search_Seq2(SSTable ST, int key) {
    ST.elem[0] = key; // 哨兵
    int i；
    for (i = ST.TableLen; ST.elem[i] != key; i--);
    return i;// 若表中不存在关键字为key的元素，将查找到i为0时退出for循环
  }
  ```

  查找成功的平均查找长度$ASL=\frac{n+1}{2}$；

  查找失败的平均查找长度$ASL=n+1$；

- 有序表的顺序查找

  若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。 

  查找成功的平均查找长度$ASL=\frac{n+1}{2}$；
  
  查找失败的平均查找长度$ASL=\frac{n}{2}+\frac{n}{n+1}$；
  
  ![](169.png)



# 折半查找

![](158.png)

折半查找又称二分查找，它仅适用于有序的顺序表。 

基本思想：首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。 然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。  

```cpp
typedef struct {// 查找表的数据结构，顺序表
    int *elem;// 动态数组基址
    int TableLen;// 表的长度
} SSTable;

int Binary_Search(SSTable L, int key) {
  int low = 0, high = L.TableLen - 1, mid;
  while (low <= high) {
    mid = (low + high) / 2; //取中间位置
    if (L.elem[mid] == key) {
      return mid; //查找成功则返回所在位置
    } else if (L.elem[mid] > key) {
      high = mid - 1;//从前半部分继续查找
    } else {
      low = mid + 1; //从后半部分继续查找
    }
  }
  return -1; //查找失败，返回T
}
```

判定树：树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。

若有序序列有n个元素，则对应的判定树有**n个圆形的非叶结点**和**n+1个方形的叶结点**。

![](157.png)

折半查找的判定树一定是一棵平衡二叉树。

折半查找的判定树中，只有最下面一层是不满的，因此元素个数为n时，树高$h=\log_2{(n+1)}$

折半查找的的时间复杂度为$O(\log_2n)$

# 分块查找

![](161.png)

分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。 

分块查找的基本思想：将查找表分为若干子块。**块内的元素可以无序，但块间的元素是有序的**，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。 

![](159.png)

分块查找的过程分为两步：

1. 在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；
2. 在块内顺序查找。 

---

设索引查找和块内查找的平均查找长度分别为$L_I$，$L_S$，则分块查找的平均查找长度为$ASL=L_I+L_S$

![](160.png)

- 用**顺序查找**查索引表

  则$L_I=(1+2+ \cdots +b)/b=\frac{b+1}{2}$，$L_S=(1+2+ \cdots +s)/s=\frac{s+1}{2}$，则$ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$。**当$s=\sqrt{ n}$时，ASL最小，为$\sqrt{n}+1$。**

- 用**折半查找**查索引表

  则$L_I=\left \lceil  {\log_2{(b+1)}} \right \rceil$，$L_S=(1+2+ \cdots +s)/s=\frac{s+1}{2}$，则$ASL=\left \lceil  {\log_2{(b+1)}} \right \rceil+\frac{s+1}{2}$

# 题目

1. 由n个数据元素组成的两个表：一个递增有序，一个无序。采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任意一个元素的概率是相同的，则在两种表中成功查找（<span style="color:red;">B</span>）。

   A.平均时间后者小	B.平均时间两者相同	C.平均时间前者小	D.无法确定

   > 对于顺序查找，不管线性表是有序的还是无序的，成功查找第一个元素的比较次数为1，成功查找第二个元素的比较次数为2，以此类推，即每个元素查找成功的比较次数只与其位置有关 （与是否有序无关），因此查找成功的平均时间两者相同。

2. 对长度为3的顺序表进行查找，若查找第一个元素的概率为1/2，查找第二个元素的概 率为1/3，查找第三个元素的概率为1/6，则查找任意一个元素的平均查找长度（<span style="color:red;">A</span>）。

   A. 5/3	B. 2	C. 7/3	D. 4/3

   > $ASL = \frac{1}{2}\times 1+\frac{1}{3}\times 2+\frac{1}{6}\times 3=\frac{5}{3}$

3. 下列关于二分查找的叙述中，正确的是（<span style="color:red;">D</span>）。

   A. 表必须有序，表可以顺序方式存储，也可以链表方式存储

   B. 表必须有序且表中数据必须是整型、实型或字符型

   C. 表必须有序，而且只能从小到大排列

   D. 表必须有序，且表只能以顺序方式存储

   > 二分查找通过下标来定位中间位置元素，故应采用顺序存储，且二分查找能够进行的前提是查找表是有序的，但具体是从大到小还是从小到大的顺序则不做要求。

4. 已知一个长度为16的顺序表，其元素按关键字有序排列，若采用折半查找算法查找一个不存在的元素，则比较的次数至少是（<span style="color:red;">A</span>），至多是（<span style="color:red;">B</span>）。

   A. 4	B. 5	C. 6	D. 7

   > - 画出查找过程中构成的判定树，让最小的分支高度对应于最少的比较次数，让最大的分支高度对应于最多的比较次数，出现类似于长度为15的顺序表时，判定树刚好是一棵满树，此时最多比较次数与最少比较次数相等。
   > - 直接用公式求出最小的分支高度和最大分支高度，最大分支高度为$H=\left \lceil \log_2{(n+1)} \right \rceil =5$，这对应的就是最多比较次数，然后由于判定树不是一棵满树，所以至少应该是4 (由判定树的各分支高度最多相差1得出)。
   >
   > ::: tip
   >
   > - 若是求查找成功或查找失败的平均查找长度，则需要画出判定树进行求解。
   >
   > - 对长度为n的有序表，采用折半查找时，查找成功和查找失败的最多比较次数相同，均为$\left \lceil \log_2{(n+1)} \right \rceil$
   >
   > :::

5. 有12个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的平均查找长度为（<span style="color:red;">A</span>），折半查找查找失败的平均查找长度为（<span style="color:red;">D</span>）。

   A. 37/12	B. 35/12	C. 39/13	D. 49/13

   > 假设有序表中元素为不难画出对它进行折半查找的判定树如下图所示，圆圈是查找成功结点，方形是虚构的查找失败结点。从而可以求出查找成功的ASL = (1+2x2 + 3x4 + 4x5*12 = 37/12，查找失败的 ASL = (3x3+ 4x10)/13 =49/13。
   >
   > ![](170.png)

6. 已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个L中不存在的元素，则关键字的比较次数最多是（<span style="color:red;">B</span>）。

   A. 4	B. 5	C. 6	D. 7

   > 折半查找法在查找不成功时和给定值进行关键字的比较次数最多为树的高度，即$\left \lfloor \log_2n \right \rfloor + 1$或$\left \lceil \log_2{(n+1)} \right \rceil$。在本题中，n= 16，故比较次数最多为5。

7. 对有2500个记录的索引顺序表（分块表）进行查找，最理想的块长为（<span style="color:red;">A</span>）。

   A. 50	B. 125	C. 500	D. $\left \lceil \log_2{2500} \right \rceil$

8. 为提高查找效率，对有65025个元素的有序顺序表建立索引顺序结构，在最好情况下查找到表中已有元素最多需要执行（<span style="color:red;">C</span>）次关键字比较。

   A. 10	B. 14	C. 16	D. 21

   > 为使查找效率最高，每个索引块的大小应是765025=255，为每个块建立索引，则索引表中索引项的个数为255。若对索引项和索引块内部都采用折半查找，则查找效率最高，为$\left \lceil \log_2{(255+1)} \right \rceil+\left \lceil \log_2{(255+1)} \right \rceil=16$。

9. 下列二又树中，可能成为折半查找判定树（不含外部结点）的是（<span style="color:red;">A</span>）。

   ![](171.png)

   > **折半查找判定树是一棵二叉排序树，其中序序列是一个有序序列。**可在树结点上依次填上相应的序号，符合折半查找规则的树即为所求，如下图所示。
   >
   > 折半查找算法在选取中间结点时，要么采用向上取整的方式，要么采用向下取整的方式。
   >
   > B选项，4、5相加除以2采用的是向上取整，7、8相加除以2采用的是向下取整，矛盾。
   >
   > C选项，3、4相加除以2采用的是向上取整，6、7 相加除以2采用的是向下取整，矛盾。
   >
   > D选项，1、10相加除以2采用的是向下取整，6、7相加除以2采用的是向上取整，矛盾。
   >
   > 只有A符合折半查找规则。
   >
   > ![](172.png)



# 二叉排序树(BST)

![](178.png)

::: tip

构造一棵二叉排序树的目的并不是为了排序，而是为了提高查找、插入和删除关键字的速度，二叉排序树这种非线性结构也有利于插入和删除的实现。

:::

## 定义

**二叉排序树**（也称**二叉查找树**）（BST，Binary Search Tree）是一棵空树，或者是具有下列特性的二叉树：

1. 左子树结点值<根结点值<右子树结点值
2. 左、右子树分别是一棵二叉排序树。

对二叉排序树进行中序遍历，可以得到一个递增的有序序列。

```cpp
typedef struct BSTNode {
    int key;
    struct BSTNode *lChild, *rChild;
} BSTNode, *BSTree;
```

## 查找

若二叉排序树非空，先将给定值与根结点的关键字比较，若相如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。

- 非递归实现

  最坏空间复杂度：$O(1)$

  ```cpp
  BSTNode *BST_Search(BSTree T, int key) {
    while (T != nullptr && key != T->key) {
      T = key < T->key ? T->lChild : T->rChild;
    }
    return T;
  }
  ```

- 递归实现

  最坏空间复杂度：$O(h)$，h为递归树的深度

  ```cpp
  BSTNode *BST_Search(BSTree T, int key) {
    if (T == nullptr)return nullptr;
    if (key == T->key) {
      return T;
    } else if (key < T->key) {
      return BST_Search(T->lChild, key);
    } else {
      return BST_Search(T->rChild, key);
    }
  }
  ```

## 插入

若原二叉排序树为空，则直接插入；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。

- 递归实现

  最坏空间复杂度：$O(h)$，h为递归树的深度

  ```cpp
  int BST_Insert(BSTree &T, int key) {
    if (T == nullptr) {
      T = new BSTNode();
      T->key = key;
      T->lChild = T->rChild = nullptr;
      return 1;
    } else if (key == T->key) {
      return 0;
    } else if (key < T->key) {
      return BST_Insert(T->lChild, key);
    } else {
      return BST_Insert(T->rChild, key);
    }
  }
  ```

插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。

## 构造

不同的关键字序列可能得到同样的二叉排序树，也可能得到不同样的二叉排序树。

```cpp
void Creat_BST(BSTree &T, int str[], int n) {
  T = nullptr;
  for (int i = 0; i < n; i++) {
    BST_Insert(T, str[i]);
  }
}
```

## 删除

在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。

1. 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 
2. 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。 
3. 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。

![](173.png)

![](174.png)

![](175.png)

## 查我效率分析

二叉排序树的查找效率，**主要取决于树的高度**。

![](176.png)

![](177.png)

# 平衡二叉树（AVL）

![](186.png)

## 定义

为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树（Balanced Binary Tree），或称AVL树。

结点左子树减去右子树的高度的值为该结点的**平衡因子**，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。 

## 插入

每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。

每次调整的对象都是**最小不平衡子树**，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。

::: tip

在插入操作中，只需将最小不平衡二叉树调整平衡，则其它祖先节点都会恢复平衡。因为插入操作会导致“最小不平衡子树”高度+1，经过调整后高度恢复。

:::

---



![](179.png)

- LL平衡旋转(**右单旋转**)

  由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。

  将A的左孩子**B向右上旋转**代替A成为根结点，将**A结点向右下旋转**成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。

  ![](180.png)

  ---

  

- RR平衡旋转（**左单旋转**）

  由于在结点A的右孩子（R）的右子树（R）上插入了新结点，S的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。 

  将A的右孩子**B向左上旋转**代替A成为根结点，将**A结点向左下旋转**成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。

  ![](181.png)

  ---

  

- LR平衡旋转（先左后右双旋转）

  由于在A的左孩子（L）的右子树（R）上插入新结点， A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。

  先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置，然后把该C结点向右上旋转提升到A结点的位置。

  ![](182.png)

  - 若插入结点在C的右子树上

    ![](183.png)

  - 若插入结点在C的左子树上，处理方式与右子树一样

    ![](184.png)

  

  ---

  

- RL平衡旋转（先右后左双旋转）

  由于在A的右孩子（R）的左子树（L）上插入新结点， A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。

  先将A结点的右孩子B的左子树的根结点**C向右上旋转提升到B结点的位置**，然后把该**C结点向左上旋转提升到A结点的位置**。

  ![](185.png)
  
  ---
  
  



## 查找

在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。

平衡二叉树的**平均查找长度为$O(\log_2n)$**

## 删除

与平衡二叉树的插入操作类似，以删除结点w为例来说明平衡二叉树删除操作的步骤：

1. 用二叉排序树的方法对结点W执行删除操作。

2. 若导致了不平衡，则从结点w开始向上回溯，找到第一个不平衡的结点z （即最小不平 衡子树）；y为结点z的高度最高的孩子结点；x是结点y的高度最高的孩子结点。 

3. 然后对以z为根的子树进行平衡调整，其中x、y和z可能的位置有4种情况：

   - y是z的左孩子，x是y的左孩子（LL，右单旋转）
   - y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）
   - y是z的右孩子，x是y的右孩子（RR，左单旋转）
   - y是z的右孩子，x是y的左孩子（RL，先右后左双旋转）

   这四种情况与插入操作的调整方式一样。不同之处在于，插入操作仅需要对以z为根的子树进行平衡调整；而删除操作就不一样，先对以z为根的子树进行平衡调整，如果调整后子树的高度减1，则**可能需要对z的祖先结点进行平衡调整**，甚至回溯到根结点（导致树高减1）。 

# 红黑树（RBT）

![](187.png)

平衡二叉树AVL，插入和删除操作很容易破坏平衡特性，需要频繁地调整树的形态。为此在AVL树的平衡标准 上进一步放宽条件，引入了红黑树的结构。 

红黑树RBT，插入和删除操作很多时候不会破坏红黑树的特性，无需频繁地调整树的形态、即使需要调整，一般可以在常数级时间内完成。

::: info 总结

平衡二叉树：适用于以查为主，很少插入和删除的场景；

红黑树：适用于频繁插入和删除的场景，实用性更强；

:::

## 定义和性质

![](190.png)

红黑树是二叉排序树。

红黑树满足如下红黑性质：

1. 每个结点或是红色，或是黑色的。 
2. 根结点是黑色的。 
3. 叶结点（虚构的外部结点、NULL结点）都是黑色的。
4. 不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。
5. 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。

![](188.png)

```cpp
struct RBNode {
    int key;
    RBNode *parent;
    RBNode *lChild;
    RBNode *rChild;
    int color; // 结点颜色，可用0/1 表示黑红 
};
```

<br>

**结点的黑高**bh：从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数。

黑高的概念是由性质5确定的。根结点的黑高称为红黑树的黑高。

![](189.png)

::: tip

- 结论1：**从根到叶结点的最长路径不大于最短路径的2倍**。

  当从根到任意一个叶结点的简单路径最短时，这条路径必然全由黑结点构成。当某条路径最长时，这条路径必然是由黑结点和红结点相间构成的，此时红结点和黑结点的数量相同。

- 结论2 ：**若根节点黑高为h，内部结点数（关键字）最少有$2^h-1$个**。

  ![](191.png)

:::

## 查找

查找的过程与二叉排序树和平衡二叉树相同。

::: tip

- 结论3 ：**有n个内部结点的红黑树的高度$h\le 2 \log_2{(n+1)}$**。

  从根到叶结点（不含叶结点）的任何一条简单路径上都至少有一半是黑结点，因此，根的黑高至少为$h/2$，于是有$n\geqslant 2^{h/2}-1$。  

  可得**红黑树查找操作的时间复杂度=$O(\log_2n)$**

:::

## 插入

红黑树的插入过程和二叉查找树的插入过程基本类似，不同之处在于，在红黑树中插入新结 点后需要进行调整（主要通过重新着色或旋转操作进行），以满足红黑树的性质。

::: tip

- 结论3：**新插入红黑树中的结点初始着为红色**

  假设新插入的结点初始着为黑色，那么这个结点所在的路径比其他路径多出一个黑结点，调整起来也比较麻烦。如果插入的结点是红色的，此时所有路径上的黑结点数量不变，仅在出现连续两个红结点时才需要调整，而且这种调整也比较简单。

:::

![](193.png)

案列：

![](192.png)

![](194.png)

![](195.png)

![](196.png)

![](197.png)

![](198.png)

![](199.png)

![](200.png)

![](201.png)

![](202.png)

![](203.png)

![](204.png)

![](205.png)

![](206.png)

![](207.png)

![](208.png)

![](209.png)

![](210.png)

![](211.png)

![](212.png)

![](213.png)

![](214.png)

![](215.png)

![](216.png)

![](217.png)



## 删除

红黑树的插入操作容易导致连续的两个红结点，破坏性质4。而删除操作容易造成子树黑高 的变化（删除黑结点会导致根结点到叶结点间的黑结点数量减少），破坏性质5。 



- **红黑树删除操作的时间复杂度为$O(\log_2n)$。**
- 红黑树中删除结点的处理方式与二叉排序树的删除一样。但红黑树中删除结点后可能破坏“红黑树特性”，此时需要调整结点颜色、位置。



# 题目

1. 对于二叉排序树，下面的说法中，（<span style="color:red;">C</span>）是正确的。

   A. 二叉排序树是动态树表，查找失败时插入新结点，会引起树的重新分裂和组合

   B. 对二叉排序树进行层序遍历可得到有序序列

   C. 用逐点插入法构造二叉排序树，若先后插入的关键字有序，二叉排序树的深度最大

   D. 在二叉排序树中进行查找，关键字的比较次数不超过结点数的1/2

   > 二叉排序树插入新结点时不会引起树的分裂组合。
   >
   > 对二叉排序树进行中序遍历可得到有序序列。
   >
   > 当插入的关键字有序时，二叉排序树会形成一个长链，此时深度最大。在此种情况下进行查找，有可能需要比较每个结点的关键字，超过总结点数的1/2。

2. 设二又排序树中关键字由1到1000的整数构成，现要查找关键字为363的结点，下述 关键字序列中，不可能是在二叉排序树上查找的序列是（<span style="color:red;">C</span>）。

   A. 2, 252, 401, 398, 330, 344, 397, 363

   B. 924, 220,911, 244, 898, 258, 362, 363

   C. 925, 202, 911, 240, 912, 245, 363

   D. 2, 399, 387, 219, 266, 382, 381, 278, 363

   > 根据二叉排序树的定义，有左子树结点值$\le$根结点值$\le$右子树结点值。C序列中，比较911关键字后，应转向其左子树比较240，左子树中不应出现比911更大的数值，但240有一个右孩子结点值为912，所以不可能是正确的序列。

3. 构造一棵具有n个结点的二叉排序树时，最理想情况下的深度为（<span style="color:red;">D</span>）。

   A. n/2	B. n	C.  $\left \lfloor \log_2{(n+1)} \right \rfloor $	D. 

   > 当二叉排序树的叶结点全部都在相邻的两层内时，深度最小。理想情况是从第一层到倒数第 二层为满二叉树。类比完全二叉树，可得深度为$\left \lceil\log_2{(n+1)}\right \rceil $。

4. 含有20个结点的平衡二叉树的最大深度为（<span style="color:red;">C</span>）。

   A. 4	B. 5	C. 6	D. 7

   > 平衡二叉树结点数的递推公式为$n_0$ = 0, $n_1$ = 1, $n_2$ = 2, $n_h=1+n_{h-1}+n_{h-2}$（h为平衡二叉树高度，$n_h$为构造此高度的平衡二叉树所需的最少结点数）。通过递推公式可得，构造5层平衡二 叉树至少需12个结点，构造6层至少需要20个结点。

5. 下列关于红黑树和AVL树的描述中，不正确的是（<span style="color:red;">C</span>）。

   A. 两者都属于自平衡的二叉树

   B. 两者查找、插入、删除的时间复杂度都相同

   C. 红黑树插入和删除过程至多有2次旋转操作

   D. 红黑树的任意一个结点的左右子树高度（含叶结点）之比不超过2

   > 自平衡的二叉排序树是指在插入和删除时能自动调整以保持其所定义的平衡性，红黑树和AVL都属于自平衡二叉树，选项A正确。
   >
   > 在红黑树中删除结点时，有些情况旋转1次会破坏了红黑树的特性，因此会出现旋转次数超过2次的情况，选项C错误。

6. 下列关于红黑树的说法中，正确的是（<span style="color:red;">B</span>）。

   A. 红黑树是一棵平衡二又树

   B, 如果红黑树的所有结点都是黑色的，那么它一定是一棵满二叉树

   C. 红黑树的任何一个分支结点都有两个非空孩子结点

   D, 红黑树的子树也一定是红黑树

   > 红黑树是一种特殊的二叉排序树，平衡二叉树的左右子树的高度差小于或等于1，红黑树显然不满足，选项A错误。
   >
   > 从根结点出发到所有叶结点的黑结点数是相同的，若所有结点都是黑色，则一定是满二叉树，选项B正确。
   >
   > 考虑某个黑结点，它可以有一个空叶结点孩子和一个非空红结点孩子，选项C错误。
   >
   > 黑树中可能存在红结点，根结点为红结点的子树不是红黑树，选项D错误。

7. 将关键字1,2, 3, 4, 5, 6, 7依次插入初始为空的红黑树T，则T中红结点的个数是（<span style="color:red;">C</span>）。 

   A. 1	B. 2	C. 3	D. 4

   > ![](218.png)

8. 将关键字5, 4, 3, 2, 1依次插入初始为空的红黑树T，则T的最终形态是（<span style="color:red;">D</span>）。

   ![](219.png)

   > ![](220.png)

9. 若将关键字1, 2, 3, 4, 5, 6, 7依次插入初始为空的平衡二叉树T，则T中平衡因子为0的分支结点的个数是（<span style="color:red;">D</span>）。

   A. 0	B. 1	C. 2	D. 3

   > ![](221.png)

10. 在任意一棵非空平衡二叉树（AVL树）$T_1$中，删除某结点v之后形成平衡二叉树$T_2$，再将v插入$T_2$形成平衡二叉树$T_3$。下列关于$T_1$与$T_3$的叙述中，正确的是（<span style="color:red;">A</span>）。

    I. 若V是$T_1$的叶结点，则$T_1$与$T_3$可能不相同

    II. 若v不是$T_1$的叶结点，则$T_1$与$T_3$一定不相同

    III. 若V不是$T_1$的叶结点，则$T_1$与$T_3$一定相同

    A.仅 I	B.仅 II	C.仅 I、II	D.仅 I、III

    > 在非空平衡二叉树中插入结点，在失去平衡调整前，一定插入在叶结点的位置。
    >
    > 若删除的是$T_1$的叶结点，则删除后平衡二叉树可能不会失去平衡，即不会发生调整，再插入此结点得到的二叉平衡树$T_1$与$T_3$相同；若删除后平衡二叉树失去平衡而发生调整，再插入结点得到的二叉平衡树$T_3$与$T_1$可能不同。说法I正确。例如，
    >
    > ![](222.png)
    >
    > 若删除的是$T_1$的非叶结点，且删除和插入操作均没有导致平衡二叉树的调整（这时可以首先想到删除的结点只有一个孩子的情况），则该结点从非叶结点变成了叶结点，$T_1$与$T_3$显然不同。 例如，
    >
    > ![](223.png)
    >
    > 若删除的是$T_1$的非叶结点，且删除和插入操作后导致了平衡二叉树的调整，则该结点有可能通过旋转后继续变成非叶结点，$T_1$与$T_3$相同。 例如，
    >
    > ![](224.png)

11. 给定平衡二叉树如下图所示，插入关键字23后，根中的关键字是（<span style="color:red;">D</span>）。

    ![](225.png)

    A. 16	B. 20	C. 23	D. 25

    > 关键字23的插入位置为25的左孩子，此时破坏了平衡的性质，需要对平衡二叉树进行调整。最小不平衡子树就是该树本身，插入位置在根结点的右子树的左子树上，因此需要进行RL旋转，RL旋转过程如下图所示，旋转完成后根结点的关键字为25，故选D。
    >
    > ![](226.png)



# B树

> [7.4_1_B树](https://www.bilibili.com/video/BV1b7411N798?p=81)

![](244.png)

## 定义

B树，又称**多路平衡查找树**，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。所谓m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。

<br>

![](227.png)

一棵m阶B树可能是空树，也可能是满足如下特性的m叉树：

1. 树中每个结点至多有m棵子树，即至多含有 m-1个关键字。

2. 若根结点不是终端结点，则至少有两棵子树。

3. **除根结点**外的所有非叶结点**至少有$\left \lceil m/2 \right \rceil$棵子树**，即**至少含有$\left \lceil m/2 \right \rceil -1$个关键字**。

4. 所有的**叶结点都出现在同一层次上**，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。

5. 所有非叶结点的结构如下：

   ![](228.png)

   - $K_i(i=1,2,\cdots,n)$为结点的关键字，且**满足 $K_1<K_2<\cdots<K_n$**；
   - $P_i(i=0,1,\cdots,n)$为指向子树根节点的指针，且指针**$P_i-1$所指子树中所有结点的关键字均小于$K_i$**，**$P_i$所指子树中所有结点的关键字均大于$K_i$**；
   - n （$\left \lceil m/2 \right \rceil \leqslant n \leqslant m-1$）为结点中关键字的个数；

::: tip

当整棵树只有1个元素时，根节点只有两个分叉，所以根结点不用保证至少有$\left \lceil m/2 \right \rceil$棵子树。

![](229.png)

:::

## 高度

一般情况下，B树的高度不包括最后的叶结点（失败节点）。

若$n\geqslant1$，则对任意一棵包含$n$个关键字、高度为$h$、阶数为$m$的B树：

- **最小高度：$h\geqslant \log_m(n+1)$**

  让每个结点尽可能的满，则$n \leqslant (m-1)(1+m+m^2+m^3+\cdots+m^{h-1})=m^h-1$，因此$h\geqslant \log_m(n+1)$。

- **最大高度：$h \leqslant (\log_{\left \lceil m/2 \right \rceil}{\frac{n+1}{2}})+1$**

  让各层的分叉尽可能少，即根节点只有2个分叉，其它结点只有$\left \lceil m/2 \right \rceil$个分叉。因此第一层1个结点；第二层至少有2个结点；第三层至少有$2\left \lceil m/2 \right \rceil$个结点；第$h$层至少有$2(\left \lceil m/2 \right \rceil)^{h-2}$个结点。第$h+1$层至少有$2(\left \lceil m/2 \right \rceil)^{h-1}$个叶子结点（失败结点）。

  因为**n个关键字的B树必有n+1个叶子结点**，则 $n+1\geqslant2(\left \lceil m/2 \right \rceil)^{h-1}$，得$h \leqslant (\log_{\left \lceil m/2 \right \rceil}{\frac{n+1}{2}})+1$。

::: tip n个关键字的B树必有n+1个叶子结点

原理跟前面折半查找的“n个圆形的非叶结点有n+1个方形的叶结点”一样，都是用关键字切割$(-\infty,+\infty)$然后得到各个区间，这个区间就是失败结点。

![](230.png)

:::

## 插入

将关键字key插入B树的过程如下：

- 定位

  找出插入该关键字的最底层中的某个非叶结点（在B树中查找key时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置）。

- 插入

  在B树中，每个非失败结点的关键字个数都在区间内。插入后的结点关键字个数小于m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1时，必须对结点进行**分裂**。 

分裂：取一个新结点，在插入key后的原结点，从中间位置（$\left \lceil m/2 \right \rceil$）将其中的关键字**分为两部分**，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（$\left \lceil m/2 \right \rceil$）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。 

::: tip

插入位置一定是“终端结点”

:::

---



以5阶B树为例，该树的结点关键字个数$2 \leqslant n\leqslant 4$。

1. 插入80

   ![](231.png)

2. 插入90

   ![](232.png)

3. 插入99

   ![](233.png)

4. 插入88

   ![](234.png)

5. 插入83，87

   ![](235.png)

6. 插入70

   ![](236.png)

7. 插入92，93，94

   ![](237.png)

8. 插入73，74，75

   ![](238.png)

   

   

## 删除

- 若被删关键字不在终端结点中时，可以用直接前驱或直接后继来替代被删除的关键字。

  直接前驱：当前关键字左侧指针所指子树中“最右下”的关键字。

  > 例如下图中80的直接前驱就是77，因此删除80只需用77顶替80即可，顶替后要记得删去终端结点的77。

  ![](240.png)

  直接后继：当前关键字右侧指针所指子树中“最左下”的关键字。

  > 例如下图中77的直接后继就是82

  ![](241.png)

  对非终端结点关键字的删除，必然可以转化成对终端结点的删除操作。

- 若被删除关键字在终端结点：

  1. **直接删除该关键字**

     若被删关键字所在结点的关键字个数$\geqslant \left \lceil m/2 \right \rceil$，则可以直接删去该关键字。

     ![](239.png)

  2. 兄弟够借

     若被删关键字所在结点删除前的关键字个数$=\left \lceil m/2 \right \rceil-1$，且与该结点相邻的右兄弟结点或左兄弟结点的关键字个数$\geqslant \left \lceil m/2 \right \rceil$，则需要调整该结点的兄弟结点或左兄弟结点及其双亲结点（父子换位法），以达到新的平衡。

     换句话说，当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺；当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺；

     ![](242.png)

     ![](243.png)

  3. 兄弟不够借

     若被删关键字所在结点删除前的关键字个数$=\left \lceil m/2 \right \rceil-1$，且此时与该结点相邻的左、右兄弟结点的关键字个数均$=\left \lceil m/2 \right \rceil-1$，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。 

     在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0，则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到$\left \lceil m/2 \right \rceil-2$，则又要与它自己的兄弟结点进行调整或合并操作。

     ---

     假设要删除49

     ![](245.png)

     右兄弟不够借，只能合并。

     ![](246.png)

     由于73所处的结点不满足B树的性质，继续合并。

     ![](247.png)

     根节点变空了，直接删除根节点。

     ![](248.png)

# B+树

一棵m阶的B+树需满足下列条件：

1. 每个分支结点最多有m棵子树（孩子结点）；

2. **非叶根结点**至少有两棵子树，其他每个**分支结点至少有$\left \lceil m/2 \right \rceil$棵子树**；

   ![](250.png)

3. **结点的子树个数与关键字个数相等**；

4. 所有**叶结点包含全部关键字**及指向相应记录的指针，叶结点中将关键字按大小顺序排列， 并且**相邻叶结点按大小顺序相互链接起来**（因此支持顺序查找）；

5. 所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针；

![](249.png)

---

m阶的B+树与m阶的B树的区别：

1. - 在B+树中，具有n个关键字的结点只含有n棵子树；
   - 在B树中，具有n个关键字的结点含有n+1棵子树；

   ---

   

2. - 在B+树中，根结点关键字个数$1\leqslant n \leqslant m$，其它结点的关键字个数$\left \lceil m/2 \right \rceil \leqslant n \leqslant m$；
   - 在B树中，根结点关键字个数$1\leqslant n \leqslant m-1$，其它结点的关键字个数$\left \lceil m/2 \right \rceil-1\leqslant n \leqslant m-1$；

   ---

3. - 在B+树中，叶结点包含全部关键字，非叶结点中出现的关键字也会出现在叶结点中；
   - 在B树中，各结点包含的关键字是不重复的；

   ---

4. - 在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只 含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
   - 在B树中，结点都包含了关键字对应记录地址的存储地址；

![](251.png)

::: tip

B+树是应数据库所需而出现的一种B树的变形树。 

在B+树中，非叶结点不含有该关键字对应记录的存储地址，可以使一个磁盘块能够包含更多个关键字，使B+树的阶更大，树更矮，读磁盘次数更少，查找更快。

:::

![](252.png)

# 题目

1. 下列关于B树和B+树的叙述中，不正确的是（<span  style="color:red">A</span>）。

   A. B树和B+树都能有效地支持顺序查找

   B. B树和B+树都能有效地支持随机查找

   C. B树和B+树都是平衡的多叉树

   D. B树和B+树都可以用于文件索引结构

   > B树和B+树的差异主要体现在：
   >
   > 1. 结点关键字和子树的个数；
   > 2. B+树非叶结点仅起索引作 用；
   > 3. B树叶结点关键字和其他结点包含的关键字是不重复的；
   > 4. B+树支持顺序查找和随机查莪，而B树仅支持随机查找；

2. 下列叙述中，不符合勿阶B树定义要求的是（<span  style="color:red">D</span>）。

   A.根结点至多有m棵子树

   B.所有叶结点都在同一层上

   C.各结点内关键字均升序或降序排列

   D.叶结点之间通过指针链接

   > m阶B树不要求将各叶结点之间用指针链接。选项D描述的实际上是B+树。

3. 已知一棵3阶B树，如下图所示。删除关键字78得到一棵新B树， 其最右叶结点中的关键字是（<span  style="color:red">D</span>）。

   ![](320.png)

   A. 60	B. 60,62	C. 62,65	D. 65

   > ![](321.png)

4.  下列应用中，适合使用B+树的是（<span  style="color:red">D</span>）。

   A.编译器中的词法分析

   B.关系数据库系统中的索引

   C.网络中的路由表快速查找

   D.操作系统的磁盘空闲块管理

   > B+树是应文件系统所需而产生的B树的变形，前者比后者更加适用于实际应用中的操作系统的文件索引和数据库索引，因为前者的磁盘读写代价更低，查询效率更加稳定。
   >
   > 编译器中的词法分析使用有穷自动机和语法树。
   >
   > 网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。
   >
   > 系统一般使用空闲空间链表管理磁盘空闲块。
   >
   > 所以选项B正确。

5. 依次将关键字5, 6, 9, 13, 8, 2, 12, 15插入初始为空的4阶B树后，根结点中包含的关键字是（<span  style="color:red">B</span>）。

   A. 8	B. 6,9	C. 8,13	D. 9,12

   > 一个4阶B树的任意非叶结点至多含有m-1 = 3个关键字，在关键字依次插入的过程中，会 导致结点的不断分裂，插入过程如下所示
   >
   > ![](322.png)

# 散列查找（哈希查找）

![](263.png)

## 散列表的基本概念

- 散列表（Hash Table）：又称**哈希表**，是一种数据结构。特点是**关键字与其存储地址直接相关**。

- 散列函数：把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。

  散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**，这些发生碰撞的不同关键字称为**同义词**。如下图所示，

  ![](253.png)

  ::: tip

  冲突总是不可避免的。

  :::



理想情况下，对散列表进行查找的时间复杂度为$O(1)$，即与表中元素的个数无关。

## 散列函数的构造方法

构造前提：

1. 散列函数的**定义域必须包含全部需要存储的关键字**，而值域的范围则依赖于散列表的大小或地址范围。 
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。 
3. 散列函数应尽量简单，能够在较短的时间内计算出任意一个关键字对应的散列地址。

<br>

**常用的散列函数**：

::: tip 设计目标

尽量降低不同关键字产生冲突的可能性

:::

1. **直接定址法**

   直接取关键字的某个线性函数值为散列地址，散列函数为$H(key)= key$或$H(key)= a\times key + b$。式中，a和b是常数。

   这种方法**不会产生冲突**，它**适合关键字的分布基本连续的情况**。若关键字分布不连续，空位较多，则会造成存储空间的浪费。

   ![](258.png)

2. **除留余数法**

   假定散列表表长为m，取一个不大于m但最接近或等于m的**质数**p，利用以下公式把关键字转换成散列地址。散列函数为$H(key)= key\%p$

   除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。

   ![](257.png)

   ::: info 质数

   质数又称[素数](https://baike.baidu.com/item/素数/115069?fromModule=lemma_inlink)，一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数；

   :::

3. **数字分析法**

   设关键字是r进制数（如十进制数），**r个数码在各位上出现的频率不一定相同**，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时**应选取数码分布较为均匀的若干位作为散列地址**。

   这种方法**适合于已知的关键字集合**，若更换了关键字，则需要重新构造新的散列函数。

   ![](259.png)

4. **平方取中法**

   取关键字的平方值的中间几位作为散列地址。

   具体取多少位要视实际情况而定。**这种方法得到的散列地址与关键字的每位都有关系**，因此使得散列地址分布比较均匀， **适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数**。 

   ![](260.png)

   

## 查找

散列表的查找过程与构造散列表的过程基本一致。

对于一个给定的关键字key，根据散列函数计算出其散列地址。检测查找表中相应地址位置上是否有记录，若无记录，返回查找失败；若有记录，与key值进行比较，相等则返回查找成功标志，不相等则返回查找失败。

**对同一组关键字，即使使用相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同**。

**散列表的查找效率的度量仍以平均查找长度作为衡量**。因为散列表在关键字与记录的存储位置之间建立了直接映像，但由于"冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。

散列表的**查找效率**取决于三个因素：**散列函数**、**处理冲突的方法**、**装填因子**。 

::: info 装填因子

散列表的装填因子一般记为$\alpha$，定义为一个表的装满程度，**$\alpha =$表中记录数$n$ / 散列表长度$m$**

**散列表的平均查找长度依赖于散列表的装填因子$\alpha$，而不直接依赖于$n$或$m$。**

$\alpha$越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。 

:::

## 处理冲突的方法

### 开放定址法

开放定址法，是指可存放新表项的**空闲地址既向它的同义词表项开放，又向它的非同义词表项开放**。其数学递推公式为
$$
H_i=(H(key)+d_i)\%m
$$
$i$为第$i$次发生冲突，$i=0,1,2,\cdots,k(k\leqslant m-1)$；$m$表示**散列表表长**；$d_i$为**增量序列**；

::: tip

如果遇到空位置还没有查找到元素，就可以确定查找失败了。

:::

::: tip

删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径。我们可以将被删结点添加一个标记，在逻辑上进行删除。

:::

---

**如何确定增量序列**：

1. **线性探测法**

   $d_i=0,1,2,3,\cdots,m-1$。冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。 

   ![](261.png)

   ![](262.png)

   线性探测法容易造成大量元素在相邻的散列地址上“**聚集**”（或堆积）起来，大大降低了查找效率。

2. **平方探测法**

   $d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$时，称为平方探测法，又称**二次探测法**，其中$k\leqslant m/2$，散列表长度m必须是一个可以表示成$4k+3$的素数。 

   平方探测法比线性探测法更不易出现"堆积”问题，但它的缺点是**不能探测到散列表上的所有单元，但至少能探测到一半单元**。

   ![](325.png)

3. **伪随机序列法**

   当$d_i$伪随机数序列时，称为伪随机序列法。

### 再散列法

又称再哈希法

当第一个散列函数$H(key)$得到的地址发生冲突时，则利用下一个散列函数计算该关键字的新地址，直到不冲突为止。此时，
$$
H_i=RH_i(key)
$$
这种方法不易产生“聚集”，但增加了计算的时间。

### 拉链法

又称链接法、链地址法。

对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。

![](254.png)

![](255.png)

由上图可知，冲突越多，查找效率越低。

![](256.png)

# 题目

1. 只能在顺序存储结构上进行的查找方法是（<span style="color:red">B</span>）。

   A. 顺序查找法 B. 折半查找法 C. 树型查找法 D. 散列查找法

   > - 顺序查找可以是顺序存储或链式存储；
   > - 折半查找只能是顺序存储且要求关键字有序；
   > - 树形查找法要求采用树的存储结构，既可以采用顺序存储也可以采用链式存储；
   > - 散列查找中的链地址法解决冲突时，采用的是顺序存储与链式存储相结合的方式；

2. 散列查找一般适用于（<span style="color:red">D</span>）的情况下的查找。

   I.若散列表的填装因子α<1，则可避免碰撞的产生

   Ⅱ.散列查找中不需要任何关键字的比较

   Ⅲ.散列表在查找成功时平均查找长度与表长有关

   IV.若在散列表中删除一个元素，不能简单地将该元素删除

   A.I和IV	B.Ⅱ和Ⅲ	C.Ⅲ	D. IV

   > - 冲突(碰撞)是不可避免的，与装填因子无关，因此需要设计处理冲突的方法，选项I错误。
   > - 散列查找的思想是计算出散列地址来进行查找，然后比较关键字以确定是否查找成功，选项II错误。
   > - 散列查找成功的平均查找长度与装填因子有关，与表长无关，选项III错误。
   > - 在开放定址的情形下，不能随便删除散列表中的某个元素，否则可能会导致搜索路径被中断(因此通常的做法是在要删除的地方做删除标记，而不是直接删除)，选项IV正确

3. 在开放定址法中散列到同一个地址而引起的“堆积”问题是由于（<span style="color:red">C</span>）引起的。

   A. 同义词之间发生冲突

   B. 非同义词之间发生冲突

   C. 同义词之间或非同义词之间发生冲突

   D. 散列表“溢出”

   > 在开放定址法中散列到同一个地址而产生的"堆积"问题，是同义词冲突的探查序列和非同义词之间不同的探查序列交织在一起，导致关键字查询需要经过较长的探测距离，降低了散列的效率。因此要选择好的处理冲突的方法来避免"堆积”。

4. 下列关于散列冲突处理方法的说法中，正确的有（<span style="color:red">A</span>）。

   I. 采用再散列法处理冲突时不易产生聚集

   II. 采用线姓探测法处理冲突时，所有同义词在散列表中一定相邻

   III. 采用链地址法处理冲突时，若限定在链首插入，则插入任意一个元素的时间相同

   IV. 采用链地址法处理冲突易引起聚集现象

   A. I 和 III	B. I、II 和 III	C. III 和 IV	D. I 和 IV

   > - 利用再散列法处理冲突时，按一定的距离，跳跃式地寻找“下一个”空闲位置，减少了发生聚集的可能，选项I正确。
   > - 散列地址i的关键字，和为解决冲突形成的某次探测地址为i的关键字, 都争夺地址因此不一定相邻，选项II错误。
   > - 选项III正确。
   > - 同义词冲突不等于聚集， 链地址法处理冲突时将同义词放在同一个链表中，不会引起聚集现象，选项IV错误。

5. 采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（<span style="color:red">D</span>）。

   A.数据元素过多	B.负载因子过大	C.散列函数选择不当	D.解决冲突的方法选择不当

   > 聚集是因选取不当的处理冲突的方法，而导致不同关键字的元素对同一散列地址进行争夺的现象。用线性再探测法时，容易引发聚集现象。

6. 在采用链地址法处理冲突所构成的散列表上查找某一关键字，则在查找成功的情况下， 所探测的这些位置上的关键字值（<span style="color:red">A</span>）；若采用线性探测法，则（<span style="color:red">B</span>）。

   A. 一定都是同义词	B.不一定都是同义词	C.都相同	D. 一定都不是同义词

   > - 在链地址法中，映射到同一地址的关键字都会链到与此地址相对应的链表上，所以探测过程一定是在此链表上进行的，从而这些位置上的关键字均为同义词；
   > - 在线性探测法中出现两个同交关键字时，会把该关键字对应地址的下一个地址也占用掉，如果对应地址的下一个地址已经被占用了，就会继续向下一个地址寻找；

7. 将10个元素散列到100000个单元的散列表中，则（<span style="color:red">C</span>）产生冲突。

   A. 一定会	B. 一定不会	C.仍可能会	D.不确定

   > 由于散列函数的选取，仍然有可能产生地址冲突，冲突不能绝对地避免。

8. 用哈希（散列）方法处理冲突（碰撞）时可能出现堆积（聚集）现象， 下列选项中，会受堆积现象直接影响的是（<span style="color:red">D</span>）。

   A.存储效率	B.散列函数	C,装填（装载）因子	D.平均查找长度

   > 产生堆积现象，即产生了冲突，它对存储效率、散列函数和装填因子均不会有影响，而平均查找长度会因为堆积现象而增大。

9. 现有长度为7、初始为空的散列表HT，散列函数H(k)=k%7，用线性探测再散列法解决冲突。将关键字22，43，15依次插入HT后，查找成功的平均查找长度是（<span style="color:red">C</span>）。

   A. 1.5	B. 1.6	C. 2	D. 3

   > ![](323.png)

10. 现有长度为11且初始为空的散列表HT，散列函数是H(key)=key%7，采用线性探查（线性探测再散列）法解决冲突。将关键字序列87, 40, 30, 6, 11, 22, 98, 20 依次插入HT后，HT查找失败的平均查找长度是（<span style="color:red">C</span>）。

    A. 4	B. 5.25	C. 6	D. 6.29

    > ![](324.png)
    >
    > 由于H(key)=0~6，查找失败时可能对应的地址有7个，对于计算出地址为0的关键字key0，只有比较完0〜8号地址后才能确定该关键字不在表中，比较次数为9；对于计算出地址为1的关键字keyl，只有比较完1〜8号地址后才能确定该关键字不在表中，比较次数为8；以此类推。 需要特别注意的是，散列函数不可能计算出地址7，因此ASL=(9 + 8 + 7 + 6 + 5 + 4 + 3)/7 = 6

11. 下列因素中，影响散列（哈希）方法平均查找长度的是（<span style="color:red">D</span>）。 

    I.装填因子	II.散列函数	III.冲突解决策略

    A.仅 I、II	B.仅 I、III	C.仅 II、III	D. I、II、III

    > 填装因子越大，说明哈希表中存储的元素越满，发生冲突的可能性就越高，导致平均查找长度越大。散列函数、冲突解决策略也会影响发生冲突的可能性。

12. 若采用链地址法构造散列表，散列函数为H(key)=key mod 17，则需（①<span style="color:red">A</span>）个链表。 这些链的链首指针构成一个指针数组，数组的下标范围为（②<span style="color:red">C</span>）。

    ①A. 17	B. 13	C. 16	D.任意

    ②A. 0 ~ 17	B. 1 ~ 17	C. 0 ~ 16	D. 1 ~ 16

    > H的取值有17种可能，对应到不同的链表中，所以链表的个数应为17。由于H(key)的取 值范围是0〜16，所以数组下标为0〜16。
