---
title: 图
index: 7
typora-root-url: ./..\..\..\..\IMG\docs\计算机\数据结构和算法
---

# 图的基本概念

## 图的定义

**图$G$** 由 **顶点集$V$** 和 **边集$E$** 组成，记为$G=(V,E)$，其中 $V(G)$ 表示图$G$中顶点的有限非空集；$E(G)$ 表示图$G$中顶点之间的关系（边）集合。

- $V=\{v_1,v_2,\cdots,v_n\}$ ，用 $\left | V \right |$ 示图 G 中**顶点的个数**，也称**图$G$的阶**
- $E=\{ (u,v)| u\in V,v\in V \}$ ，用 $\left | E \right |$ 表示图 G 中**边的条数**。

![](71.png)

::: tip

经性表可以是空表，树可以是空树，但图不可以是空图。

即图中不能一个顶点也没有，图的**顶点集$V$一定非空**，但**边集$E$可以为空**，此时图中只有顶点而没有边。

:::

## 无向图、有向图

- 无向图

  若 E 是**无向边**（简称**边**）的有限集合时，则图 G 为**无向图**。

  边是顶点的无序对，**记为 $(v, w)$ 或 $(w,v)$**，因为 $(v, w)=(w,v)$，其中$v,w$是顶点。

  可以说顶点$w$和顶点$v$互为邻接点。边$(v, w)$依附于顶点$w$和$v$，或称边$(v, w)$和顶点$v, w$相关联。

  ![](72.png)

  $G_1 = (V_1,E_1)$

  $V_1=\{ A,B,C,D,E \}$

  $E_1=\{ (A,B),(B,D),(B,E),(C,D),(C,E),(D,E) \}$

- 有向图

  若 E 是**有向边**（也称**弧**）的有限集合时，则图 G 为**有向图**。

  弧是顶点的有序对，**记为 $<v,w>$**，其中$v,w$是顶点，$v$称为**弧尾**，$w$称为**弧头**，$<v,w>$称为从顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。

  $<v,w>\ne <w,v>$

  ![](73.png)

  $G_2 = (V_2,E_2)$

  $V_2=\{ A,B,C,D,E \}$

  $E_2=\{ <A,B>,<A,C>,<A,D>,<A,E>,<B,A>,<B,C>,<B,E>,<C,D>\}$

## 简单图、多重图

- 简单图

  1. 不存在重复边；
  2. 不存在顶点到自身的边；

  ![](74.png)

- 多重图

  图 G 中某两个顶点之间的边数大于 1 条，又允许顶点通过一条边和自身关联。

  ![](75.png)

::: tip

数据结构中仅讨论简单图。

:::

## 路径、路径长度、回路、距离

- **路径**

  顶点$v_p$到顶点$v_q$之间的一条路径，是指顶点序列，$v_p,v_{i_1},v_{i_2},\cdots,v_q$。

- **路径长度**

  路径上边的数目。

- **回路**

  第一个顶点和最后一个顶点相同的路径称为**回路**或**环**。若一个图有 n 个顶点，并且有大于 n-1 条边，则此图一定有环。

  1. **图是一个环**： 当说一个图是一个环时，意味着整个图的结构是一个环。换句话说，图中的所有顶点都可以按照一定的方式连接成一个闭合的环，每个顶点都与它相邻的两个顶点相连。这种情况下，整个图可以被看作一个环的扩展，每个顶点都是环中的一个节点，每条边都是环中的一条边。
  2. **图存在一个环**： 当说一个图存在一个环时，意味着在这个图中存在一个封闭的路径，这个路径可以回到起始顶点，形成一个环。这个环可能是图中的一个子集，而不一定涵盖所有的顶点。换句话说，图中的某些顶点和边组成了一个闭合路径，形成了一个环，但是这个环不一定包括图中的所有顶点。

  ![](91.png)

  ![](92.png)

- **简单路径**

  在路径序列中，顶点不重复出现的路径称为简单路径。

- **简单回路**

  除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。

- **点到点的距离**

  从顶点$u$出发到顶点$v$的**最短路径**若存在，则此路径的长度称为从$u$到$v$的距离。若从$u$到 $v$根本不存在路径，则记该距离为无穷（$\infty$）。

## 子图

设有两个图$G = (V,E)$和$G'= (V',E')$

- 若$V'$是$V$的子集，且$E'$是$E$的子集，则称$G'$是$G$的**子图**。

- 若有满足$V(G')=V(G)$ 的子图$G'$，则称其为$G$的**生成子图**。

![](80.png)

![](81.png)

::: tip

并非$V$和$E$的任何子集都能构成$G$的子图，因为这样的子集可能不是图，即$E$的子集中的某些边关联的顶点可能不在这个$V$的子集中。

![](79.png)

:::

## 连通 、连通图 、连通分量

::: tip

在无向图中讨论连通性，在有向图中讨论强连通性。

:::

- **连通**

  在**无向图**中，若从顶点$V$到顶点$W$有路径存在，则称$V$和$W$是连通的。

- **强连通**

  在**有向图**中，如果有一对顶点$V$和$W$，从$V$到$W$和从$W$到$V$之间都有路径，则称这两个顶点是强连通的。

- **连通图**

  若图$G$中任意两个顶点都是连通的，则称图$G$为连通图，否则称为非连通图。

  ![](https://www.hello-algo.com/chapter_graph/graph.assets/connected_graph.png)

  ::: info 常见考点

  对于 n 个顶点的无向图$G$

  1. 若$G$是连通图，则**最少**有 $n-1$ 条边；

  <img src="../../../images/计算机/数据结构和算法/76.png" style="zoom: 40%;" />

  2. 若$G$是非连通图，则**最多**可能有$C_{n-1}^2$条边；

     除去一个顶点，剩下顶点两两相连

     <img src="../../../images/计算机/数据结构和算法/77.png" style="zoom: 30%;" />

  :::

- **强连通图**

  若图中任何一对顶点都是强连通的，则称此图为强连通图。

  ::: info 常见考点

  对于 n 个顶点的有向图$G$

  1. 若 G 是强连通图，则**最少**有 n 条边（形成回路）

     <img src="../../../images/计算机/数据结构和算法/78.png" style="zoom: 40%;" />

  :::

- **连通分量**

  无向图中的**极大连通子图**称为连通分量。

  ::: info 极大连通子图

  子图必须连通，且包含尽可能多的**顶点**和**边**。

  :::

  ![](82.png)

  ![](84.png)

- **强连通分量**

  有向图中的**极大强连通子图**称为有向图的强连通分量。

  ::: info 极大强连通子图

  子图必须强连通，同时保留尽可能多的**边**。

  :::

  ![](83.png)

## 生成树、生成森林

- 生成树

  **连通图**的生成树是**包含图中全部顶点的一个极小连通子图**。

  若图中顶点数为 n，则它的生成树含有 n-1 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。

  ::: info 极小连通子图

  边要尽可能少，但要保持连通

  :::

  ![](85.png)

- 生成森林

  在**非连通图**中， **连通分量的生成树**构成了非连通图的**生成森林**。

  ![](86.png)

## 顶点的度、入度和出度

- 在无向图中

  **顶点$v$的度**是指依附于顶点 v 的边的条数，记为 TD(v)。

  ::: info 性质

  对于具有 n 个顶点、e 条边的无向图，

  $$
  \sum_{i=1}^{n}TD(v_i) =2|E|=2e
  $$

  即无向图的全部顶点的度的和等于边数的 2 倍，因为每条边和两个顶点相关联。

  :::

- 在有向图中

  **入度**是以顶点$v$为终点的有向边的数目，记为 ID(v)；

  **出度**是以顶点$v$为起点的有向边的数目，记为 OD(v)；

  **顶点$v$的度**等于其入度与出度之和，即 TD(v) = ID(v) + OD(v)。

  ::: info 性质

  对于具有 n 个顶点、e 条边的有向图，

  $$
  \sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)=e
  $$

  即有向图的全部顶点的入度之和与出度之和相等，并且等于边数，这是因为每条有向边都有一个起点和终点。

  :::

## 边的权、带权图/ 网

- **边的权**

  在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的**权值**。

- **带权图/ 网**

  边上带有权值的图称为**带权图**，也称**网**。

- **带权路径长度**

  当图是带权图时，一条**路径上所有边权值之和**，称为路径的带权路径长度。

![](87.png)

## 几种特殊形态的图

### 完全图

也称**简单完全图**

- 对于无向图

  $|E|$ 的取值范围为 0 到$C_n^2=n(n-1)/2$，有$n(n-1)/2$条边的无向图称为完全图，在完全图中**任意两个顶点之间都存在边**。

- 对于有向图

  $|E|$ 的取值范围为 0 到$n(n-1)$，有而$n(n-1)$条弧的有向图称为**有向完全图**，在有向完全图中**任意两个顶点之间都存在方向相反的两条弧**。

### 稠密图、稀疏图

![](88.png)

### 树

**不存在回路**，且**连通**的无向图

n 个顶点的树，必有 n-1 条边。

![](89.png)

### 有向树

一个顶点的入度为 0，其余顶点的入度均为 1 的有向图，称为有向树。

![](90.png)

# 题目

1. 图中有关路径的定义是（<span style="color:red;">A</span>）。

   A. 由顶点和相邻顶点序偶构成的边所形成的序列

   B. 由不同顶点所形成的序列

   C. 由不同边所形成的序列

   D. 上述定义都不是

   > 图中的每个顶点代表一个对象，而边则代表对象之间的关系。相邻顶点是指通过一条边相连接的顶点。"相邻顶点序偶" 意味着对于每条边，你可以将连接的两个顶点按顺序形成一个有序对（序偶）。如果将这些有序对按照边出现的顺序排列，就构成了 "由顶点和相邻顶点序偶构成的边所形成的序列"。

2. —个有 n 个顶点和 n 条边的无向图一定是(<span style="color:red;">D</span>)。

   A.连通的 B.不连通的 C.无环的 D.有环的

   > 若一个无向图有 n 个顶点和 n-1 条边，可以使它连通但没有环（即生成树），但若再加一条边，在不考虑重边的情形下，则必然会构成环。

3. 一个有 28 条边的非连通无向图至少有（<span style="color:red;">C</span>）个顶点。

   A. 7 B. 8 C. 9 D. 10

   > 考查至少有多少个顶点的情形，我们考虑该非连通图最极端的情况，即它由一个完全图加一个独立的顶点构成，此时若再加一条边，则必然使图变成连通图。在$28 = n(n-1)/2 = 8\times 7/2$条边的完全无向图中，总共有 8 个顶点，再加上 1 个不连通的顶点，共 9 个顶点。

4. 对于一个有 n 个顶点的图：若是连通无向图，其边的个数至少为（）；若是强连通有向图，其边的个数至少为（<span style="color:red;">A</span>）。

   A. n-1，n B. n-1，n(n- 1) C. n，n D. n，n(n -1)

5. 无向图 G 有 23 条边，度为 4 的顶点有 5 个，度为 3 的顶点有 4 个，其余都是度为 2 的顶点，则图 G 有（<span style="color:red;">D</span>）个顶点。

   A. 11 B. 12 C. 15 D. 16

   > 由于在具有 n 个顶点、e 条边的无向图中，有$\sum_{i=1}^n TD(v)=2e$，故可求得度为 2 的顶点数为 7，从而共有 16 个顶点。

6. 在有 n 个顶点的有向图中，顶点的度最大可达（<span style="color:red;">D</span>）。

   A. n B. n - 1 C. 2n D. 2n-2

   > 在有向图中，顶点的度等于入度与出度之和。n 个顶点的有向图中，任意一个顶点最多还可以与其他 n-1 个顶点有一对指向相反的边相连。注意数据结构中仅讨论简单图。

7. 具有 6 个顶点的无向图，当有（<span style="color:red;">D</span>）条边时能确保是一个连通图。

   A. 8 B. 9 C. 10 D. 11

   > 5 个顶点构成一个完全无向图，需要$n(n-1)/2 = 10$条边；再加上 1 条边后，能保证第 6 个顶点必然与此完全无向图构成一个连通图，故共需 11 条边。

8. 若具有 n 个顶点的图是一个环，则它有（<span style="color:red;">B</span>）棵生成树。

   A. $n^2$ B. n C. n-1 D. 1

   > n 个顶点的生成树是具有 n-1 条边的极小连通子图，因为 n 个顶点构成的环共有 n 条边，去掉任意一条边就是一棵生成树，所以共有 n 种情况，所以可以有 n 棵不同的生成树。

9. 若一个具有 n 个顶点、e 条边的无向图是一个森林，则该森林中必有（<span style="color:red;">C</span>）棵树。

   A. n B. e C. n—e D. 1

   > n 个结点的树有 n-1 条边，假设森林中有 x 棵树，则再用 x-1 条边就能把所有的树连接成一棵树，此时，边数+1 = 顶点数，即 e + (x-1)+1=n，故 x=n-e。

10. 已知无向图 G 含有 16 条边，其中度为 4 的顶点个数为 3，度为 3 的顶点个数为 4，其他顶点的度均小于 3。图 G 所含的顶点个数至少是（<span style="color:red;">B</span>）。

A. 10 B. 11 C. 13 D. 15

> 无向图边数的 2 倍等于各顶点度数的总和。为求至少的顶点数，应使每个顶点的度取最大，由于其他顶点的度均小于 3，可以设它们的度都为 2，设它们的数量是 X，列出方程$4\times 3 + 3\times4 + 2x = 16\times2$，解得 x = 4。因此至少包含 4 + 4 + 3=11 个顶点。

11. 对于无向图$G=(V,E)$，下列选项中，正确的是（<span style="color:red;">D</span>）。

    A. 当$|V|>|E|$时，G—定是连通的

    B. 当$|V|<|E|$时，G—定是连通的

    C. 当$|V|=|E|-1$时，G 一定是不连通的

    D. 当$|V|>|E|+1$时，G —定是不连通的

    > 注意，$|V|$是图的顶点数，$|E|$是图的边数。
    >
    > - 仅当 $|E|\ge (|V|-1)(|V|-2)/2 +1$ 时（此时$|V|-1$个顶点构成一个完全图，若再加入一条边，则一定变成连通图），图才一定是连通的。
    > - 当$|E|>|V|$时， 图有可能是连通的，也可能是不连通的，选项 B 错误。
    > - 当$|E|<|V|$时，仅当$|E| = |V|-1$时，图才可能是连通的（此时图是生成树），选项 A 错误。
    > - 当$|E| = |V|+1$时，图有可能是连通的，也可能是不连通的，选项 C 错误。
    > - 当$|E|<|V|-1$时，图一定是不连通的，选项 D 正确。

# 图的存储

## 邻接矩阵法

所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。

结点数为$n$的图$G=(V,E)$的邻接矩阵$A$是$n\times n$的。将$G$的顶点编号为约$v_1,v_2,\cdots,v_n$。若$(v_i,v_j)\in E$，则$A[i][j]=1$，否则$A[i][j]=0$。

![](93.png)

```cpp
#define MaxVertexNum 100 // 顶点数目的最大值

typedef struct {
    char Vex[MaxVertexNum]; // 顶点表
    int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵，边表
    int vexnum, arcnum; // 图的当前顶点数和边数/弧数
} MGraph; 
```

对于带权图而言，若顶点$V_i$和$V_j$之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点$V_i$和$V_j$不相连，则通常用$\infty$来代表这两个顶点之间不存在边。

![](94.png)

```cpp
#include <climits>

#define MaxVertexNum 100 // 顶点数目最大值
#define INFINITY INT_MAX // 无穷

typedef struct {
    char Vex[MaxVertexNum]; // 顶点表
    int Edge[MaxVertexNum][MaxVertexNum]; // 边的权
    int vexnum, arcnum; // 图的当前顶点数和边数/弧数
} MGraph;
```



::: tip

1. 在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。 
2. 当邻接矩阵的元素仅表示相应边是否存在时，EdgeType可采用 `bool` 类型。 

:::

---



**特点**：

1. 无向图的邻接矩阵一定是一个对称矩阵(并且唯一)。因此，在实际存储邻接矩阵时只需存储上(或下)三角矩阵的元素。

2. 稠密图适合使用邻接矩阵的存储表示。 

3. 邻接矩阵表示法的**空间复杂度为$O(n^2)$**，其中n为图的顶点数$|V|$，只和顶点数相关，和实际边数无关。

4. 邻接矩阵求顶点的度/出度/入度的**时间复杂度为$O(|V|)$**

   - 对于无向图，

     第 $i$ 个结点的度 = 第 $i$ 行(或第 $i$ 列)的非零元素的个数。

   - 对于有向图，
     - 第 $i$ 个结点的出度 = 第 $i$ 行的非零元素的个数。
     - 第 $i$ 个结点的入度 = 第 $i$ 列的非零元素的个数。
     - 第 $i$ 个结点的度 = 第 $i$ 行、第 $i$ 列的非零元素的个数。

   用邻接矩阵存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。

5. 设图$G$的邻接矩阵为$A$，$A^n$的元素$A^n[i][j]$等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。

## 邻接表法

顺序+链式存储

邻接表，是指对图$G$中的每个顶点$v$，建立一个单链表，第$i$个单链表中的结点表示依附于顶点$v$，的边（对于有向图则是以顶点$v_i$为尾的弧），这个单链表就称为顶点$v_i$的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。

![](95.png)

```cpp
#define MaxVertexNum 100

// 边/弧
typedef struct ArcNode {
    int adjvex;// 边/弧指向哪个结点
    struct ArcNode *next;// 指向下一条弧的指针
    // int info;// 可以储存边的权值
} ArcNode;

// 顶点
typedef struct VNode {
    int data;/ / 顶点信息
    ArcNode *first;// 第一条边/弧
} VNode, AdjList[MaxVertexNum];

// 用邻接表存储的图
typedef struct {
    char Vex[MaxVertexNum]; // 顶点表
    int Edge[MaxVertexNum][MaxVertexNum]; // 边的权
    int vexnum, arcnum; // 图的当前顶点数和边数/弧数
} ALGraph;
```

**特点：**

1. - 若G为无向图，则所需的存储空间为$O(|V|+2|E|)$；
   - 若G为有向图，则所需的存储空间为$O(|V|+|E|)$；

   前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。 

2. 对于稀疏图，采用邻接表表示将极大地节省存储空间。 

3. 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。 在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为$O(n)$。

4. 要确定给定的两个顶点间是否存在边，在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。 

5. 在有向图的邻接表表示中， 求一个给定顶点的出度只需计算其邻接表中的结点个数；但求其顶点的入度则需要遍历全部的邻接表。

6. **图的邻接表表示并不唯一**，因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。

   ![](96.png)

## 十字链表

::: tip

只适用于存储有向图

:::

十字链表是**有向图的一种链式存储结构**。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。

![](98.png)

空间复杂度：$O(|V|+|E|)$

- 找到指定顶点的所有出边：顺着绿色线路找
- 找到指定顶点的所有入边：顺着橙色线路找

## 邻接多重表

::: tip

只适用于存储无向图

:::

在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。 

 邻接多重表是**无向图的另一种链式存储结构**。 

![](99.png)

空间复杂度：$O(|V|+|E|)$

和十字链表相比较，

![](100.png)

## 四种存储方式的区别

![](101.png)

# 图的基本操作

图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。

- `Adjacent(G , x , y)`：判断图 G 是否存在边<x,y>或(x,y)。
- `Neighbors(G , x)`：列出图 G 中与结点x邻接的边。
- `Insertvertex(G , x)`：在图 G 中插入顶点 x。 
- `DeleteVertex(G , x)`：从图 G 中删除顶点 x。
- `AddEdge(G , x , y)`：若无向边(x,y)或有向边<x,y>不存在，则向图 G 中添加该边。
- `RemoveEdge(G , x , y)`：若无向边(x,y)或有向边<x,y>存在，则从图G中删除该边。
- **`FirstNeighbor(G , x)`**：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- **`NextNeighbor(G , x , y)`**：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
- `Get_edge_value(G , x , y)`：获取图 G 中边(x,y)或<x,y>对应的权值。
- `Set_edge_value(G , x , y , v)`：设置图G中边(x,y)或<x,y>对应的权值为V。

# 题目

1. 在含有n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为（<span style="color:red;">D</span>）。

   A. e	B. 2e	C. $n^2-e$	D. $n^2-2e$

   > 无向图的邻接矩阵中，矩阵大小为$n^2$，非零元素的个数为2e，故零元素的个数为$n^2-2e$。

2. 带权有向图G用邻接矩阵存储，则$V_i$的入度等于邻接矩阵中（<span style="color:red;">D</span>）。

   A,第$i$行非8的元素个数	B.第$i$列非$\infty$的元素个数	C.第$i$行非$\infty$且非0的元素个数	D.第$i$列非$\infty$且非0的元素个数

   > 带权有向图的邻接矩阵中，0和$\infty$表示的都不是有向边，而入度是由邻接矩阵的列中元素计 算出来的；出度是由邻接矩阵的行中元素计算出来的。

3. 在有向图的邻接表存储结构中，顶点V在边表中出现的次数是（<span style="color:red;">C</span>）。

   A. 顶点v的度	B. 顶点v的出度	C. 顶点v的入度	D. 依附于顶点v的边数

   > 题中的边表是不包括顶点表的。因为任何顶点$u$对应的边表中存放的都是以$u$为起点的边所对应的另一个顶点V。从而$v$在边表中出现的次数也就是它的入度。

4. n个顶点的无向图的邻接表最多有（<span style="color:red;">B</span>）个边表结点。

   A. $n^2$	B. n(n-1)	C. n(n+1)	D. n(n-1)/2

   > n个顶点的无向图最多有n(n-1)/2条边，每条边在邻接表中存储两次，所以边表结点最多为n(n-1)个。

5. 对邻接表的叙述中，（<span style="color:red;">D</span>）是正确的。

   A. 无向图的邻接表中，第i个顶点的度为第i个链表中结点数的两倍

   B. 邻接表比邻接矩阵的操作更简便

   C. 邻接矩阵比邻接表的操作更简便

   D. 求有向图结点的度，必须遍历整个邻接表

   > 无向图的邻接表中，第i个顶点的度为第i个链表中的结点数，故选项A错。
   >
   > 
   >
   > 邻接表和邻接矩阵对于不同的操作各有优势，选项B和C都不准确。
   >
   > 有向图结点的度包括出度和入度，对于出度，需要遍历顶点表结点所对应的边表；对于入度，则需要遍历剩下的全部边表，故选项D正确。

# 图的遍历

图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。

树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。

图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。 

---



## 广度优先遍历(BFS)

> [6.3_1_图的广度优先遍历](https://www.bilibili.com/video/BV1b7411N798/?p=60)

::: info 

Breadth-First-Search，BFS

:::

![](109.png)

### 定义

类似于二叉树的**层序遍历**算法。

基本思想是：首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点$w_1,w_2,\cdots,w_i$，然后依次访问$w_1,w_2,\cdots,w_i$的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。

![](102.png)

### 遍历序列

- 同一个图的邻接矩阵存储表示是唯一的，因此广度优先遍历序列唯一。
- 同一个图的邻接表存储表示不唯一，因此广度优先遍历序列不唯一。

<img src="../../../images/计算机/数据结构和算法/103.png" style="zoom:67%;" />

### 实现

要点：

1. 找到与一个顶点相邻的所有顶点
2. 标记哪些顶点被访问过
3. 需要一个辅助队列

```cpp
#define MaxVertexNum 100

bool visited[MaxVertexNum];// 访问标记数组，初始值为false

void BFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G
  visit(v); //访问初始顶点v
  visited[v] = true; // 标记为已访问
  Enqueue(Q, v); // 顶点v入队列Q
  while (!isEmpty(Q)) {
    DeQueue(Q, v);// 顶点v出列
    for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
      // 检测v所有邻接点
      if (!visited[w]) {// w为v尚未访问的邻接顶点
        visit(w);// 访问顶点w
        visited[w] = true;
        EnQueue(Q, w);// 顶点w入队列
      }
    }
  }
}
```

如果是非连通图，只执行一次遍历是无法遍历完所有结点的

<img src="../../../images/计算机/数据结构和算法/104.png" style="zoom:67%;" />

如需解决这个问题，只需遍历一遍访问标记数组，找到仍为false的顶点，继续执行BFS就行

```cpp
#define MaxVertexNum 100

bool visited[MaxVertexNum];// 访问标记数组，初始值为false

void BFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G
  visit(v); //访问初始顶点v
  visited[v] = true; // 标记为已访问
  Enqueue(Q, v); // 顶点v入队列Q
  while (!isEmpty(Q)) {
    DeQueue(Q, v);// 顶点v出列
    for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
      // 检测v所有邻接点
      if (!visited[w]) {// w为v尚未访问的邻接顶点
        visit(w);// 访问顶点w
        visited[w] = true;
        EnQueue(Q, w);// 顶点w入队列
      }
    }
  }
}

void BFSTraverse(Graph G) {// 对图G进行广度优先遍历
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false;// 访问标记数组初始化
  }
  InitQueue(Q);// 初始化辅助队列Q
  for (int i = 1; i < G.vexnum; i++) {// 遍历
    if (!visited[i]) {
      BFS(G, i);// i结点未访问过，从i开始执行BFS
    }
  }
}
```

### 复杂度

- 空间复杂度

  无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q。最坏的情况是$n$个顶点均需入队一次，空间复杂度为$O(n)$ 。

  <img src="../../../images/计算机/数据结构和算法/105.png" style="zoom: 80%;" />

- 时间复杂度

  1. 邻接矩阵：

     访问$|V|$个顶点需要$O(|V|)$的时间；查找每个顶点的邻接点都需要$O(|V|)$的时间，总共有$|V|$个顶点；

     **时间复杂度 = $O(|V|^2)$**

  2. 邻接表：

     访问$|V|$个顶点需要$O(|V|)$的时间；查找每个顶点的邻接点都需要$O(|E|)$的时间；

     **时间复杂度 = $O(|V|+ |E|)$**

---



### 广度优先生成树和生成森林

广度优先生成树由广度遍历的过程确定的。

同一个图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。

![](106.png)

![](107.png)

对**非连通图**或者只执行一次BFS无法遍历全部结点的图进行广度优先遍历，可得到广度优先生成森林。相关内容可查看[图的连通性](#图的连通性)。

![](108.png)

---



## 深度优先遍历(DFS)

> [6.3_2_图的深度优先遍历](https://www.bilibili.com/video/BV1b7411N798/?p=61)

::: info 

Depth-First-Search，DFS

:::

![](114.png)

### 定义

类似于树的**先序遍历**。

基本思想如下：首先访问图中某一起始顶点$v$，然后由$v$出发，访问与$v$邻接且未被访问的任意一个顶点$w_1$，再访问与$w_1$邻接且未被访问的任意一个顶点$w_2$，重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。 

![](110.png)

### 遍历序列

图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一 的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。

### 实现

```cpp
#define MaxVertexNum 100

bool visited[MaxVertexNum];// 访问标记数组，初始值为false

void DFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G
  visit(v); //访问初始顶点v
  visited[v] = true; // 标记为已访问
  for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
    if (!visited[w]) {// w为v尚未访问的邻接顶点
      DFS(G, w);
    }
  }
}
```

与广度优先遍历一样，如果是非连通图，只执行一次遍历是无法遍历完所有结点的

```cpp
#define MaxVertexNum 100

bool visited[MaxVertexNum];// 访问标记数组，初始值为false

void DFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G
  visit(v); //访问初始顶点v
  visited[v] = true; // 标记为已访问
  for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
    if (!visited[w]) {// w为v尚未访问的邻接顶点
      DFS(G, w);
    }
  }
}

void DFSTraverse(Graph G) {// 对图G进行深度优先遍历
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false;// 访问标记数组初始化
  }
  for (int i = 0; i < G.vexnum; i++) {
    if (!visited[i]) {
      DFS(G, i);
    }
  }
}
```

### 复杂度

- 空间复杂度

  ![](111.png)

- 时间复杂度

  时间复杂度 = 访问各结点所需的时间 + 探索各边所需的时间

  - 邻接矩阵：

    访问$|V|$个顶点需要$O(|V|)$的时间；查找每个顶点的邻接点都需要$O(|V|)$的时间，总共有$|V|$个顶点；

    **时间复杂度 = $O(|V|^2)$**

  - 邻接表：

    访问$|V|$个顶点需要$O(|V|)$的时间；查找每个顶点的邻接点都需要$O(|E|)$的时间；

    **时间复杂度 = $O(|V|+ |E|)$**

  ::: tip

  时间复杂度与广度优先遍历序列的时间复杂度一样

  :::

  ---
  
  

### 深度优先的生成树和生成森林

与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。

与广度优先遍历类似，对只执行一次DFS无法遍历全部结点的图进行深度优先搜索，那生成的就是深度优先生成森林。相关内容可查看[图的连通性](#图的连通性)。

::: tip

- 同一个图的邻接矩阵表示方式唯一，因此深度优先遍历序列唯一，深度优先生成树也唯一
- 同一个图的邻接表表示方式不唯一，因此深度优先遍历序列不唯一，深度优先生成树也不唯一

:::

---



## 图的连通性

- 对于**无向图**进行BFS/DFS遍历，**调用BFS/DFS函数的次数 = 连通分量数**。

  1. 若该无向图是**连通图，只需调用1次**BFS/DFS。

- 对于**有向图**进行BFS/DFS遍历，调用BFS/DFS函数的次数需要具体分析

  1. 若起始顶点到其它各顶点都有路径，则只需调用1次BFS/DFS；

     ![](112.png)

     > 如图，若从7顶点开始遍历，遍历一次就可以遍历完全部结点；若从2结点开始遍历就需要遍历多次。

  2. 若该有向图是强连通图，从任一节点出发只需调用1次BFS/DFS；

     ![](113.png)

# 题目

1. 下列关于广度优先算法的说法中，正确的是（<span style="color:red">A</span>）。 

   I. 当各边的权值相等时，广度优先算法可以解决单源最短路径问题

   II. 当各边的权值不等时，广度优先算法可用来解决单源最短路径问题

   III. 广度优先遍历算法类似于树中的后序遍历算法

   IV. 实现图的广度优先算法时，使用的数据结构是队列

   A. L IV	B. II、III、IV	C. II、IV	D. I、III, IV

   > 广度优先搜索以起始结点为中心，一层一层地向外层扩展遍历图的顶点，因此无法考虑到边权值，只适合求边权值相等的图的单源最短路径。

2. 判断有向图中是否存在回路，除可以利用拓扑排序外，还可以利用（<span style="color:red">C</span>）。 

   A.求关键路径的方法	B.求最短路径的Dijkstra算法	C.深度优先遍历算法	D.广度优先遍历算法

   > 利用深度优先遍历可以判断图$G$中是否存在回路。
   >
   > - 对于无向图来说，若深度优先遍历过程中遇到了回边，则必定存在环；
   > - 对于有向图来说，这条回边可能是指向深度优先森林中另一棵生成树上的顶点的弧；但是，从有向图的某个顶点$v$出发进行深度优先遍历时，若在$DFS(v)$结束之前出现一条从顶点$u$到顶点$v$的回边，且$u$在生成树上是$v$的子孙，则有向图必定存在包含顶点$v$和顶点$u$的环。

3. 图的广度优先生成树的树高比深度优先生成树的树高（<span style="color:red">A</span>）。 

   A.小或相等	B.小	C.大或相等	D.大

   > 对于无向图的广度优先搜索生成树，起点到其他顶点的路径是图中对应的最短路径，即所有生成树中树高最小。此外，深度优先总是尽可能"深”地搜索图，因此其路径也尽可能长，故深度优先生成树的树高总是大于或等于广度优先生成树的树高。



# 最小生成树（最小代价树）

> [6.4_1_最小生成树](https://www.bilibili.com/video/BV1b7411N798/?p=62)

## 定义

对于一个**带权连通无向图** $G = (V, E)$，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设 $R$ 为 $G$ 的所有生成树的集合，若 $T$ 为 $R$ 中**边的权值之和最小的那棵生成树**， 则 $T$ 称为 $G$ 的**最小生成树**（Minimum-Spanning-Tree，MST）。

## 性质

1. 当图 $G$ 中的各边权值互不相等时，$G$ 的最小生成树是唯一的。
2. 若无向连通图 $G$ 的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。  
3. 最小生成树可能有多个，但边的权值之和总是唯一且最小的；
4. 最小生成树的边数 = 顶点数 - 1。

## 构造最小生成树

构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G = (V, E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集。若 $(u,v)$ 是一条具有最小权值的边，其中 $u\in U,v\in V-U$，则必存在一棵包含边 $(u,v)$ 的最小生成树。 

基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。

### Prim 算法

普里姆算法

从某一顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，知道所有顶点都纳入为止。

**时间复杂度：$O(|V|^2)$**，适合边稠密图

> 以P城为起点构建生成树

![](115.png)

![](116.png)

### Kruskal 算法

克鲁斯卡尔算法

每次选择一条权值最小的边，使这条边的两头连通（如果原本已经连通就跳过）；直到所有结点都连通。

**时间复杂度：$O(|E|\log_2|E|)$**，适合边稀疏图

![](117.png)

# 最短路径

![](118.png)

![](135.png)

---



## BFS算法求解单源最短路径问题

::: tip

BFS算法求解单源最短路径只适用于**无权图**，或**所有边权值都相同的图**。

:::

若图$G=(V,E)$为**非带权图**，定义从顶点$u$到顶点$v$的最短路径$d(u, v)$为从$u$到$v$的任何路径中最少的边数；若从$u$到$v$没有通路，则$d(u,v)=\infty$。

使用BFS求解一个满足上述定义的非带权图的单源最短路径问题，这是由**广度优先搜索总是按照距离由近到远来遍历图中每个顶点**的性质决定的。

```cpp
void BFS_MIN_Distance(Graph G, int u) {
  int d[G.vexnum]; //d[i]表呆从u到i结点的最短路径
  int path[G.vexnum]; // 最短路径从哪个顶点过来
  for (int i = 0; i < G.vexnum; ++i) {
    d[i] = INT_MAX; // 初始化路径长度
    path[G.vexnum] = -1;
  }
  visited[u] = true;
  d[u] = 0;
  Enqueue(Q, u); // 顶点v入队列Q
  while (!isEmpty(Q)) {
    DeQueue(Q, u);
    for (int w = FirstNeighbor(G, u); w >= 0; w = NextNeighbor(G, u, w)) {
      if (!visited[w]) {// w为v尚未访问的邻接顶点
        visited[w] = true;
        d[w] = d[u] + 1;// 路径长度加1
        path[w] = u; // 最短路径应从u到w
        EnQueue(Q, w);// 顶点w入队列
      }
    }
  }
}
```

![](119.png)

---



## Dijkstra算法求单源最短路径问题

> [6.4_3_最短路径问题\_Dijkstra算法](https://www.bilibili.com/video/BV1b7411N798/?p=64)
>
> [【算法】最短路径查找—Dijkstra算法](https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.337.search-card.all.click&vd_source=18ba17bb87b1c219c021b5fd3be34461)

::: tip

Dijkstra算法**不适用于带有负权值的带权图**。

:::

![](120.png)

Dijkstra算法设置一个集合 $S$ 记录己求得的最短路径的顶点，初始时把源点 $v_0$ 放入 $S$，集合 $S$ 每并入一个新顶点 $v_i$，都要修改源点 $V_0$ 到集合 $V-S$ 中顶点当前的最短路径长度。

Dijkstra算法也是基于贪心策略。

---



- `dist[]`：

  记录从源点 $v_0$ 到其他各顶点当前的最短路径长度，它的初态为：若从 $v_0$ 到 $v_i$ 有弧，则`dist[i]`为弧上的权值；否则置为 $\infty$。 

- `path[]`： 

  `path[i]`表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $v_0$ 到顶点 $v_i$ 的最短路径。

---



**时间复杂度：**

- 使用邻接矩阵表示时，时间复杂度为 $O(|V|^2)$
- 使用带权的邻接表表示时，虽然修改`dist[]`的时间可以减少，但由于在`dist[]`中选择最小分量的时间不变，时间复杂度仍为 $O(|V|^2)$

---



![](121.png)

![](122.png)

![](123.png)

![](124.png)

![](125.png)

![](126.png)

**实现**

```cpp
#include <climits>

// 从顶点v出发的最短路径
void Dijkstra(Graph G, int v) {
  // 标记各顶点是否为已找到的最短路径
  bool final[G.vexnum];
  // 最短路径长度
  int dist[G.vexnum];
  // 路径上的前驱
  int path[G.vexnum];
  // 辅助数组初始化
  for (int i = 0; i < G.vexnum; i++) {
    final[i] = false;
    dist[i] = INT_MAX;
    path[i] = -1;
  }
  // 初始化顶点v，将该出发点加入到最短路径，出发点到出发点的最短距离为0
  final[v] = true;
  dist[v] = 0;
  // 更新顶点v的邻接顶点的dist和path信息
  for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
    int edgeVal = Get_edge_value(G, v, w);
    dist[w] = edgeVal;
    path[w] = v;
  }
  // 主循环，由于出发结点v的final已经修改为true，因此执行G.vexnum - 1次即可
  for (int i = 0; i < G.vexnum - 1; i++) {
    // 寻找距离出发点最小的结点，即dist值最小的结点
    int minNodeDist = INT_MAX, minNodeIndex = -1;
    for (int j = 0; j < G.vexnum; j++) {
      if (!final[j] && dist[j] < minNodeDist) {
        minNodeIndex = j;
        minNodeDist = dist[j];
      }
    }
    // 将该结点标记为最短路径
    final[minNodeIndex] = true;
    // 遍历该结点的邻接结点，更新邻接结点的dist和path值
    for (int w = FirstNeighbor(G, minNodeIndex); w >= 0; w = NextNeighbor(G, minNodeIndex, w)) {
      // 计算从出发点到w的dist值
      int newDist = Get_edge_value(G, minNodeIndex, w) + dist[minNodeIndex];
      // 如果该新dist值小于w原来的dist值，则证明新的路径更加短
      if (newDist < dist[w]) {
        dist[w] = newDist;
        path[w] = minNodeIndex;
      }
    }
  }
}
```

---



## Floyd算法求各顶点之间最短路径问题

> [6.4_4_最短路径问题\_Floyd算法](https://www.bilibili.com/video/BV1b7411N798/?p=65)

如果要求出每一对顶点之间的最短路径，我们可以每次以一个顶点为源点，重复执行Dijkstra算法n次。时间复杂度为$O(n^3)$。但相比于Floyd算法会更麻烦。

![](127.png)

Floyd算法的基本思想是：递推产生一个n阶方阵序列 $A^{(-1)},A^{(0)},\cdots,A^{(k)},A^{(n-1)}$，其中 $A^{(k)}[i][j]$ 表示从顶点$v_i$到顶点$v_j$的路径长度，$k$ 表示绕行第 $k$ 个顶点的运算步骤。初始时，对于任意两个 顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以 $\infty$ 作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k(k=0,1,\cdots,n-1)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。

Floyd算法的**时间复杂度为$O(|V|^3)$**。不过由于其代码很紧凑，且并不包含其他复杂的数据结 构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。

Floyd算法的**空间复杂度为$O(|V|^2)$**。

Floyd算法**允许图中有带负权值的边**，但**不允许有包含带负权值的边组成的回路**。

![](134.png)

---

定义一个$n$阶方阵序列$A^{(-1)},A^{(0)},\cdots,A^{(k)},A^{(n-1)}$，其中
$$
A^{(-1)}[i][j] = arcs[i][j]\\
A^{(k)}[i][j]=Min\{ A^{(k-1)}[i][j],A^{(k-1)}[i][k]+A^{(k-1)}[k][j] \} ,k(k=0,1,\cdots,n-1)
$$

> $A^{(1)}[i][j]$是从顶点$v_i$到$v_j$的中间顶点的序号不大于1的最短路径的长度；
>
> $A^{(k)}[i][j]$是从顶点$v_i$到$v_j$的中间顶点的序号不大于k的最短路径的长度；
>
> $A^{(n-1)}[i][j]$是从顶点$v_i$到$v_j$的最短路径的长度；

::: info 

1. $A^{(-1)}$的矩阵就是图的邻接矩阵表示。
2. 此时加入顶点$v_0$，将顶点$v_i$到$v_j$的距离与$v_i$到$v_0$+$v_0$到$v_j$的距离和相比较，修改$A$矩阵。此时$A$矩阵的`A[i][j]`的值就是$v_i$到$v_j$的最短路径。
3. 此时加入顶点$v_1$。注意现在的`A[i][j]`的值不管是否经过$v_0$都是最短路径，但这只是包含$v_0$情况下的最短路径，现在新加入了$v_1$则需要重新计算。将顶点$v_i$到$v_j$的距离与$v_i$到$v_1$+$v_1$到$v_j$的距离和相比较，修改$A$矩阵。此时$A$矩阵的`A[i][j]`的值就是$v_i$到$v_j$的最短路径。
4. 加入顶点$v_2$，……
5. 重复加入顶点，

:::

![](128.png)

![](129.png)

![](130.png)

![](131.png)



![](132.png)

若图的顶点不止3个，求路径如下：

![](133.png)

 

**实现**

```cpp
// 以 Vk 做为中转点
  for (int k = 0; k < n; k++) {
    // 遍历整个矩阵，i为行号，j为列号
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        // 以Vk为中转点的路径更短
        if (A[i][j] > A[i][k] + A[k][j]) {
          // 更新最短路径长度
          A[i][j] = A[i][k] + A[k][j];
          // 更新中转点
          path[i][j] = k;
        }
      }
    }
  }
```

# 有向无环图

有向无环图：若一个有向图中不存在环，则称为有向无环图，简称**DAG图**。 

![](136.png)

有向无环图**是描述含有公共子式的表达式的有效工具**。

例如表达式：$((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)$

删除重复出现的子树，只保留一颗。这样可以节省存储空间。

![](137.png)

![](138.png)

![](139.png)

![](140.png)

::: tip 解题技巧

> [6.4_5_有向无环图描述表达式](https://www.bilibili.com/video/BV1b7411N798?t=203.7&p=66)

![](141.png) 

![](142.png)

:::

# 拓扑排序

![](145.png)

A0V网（Activity On Vertex Network，用顶点表示的网）：若用DAG图表示一个工程，其顶点表示活动，用有向边$<v_i,v_j>$表示活动$v_i$必须优先于活动$v_j$进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为A0V网。

![](143.png)

拓扑排序：在图论中，由一个**有向无环图的顶点组成的序列**，当且仅当满足下列条件时，称为该图的一个拓扑排序： 

1. 每个顶点出现且只出现一次。 
2. 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。

每个AOV网都有**一个或多个**拓扑排序序列。 

![](144.png)

拓扑排序的实现：

1. 从AOV网中选择一个没有前驱的顶点并输出。
2. 从网中删除该顶点和所有以它为起点的有向边。
3. 重复①和②直到当前的**AOV网为空**或**当前网中不存在无前驱的顶点**为止。后一种情况说明有向图中必然存在环。 

时间复杂度：

- 采用邻接表存储：$O(|V|+|E|)$
- 采用邻接矩阵存储：$O(|V|^2)$

![](146.png)

```cpp
#define MaxVertexNum 100 // 图中最大顶点数目
typedef struct ArcNode {
    int adjvex;// 该弧指向的顶点的位置
    struct ArcNode *nextArc;// 指向下一条边的指针
} ArcNode;

typedef struct VNode {// 顶点表结点
    int data;// 顶点信息
    ArcNode *firstArc;// 指向第一条依附该顶点的弧的指针
} VNode, AdjList[MaxVertexNum];

typedef struct {
    AdjList vertices;// 邻接表
    int vexnum, arcnum;// 图的顶点数和弧数
} Graph;

bool TopologicalSort(Graph G) {
  InitStack(S);// 初始化栈
  int i;
  for (i = 0; i < G.vexnum; i++) {
    if (indegre[i] == 0) {
      Push(S, i);// 将所有入度为0的顶点进栈
    }
  }
  int count = 0;// 记录当前已经输出的顶点数
  while (!IsEmpty(S)) {// 栈不空，则存在入度为0的顶点
    Pop(S, i);// 栈顶元素出栈
    print[count++] = i;// 输出顶点i
    for (ArcNode *p = G.vertices[i].firstArc; p != nullptr; p = p->nextArc) {
      // 将所有i指向的顶点的入度减1，并将入度减为0的顶点压入栈S
      int v = p->adjvex;
      if (!(--indegree[v])) {
        Push(S, v);// 入度为0，则入栈
      }
    }
  }
  if (count < G.vexnum) {
    return false;// 排序失败，有向图中有回路
  } else {
    return true;// 拓扑排序成功
  }
}
```



---



对一个AOV网，如果采用下列步骤进行排序，则称之为**逆拓扑排序**:

1. 从AOV网中选择一个没有后继（出度为0）的顶点并输出；
2. 从网中删除该顶点和所有以它为终点的有向边；
3. 重复①和②直到当前的AOV网为空；

![](147.png)

用DFS算法实现逆拓扑排序：

```cpp
void DFS(Graph G, int v) {// 从顶点v出发，广度优先遍历图G
  visited[v] = true; // 标记为已访问
  for (int w = FirstNeighbor(G, v); w >= 0; w = NextNeighbor(G, v, w)) {
    if (!visited[w]) {// w为v尚未访问的邻接顶点
      DFS(G, w);
    }
  }
  print(v); // 输出顶点
}

void DFSTraverse(Graph G) {// 对图G进行深度优先遍历
  for (int i = 0; i < G.vexnum; i++) {
    visited[i] = false;// 访问标记数组初始化
  }
  for (int i = 0; i < G.vexnum; i++) {
    if (!visited[i]) {
      DFS(G, i);
    }
  }
}
```

# 关键路径

![](155.png)

在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销**（如完成活动所需的时间），称之为用边表示活动的网络，简称AOE网（Activity On Edge NetWork）。

在AOE网中，**有些活动是可以并行进行的**。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都己完成，整个工程才能算结束。

![](148.png)

::: tip

AOE网和AOV网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE网中的边有权值；而 AOV网中的边无权值，仅表示顶点之间的前后关系。

:::

AOE网具有以下两个性质： 

1. 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；
2. 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。

---

![](149.png)

在AOE网中

- 仅有一个入度为0的顶点，称为**开始顶点（源点）**，它表示整个工程的开始；
- 仅有一个出度为0的顶点，称为**结束顶点（汇点）**，它表示整个工程的结束；

从源点到汇点的所有路径中

- **关键路径**：具有最大路径长度的路径
- **关键活动**：关键路径上的活动

完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。因为关键活动影响了整个工程的时间。若关键活动不能按时完成，则整个工程的完成时间就会延长。若关键活动的时间减少，则整个工程的完成时间就会缩短。当缩短到一定程度时，关键活动可能会变成非关键活动。

---

- 事件$v_k$的最早发生时间$ve(k)$

  指从源点$v_1$到顶点处的最长路径长度。

  ![](150.png)

  ---

  

- 活动$a_i$的最早开始时间$e(i)$

  指该活动弧的起点所表示的事件的最早发生时间。

  ![](152.png)

  ---

  

- 事件$v_k$的最迟发生时间$vl(k)$

  指在不推迟整个工程完成的前提下，即保证它的后继事件$v_j$在其最迟发生时间$vl(k)$能够发生时，该事件最迟必须发生的时间。  

  ![](151.png)

  ---

  

- 活动$a_i$的最迟开始时间$l(i)$

  指该活动弧的终点所表示事件的最迟发生时间与该活动所需时间之差。

  ![](153.png)

  ---

  

- 活动$a_i$的最迟开始时间$l(i)$和其最早开始时间$e(i)$的差额$d(i)=l(i)-e(i)$

  指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动$a_i$可以拖延的时间。

  ![](154.png)

  ---

  



# 题目

1. 用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树（<span style="color:red">C</span>）。 

   A.相同	B.不相同	C.可能相同，可能不同	D.无法比较

   > 当无向连通图存在权值相同的多条边时，最小生成树可能是不唯一的；另外，由于这是一个无向连通图，故最小生成树必定存在，从而选A。

2. 以下叙述中，正确的是（<span style="color:red">A</span>）。 

   A. 只要无向连通图中没有权值相同的边，则其最小生成树唯一

   B. 只要无向图中有权值相同的边，则其最小生成树一定不唯一

   C. 从n个顶点的连通图中选取n-1条权值最小的边，即可构成最小生成树

   D. 设连通图G含有n个顶点，则含有n个顶点、n-1条边的子图一定是G的生成树

   > 选项A显然正确，最小生成树算法是基于贪心策略的，每次总是选取权值最小且满足条件的边，如果各边权值不同，则每次选择的新顶点也是唯一的，因此最小生成树唯一。
   >
   > 选项B，若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。
   >
   > 选项C，选取的n-1条边可能构成回路。
   >
   > 选项D，含有n个顶点、n-1条边的子图可能构成回路，也可能不连通。

3. 以下叙述中，正确的是（<span style="color:red">A</span>）。 

   A.最短路径一定是简单路径

   B. Dijkstra算法不适合求有回路的带权图的最短路径

   C. Dijkstra算法不适合求任意两个顶点的最短路径

   D. Floyd算法求两个顶点的最短路径时，$path_{k-1}$一定是$path_k$的子集

   > Dijkstra算法适合求解有回路的带权图的最短路径，也可以求任意两个顶点的最短路径，不适合求带负权值的最短路径问题。
   >
   > 在用Floyd算法求两个顶点的最短路径时，当最短路径发生更改时，$path_{k-1}$就不是$path_k$的子集。

4. 下面的（<span style="color:red">A</span>）方法可以判断出一个有向图是否有环（回路）。

   I.深度优先遍历	II.拓扑排序	III.求最短路径	IV.求关键路径

   A. I、II、IV	B. I. IIL IV	C. I、II、III	D.全部可以

   > - 使用深度优先遍历，若从有向图上的某个顶点u出发，在DFS(m)结束之前出现一条从顶点v到u的边，由于v在生成树上是u的子孙，则图中必定存在包含u和v的环，因此深度优先遍历可以检测一个有向图是否有环。
   >
   > - 拓扑排序时，当某顶点不为任何边的头时才能加入序列，存在环时环中的顶点一直是某条边的头，不能加入拓扑序列。也就是说，还存在无法找到下一个可以加入拓扑 序列的顶点，则说明此图存在回路。
   >
   > - 求最短路径是允许图有环的。至于关键路径能否判断一个图有环，则存在一些争议。
   > - 关键路径本身虽然不允许有环，但求关键路径的算法本身无法判断是否有环, 判断是否有环是求关键路径的第一步一一拓扑排序。所以这个问题的答案主要取决于你从哪个角度出发看问题，考生需要理解问题本身，真正统考时是不会涉及一些模棱两可的问题的。

5. 以下关于拓扑排序的说法中，错误的是（<span style="color:red">D</span>）。

   I. 若某有向图存在环路，则该有向图一定不存在拓扑排序

   II. 在拓扑排序算法中为暂存入度为零的顶点，可以使用栈，也可以使用队列

   III. 若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1

   A. I、III	B. Il、Ill	C. II	D. III

   > - I中，对于一个存在环路的有向图，使用拓扑排序算法运行后，肯定会出现有环的子图，在此环中无法再找到入度为0的结点，拓扑排序也就进行不下去。
   >
   > - II中，注意，若两个结点之间不存在祖先或子孙关系，则它们在拓扑序列中的关系是任意的（即前后关系任意），因此使用栈和队列都可以，因为进栈或队列的都是入度为0的结点，此时入度为0的所有结点是没有关系的。 
   >
   > - III是难点，若拓扑有序序列唯一，则很自然地让人联想到一个线性的有向图（错误），下图的拓扑序列也是唯一的，但度却不满足条件。
   >
   >   ![](162.png)

6. 若一个有向图的顶点不能排成一个拓扑序列，则判定该有向图（<span style="color:red">D</span>）。

   A.含有多个出度为0的顶点	B,是个强连通图	C.含有多个入度为0的顶点	D.含有顶点数大于1的强连通分量

   > 一个有向图中的顶点不能排成一个拓扑序列，表明其中存在一个顶点数目大于1的回路（环）， 该回路构成一个强连通分量，从而答案选D。

7. 若一个有向图具有有序的拓扑排序序列，则它的邻接矩阵必定为（<span style="color:red">C</span>）。 

   A.对称	B.稀疏	C.三角	D. 一般

   > 此题一直以来争议较大，因为有些书中漏掉了 “有序”二字。可以证明，对有向图中的顶点适当地编号，使其邻接矩阵为三角矩阵且主对角元全为零的充分必要条件是，该有向图可以进行拓扑排序。若这个题目把“有序"二字去掉，显然应该选D。但此题题干中已经指出是“有序的 拓扑序列”，因此应该选C。需要注意的是，若一个有向图的邻接矩阵为三角矩阵（对角线以上或 以下的元素为0），则图中必不存在环，因此其拓扑序列必然存在。

8. 若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是（<span style="color:red">C</span>）。 

   A.存在，且唯一	B.存在，且不唯一	C.存在，可能不唯一	D.无法确定是否存在

   > 对角线以下的元素均为零，表明只有从顶点$i$到顶点$j(i<j)$可能有边，而从顶点$j$到顶点$i$一定无边，即有向图是一个无环图，因此一定存在拓扑序列。
   >
   > 对于拓扑序列是否唯一，举例：设有向图的邻接矩阵为
   > $$
   > \begin{bmatrix}
   >  0 & 1 & 1\\
   >  0 &  0& 0\\
   >  0 & 0 &0
   > \end{bmatrix}
   > $$
   > 则存在两个拓扑序列，因此该图存在可能不唯一的拓扑序列。

9. 下列关于图的说法中，正确的是（<span style="color:red">C</span>）。 

   I. 有向图中顶点V的度等于其邻接矩阵中第V行中1的个数

   II. 无向图的邻接矩阵一定是对称矩阵，有向图的邻接矩阵一定是非对称矩阵

   III. 在带权图G的最小生成树$G_1$中，某条边的权值可能会超过未选边的权值

   IV. 若有向无环图的拓扑序列唯一，则可以唯一确定该图

   A. I、II、III	B. III、IV	C. lll	D. IV

   > - 有向图邻接矩阵的第V行中1的个数是顶点V的出度，而有向图中顶点的度为入度与出度之和，I错。
   >
   > - 无向图的邻接矩阵一定是对称矩阵，但当有向图中任意两个顶点之间有边相连，且是 两条方向相反的有向边时，有向图的邻接矩阵也是一个对称矩阵，II错。
   >
   > - 最小生成树中的n-1条边并不能保证是图中权值最小的1条边，因为权值最小的n-1条边并不一定能使图连通。在下图中，左图的最小生成树如下图所示，权值为3的边并不在其最小生成树中。
   >
   >   ![](163.png)
   >
   > - 有向无环图的拓扑序列唯一并不能唯一确定该图。在下图所示的两个有向无环图中，拓扑序列都为$V_1,V_2,V_3,V_4$，IV错。注意，很多辅导书对该命题的判断是错误的。
   >
   >   ![](164.png)

10. 下面关于求关键路径的说法中，不正确的是（<span style="color:red">C</span>）。 

    A. 求关键路径是以拓扑排序为基础的

    B. 一个事件的最早发生时间与以该事件为始的弧的活动的最早开始时间相同

    C. 一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差

    D.关键活动一定位于关键路径上

    > 一个事件的最迟发生时间 = min｛以该事件为尾的弧的活动的最迟开始时间｝，或min｛以该事件为尾的弧所指事件的最迟发生时间与该弧的活动的持续时间之差｝。

11. 下列关于关键路径的说法中，正确的是（<span style="color:red">C</span>）。 

    I. 改变网上某一关键路径上的任意一个关键活动后，必将产生不同的关键路径

    II. 在AOE图中，关键路径上活动的时间延长多少，整个工程的时间也就随之延长多少

    III. 缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度

    IV. 缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度

    V. 缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度

    A. II 和 V	B. I、II 和 IV	C. II 和 IV	D. I 和 IV

    > 若改变的是所有关键路径上的公共活动，则不一定会产生不同的关键路径（延长必然不会导致，只有缩短才有可能导致）。根据关键路径的定义，可知选项II正确。关键路径是源点到终点的最长路径，只有所有关键路径的长度都缩短时，整个图的关键路径才能有效缩短，但也不能任意缩短，一旦缩短到一定程度，该关键活动就可能会变成非关键活动。

12. 下列关于最小生成树的叙述中，正确的是（<span style="color:red">A</span>）。

    I. 最小生成树的代价唯一

    II. 所有权值最小的边一定会出现在所有的最小生成树中

    III. 使用Prim算法从不同顶点开始得到的最小生成树一定相同

    IV. 使用Prim算法和Kruskal算法得到的最小生成树总不相同

    A,仅 I	B.仅 II	C.仅 I、III	D.仅 II、IV

    > 最小生成树的树形可能不唯一（因为可能存在权值相同的边），但代价一定是唯一的，选项I 正确。
    >
    > 若权值最小的边有多条并且构成环状，则总有权值最小的边将不出现在某棵最小生成树中， 选项II错误。
    >
    > 设N个结点构成环，N-1条边权值相等，另一条边权值较小，则从不同的顶点开始Prim算法会得到N-1种不同的最小生成树，选项III错误。当最小生成树唯一时（各边的权值不同），Prim算法和Kruskal算法得到的最小生成树相同，选项IV错误。

13. 下列AOE网表示一项包含8个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是（<span style="color:red">C</span>）。 

    ![](165.png)

    A. c 和 e	B. d 和 c	C. f 和 d	D. f 和 h

    > 找出AOE网的全部关键路径为bdcg、bdeh和bfh。根据定义，只有关键路径上的活动时间同时减少时，才能缩短工期。选项A、B和D并不包含在所有的关键路径中，只有C包含，因此只有加快f和d的进度才能缩短工期。

14. 用有向无环图描述表达式(x + y)((x + y)/x)，需要的顶点个数至少是（<span style="color:red">A</span>）。 

    A. 5	B. 6	C. 8	D. 9

    > ![](166.png)

15. 下图是一个有10个活动的AOE网，时间余量最大的活动是（<span style="color:red">B</span>）。 

    ![](167.png)

    A. c	B.g	C. h	D.j

    > 活动的时间余量=结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的持续时间。
    >
    > ![](168.png)
    >
    > - $c$ 的时间余量=$vl(3)-ve(2)-l =5-2-1 =2$
    > - $g$ 的时间余量=$vl(6)-ve(3)-1 = 12-5-1 =6$
    > - $h$ 的时间余量=$vl(5)-ve(4)-l = 11-8-1 =2$
    > - $j$ 的时间余量=$vl(6)-ve(5)- 1 = 12-9-1 =2$
    >
    > 时间余量最大的活动是g。

    

    

    

    
