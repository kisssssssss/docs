---
title: 内存管理
index: 3
typora-root-url: ./..\..\..\..\IMG\docs\计算机\操作系统
---

# 内存

![](202.png)

## 什么是内存

![](200.png)

![](201.png)

## 程序的链接与装入

创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需 要以下几个步骤：

1. **编译**：由编译程序将用户源代码编译成若干目标模块。
2. **链接**：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。
3. **装入**：由装入程序将装入模块装入内存运行。

![](209.png)

链接的三种方式：

1. **静态链接**

   在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不 再拆开。

   ![](210.png)

2. **装入时动态链接**

   将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。

   优点：便于修改和更新，便于实现对目标模块的共享。

   ![](211.png)

3. **运行时动态链接**

   对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。凡在执行过程中未被 用到的目标模块，都不会被调入内存和被链接到装入模块上。

   优点：加快程序的装入过程，还可节省大量的内存空间。

   ![](212.png)

装入的三种方式：

1. **绝对装入**

   绝对装入方式**只适用于单道程序环境**。

   在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。

   由于程序中的逻辑地址与实际内存地址完全相同，因此不需对程序和数据的地址进行修改。

   ![](206.png)

2. **可重定位装入**

   根据内存的当前情况，将装入模块装入内存的适当位置。

   在装入时对目标程序中**指令和数据地址的修改过程称为重定位**，又因为**地址变换通常是在进程装入时一次完成的，故称为静态重定位**。

   当一个作业装入内存时，**必须给它分配要求的全部内存空间**，若没有足够的内存，则无法装 入。作业一旦进入内存，**整个运行期间就不能在内存中移动**，也不能再申请内存空间。

   ![](207.png)

3. **动态运行时装入**

   程序在内存中若发生移动，则需要采用动态的装入方式。

   装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。

   这种方式需要一个**重定位寄存器**的支持，

   优点：可以将程序分配到不连续的存储区；在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享。

   ![](208.png)

## 逻辑地址与物理地址

![](203.png)

![](204.png)

![](205.png)

## 进程的内存映像

不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。

一个进程的内存映像一般有几个要素：

- 代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。
- 数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。
- 进程控制块（PCB）：存放在系统区。操作系统通过 PCB 来控制和管理进程。
- 堆：用来存放动态分配的变量。通过调用 malloc 函数动态地向高地址分配空间。
- 栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。

代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。

## 内存保护

确保每个进程都有一个单独的内存空间。

内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。

内存保护可采取两种方法：

1. 在 CPU 中**设置一对上、下限寄存器**，存放用户作业在主存中的下限和上限地址。每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。

2. 采用**重定位寄存器**（又称基地址寄存器）和**界地址寄存器**（又称限长寄存器）来实现这种保护。

   重定位寄存器存放进程的起始物理地址，界地址寄存器存放进程的最大逻辑地址。

   内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。

   ![](213.png)

   加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个存储器。

   这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。

## 内存共享

并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。

可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。

在实际执行时，可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区。这样，程序在执行时只需对该私有数据区中的内存进行修改，并不去改变共享的代码。

# 内存管理

内存管理（MemoryManagement）是操作系统设计中最重要和最复杂的内容之一。

操作系统对内存的划分和动态分配，就是内存管理的概念。

内存管理的**主要功能**有：

1. 内存空间的分配与回收

   由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。

2. 地址转换

   在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。

3. 内存空间的扩充

   利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。

4. 内存共享

   指允许多个进程访问内存的同一部分。例如，多个合作进程可能需要访问同一块数据，因此必须支持对内存共享区域进行受控访问。

5. 存储保护

   保证各道作业在各自的存储空间内运行，互不干扰。

# 覆盖与交换

![](216.png)

覆盖与交换技术是在多道程序环境下**用来扩充内存**的两种方法。

交换技术主要在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。

对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史，而交换技术在现代操作系统中仍具有较强的生命力。

## 覆盖

覆盖技术，用来**解决程序大小超过物理内存总和的问题**。

基本思想：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成**一个固定区**和**若干覆盖区**。将经常活跃的部分放在固定区， 不常用的部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。

![](214.png)

覆盖技术打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。

内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。

缺点的是必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了编程的负担。

## 交换

交换（对换）的基本思想是，把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序暂时从内存移到外存，把内存空间腾出来，这一过程又称**换出**；把准备好竞争 CPU 运行的程序从外存移到内存，这一过程又称**换入**。

暂时换出外存等待的进程状态称为**挂起状态**。挂起状态又可以细分为**就绪挂起**、**阻塞挂起**两种状态。

有关交换，需要注意以下几个问题：

- 交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。
- 为了有效使用 CPU,需要使每个进程的执行时间比交换时间长。
- 若换出进程，则必须确保该进程完全处于空闲状态。
- 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。
- 交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。
- 普通的交换使用不多，但交换策略的某些变体在许多系统（如 UNIX）中仍发挥作用。

![](215.png)

# 内存分配与回收

存储管理方式随着操作系统的发展而发展。

在操作系统由单道向多道发展时，存储管理方式由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式—页式存储管理。

## 连续分配管理方式

![](225.png)

**连续分配**方式是指为一个用户程序分配一个连续的内存空间。

连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。

### 单一连续分配

内存在此方式下分为**系统区**和**用户区**。

- 系统区仅供操作系统使用，通常在低地址部分；
- 在用户区内存中，**仅有一道用户程序**，即整个内存的用户空间由该程序独占。

优点：实现简单、**无外部碎片**，无须进行内存保护，因为内存中永远只有一道程序。

缺点：只能用于单用户、单任务的操作系统中，**有内部碎片**，存储器的利用率极低。

::: info 内部碎片

内部碎片是指分配给某进程的内存区域中，如果有些部分没有用上，那么这部分就是“内部碎片”。

:::

### 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式，它**将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业**。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。

在划分分区时有两种不同的方法：

1. 分区大小相等

   程序太小会造成浪费，程序太大又无法装入，缺乏灵活性，但适用于用一台计算机控制多个相同对象的场合。

2. 分区大小不等

   增加了灵活性。可以划分为多个较小的分区、适量的中等分区和少量大分区。

![](217.png)

为了便于分配，建立一张**分区使用表**，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态(是否己分配)。

![](218.png)

分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为"已分配”；若找不到这样的分区，则拒绝分配。回收内存时，只需将对应表项的状态置为“未分配”即可。

优点：实现简单，**无外部碎片**。

缺点：

1. 程序可能太大而放不进任何一个分区，可以采用覆盖技术来解决，但这样又会降低性能；
2. 会**产生内部碎片**，内存利用率低。

### 动态分区分配

又称**可变分区分配**。这种分配方式**不会预先划分内存分区**，它是在进程装入内存时，**根据进程的大小，动态地建立分区**， 并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。

---

系统中需要相应的数据结构，用以描述空闲分区和已分配分区的情况。

常用的数据结构有：

1. **空闲分区表**

   ![](219.png)

2. **空闲分区链**

   ![](220.png)

---

把一个新作业装入内存时，必须按照一定的**动态分区分配算法**，从空闲分区表或空闲分区链中选出一个分区分配给该作业。

---

**分配内存时**，检索空闲分区链，找到所需的分区，若其大小大于请求大小，便从该分区中按请求大小分割一块空间分配给装入进程（若剩余部分小到不足以划分，则无须分割），余下部分仍留在空闲分区链中。

**回收内存时**，系统根据回收分区的始址，从空闲分区链中找到相应的插入点，此时可能出现四种情况：

- 回收区与插入点的前一空闲分区相邻，将这两个分区合并，并修改前一分区表项的大小为两者之和；

  > 例：回收进程 4
  >
  > ![](221.png)

- 回收区与插入点的后一空闲分区相邻，将这两个分区合并，并修改后一分区表项的始址和大小；

  > 例：回收进程 3
  >
  > ![](222.png)

- 回收区同时与插入点的前、后两个分区相邻，此时将这三个分区合并，修改前一分区表项的大小为三者之和，取消后二分区表项；

  > 例：回收进程 4
  >
  > ![](223.png)

- 回收区没有相邻的空闲分区，此时应为回收区新建一个表项，填写始址和大小，并插入空闲分区链。

  > 例：回收进程 3
  >
  > ![](224.png)

---

动态分区分配没有内部碎片，但是有外部碎片。

内部碎片：分配给某进程的内存区域中，有些部分没有使用；

外部碎片：内存中的某些空闲分区太小难以利用。

克服外部碎片可以通过**紧凑技术**来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于 Windows 系统中的磁盘碎片整理程序，只不过后者是对外存空间的紧凑。

### 动态分区分配算法

1. **首次适应**（First Fit, FF）算法

   空闲分区**以地址递增的次序**链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。

   最简单，通常也是最好和最快的。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此增加了查找开销。

2. **邻近适应**（Next Fit, NF）算法

   又称**循环首次适应算法**，由首次适应算法演变而成。不同之 处是，分配内存时**从上次查找结束的位置开始继续查找**。

   但它常常导致在内存空间的尾部（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配）分裂成小碎片。通常比首次适应算法要差。

3. **最佳适应**（Best Fit, BF）算法

   空闲分区**按容量递增的次序**形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业。

   虽然称为"最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，**会产生最多的外部碎片**。

4. **最坏适应**（Worst Fit, WF）算法

   空闲分区**以容量递减的次序**链接，找到第一个能满足要求的， 即最大的分区，从中分割一部分存储空间给作业。

   每次都选择最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用。但会很快导致没有可用的大内存块，因此性能也非常差。

![](226.png)

## 非连续分配管理方式

### 基本分页存储管理

#### 分页存储的基本概念

![](236.png)

进程中的块称为页或**页面**，内存中的块称为**页框**或页帧。外存也以同样的单位进行划分，直接称为块或盘块。

**进程在执行时**需要申请主存空间，即要**为每个页面分配主存中的可用页框**，这就产生了页和页框的一一对应。

为方便地址转换，**页面大小应是 2 的整数倍**。

::: info

页面大小刚好是2的整数幂的好处：

计算机硬件可以很快速的把一个逻辑地址拆分成对应的**页号**和**页内偏移量**，而无需进行除法运算，从而提升了运行速度。

然后根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。

:::

当然页面大小也应该适中，因为

- 页面太小会使进程的页面数过多，造成页表过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；
- 页面过大又会使页内碎片增多，降低内存的利用率；

![](227.png)

![](231.png)

![](232.png)

---

分页存储管理的逻辑地址结构包含两部分：前一部分为**页号**，后一部分为**页内偏移量**，即**页内地址**。

在下图所示的例子中，地址长度为 32 位， 其中

- 0〜11 位为页内地址，即每页大小为 4KB；
- 12〜31 位为页号，即最多允许$2^{20}$页。

![](228.png)

![](235.png)

---

为了便于在内存中找到进程的每个页面所对应的物理块，系统为**每个进程**建立一张**页表**，它记录页面在内存中对应的物理块号，**页表一般存放在内存中**。

在配置页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，**页表的作用是实现从页号到物理块号的地址映射**。

![](229.png)

页表是由**页表项**组成的。

**每个页表项的长度是相同的，页号是“隐含”的**（因为页表项连续存放，不占存储空问题间，类似于数组）。

::: tip 页表项与地址结构比较

页表项与地址都由两部分构成，而且第一部分都是页号，但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；

页表项的第二部分与地址的第二部分共同组成物理地址。

:::

![ ](../../../images/计算机/操作系统/230.png)

![ ](../../../images/计算机/操作系统/238.png)

---

#### 基本地址变换机构

![](237.png)

**基本地址变换机构**可以**借助进程的页表将逻辑地址转换为物理地址**。

通常会在系统中设置一个**页表寄存器**（PTR），存放页表在内存中的起始地址 F 和页表长度 M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

::: tip

注意：页面大小是 2 的整数幂

:::

![](233.png)

设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：

1. 计算页号 P 和页内偏移量 W

   如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量。

2. 比较页号 P 和页表长度 M，若 P$\geqslant$M，则产生越界中断，否则继续执行。

   ::: tip

   页号是从 0 开始的，而页表长度至少是 1，因此 P=M 时也会越界

   :::

3. 页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度，取出该页表项内容 b，即为内存块号。

4. 计算 E=b*L+W，用得到的物理地址E去访存。

   如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了

::: tip 页表项长度、页表长度、页面大小的区别

- 页表长度：这个页表中总共有几个页表项，即总共有几个页；
- 页表项长度：每个页表项占多大的存储空间；
- 页面大小：一个页面占多大的存储空间；

::: 

![](234.png)

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。

因此，**页式管理中地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

####  具有快表的地址变换机构

由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：

- 第一次是访问页表，确定所存取的数据或指令的物理地址；
- 第二次是根据该地址存取数据或指令。

显然，这种方法比通常执行指令的速度慢了一半。 为此，在地址变换机构中增设一个具有并行查找能力的高速缓冲存储器一一**快表**。

**快表**，又称**联想寄存器**（**TLB**，translation lookaside buffer），是一种访问速度比内存快很多的**高速缓存**，用来**存放最近访问的页表项的副本**，可以**加速地址变换的速度**。

与此对应，内存中的页表常称为慢表。

::: tip

TLB不是内存。

TLB和普通Cache的区别：TLB中只有页表项的副本，而普通Cache中可能会有其他各种数据的副本。

![](239.png)

:::

::: info

快表是专门的硬件，当进程切换的时候，快表的内容需要被清除。

:::

在具有快表的分页机制中，地址的变换过程如下： 

1. CPU给出逻辑地址，由硬件进行地址转换，得到页号、页内偏移量，将页号与快表中的所有页号进行比较。

2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。

   因此，**若快表命中，则访问某个逻辑地址仅需一次访存即可**。

3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。

   因此，**若快表未命中，则访问某个逻辑地址需要两次访存**

   ::: tip

   在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

   :::

![](240.png)

::: info

有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。

:::

![](241.png)

::: info

局部性原理：

- **时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。

  因为程序中存在大量的循环。

- **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。

  因为很多数据在内存中都是连续存放的。

:::

在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。这就是为什么具有快表的地址变换机构能大幅提高系统效能的原因。

![](242.png)

#### 两级页表 

![](248.png)

![](243.png)

单级页表的问题：

1. 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。
2. 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

为了解决单级页表的问题一，可将页表进行分组，使每个内存块刚好可以放入一个分组。另外，要为离散分配的页表再建立一张页表，称为**页目录表**，或称**外层页表**，或称**顶层页表**。

![](244.png)

二级页表如何实现地址变换：

1. 按照地址结构将逻辑地址拆分成三部分
2. 从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
3. 根据二级页号查表，找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址

![](245.png)

为了解决单级页表的问题二，可以在需要访问页面时才把页面调入内存。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。

![](246.png)

::: tip

1. 若采用多级页表机制，则**各级页表的大小不能超过一个页面**。

   ![](247.png)

2. 两级页表的**访存次数**分析（假设没有快表机构）

   - 第一次访存：访问内存中的页目录表
   - 第二次访存：访问内存中的二级页表
   - 第三次访存：访问目标内存单元

:::

### 基本分段存储管理

![](256.png)

#### 分段

段式管理方式按照用户进程中的自然段划分逻辑空间。

例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，**每段从0开始编址**，并分配一段连续的地址空间。 

内存分配规则：段内要求连续，段间不要求连续。

![](249.png)

分段系统的**逻辑地址结构**由**段号**（**段名**）和**段内地址**（**段内偏移量**）所组成。

段号的位数决定了每个进程最多可以分几个段。段内地址位数决定了每个段的最大长度是多少。

![](250.png)

#### 段表

每个进程都有一张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。

配置段表后，执行中的进程可通过查找段表，找到每段所对应的内存区。

![](251.png)

#### 地址变换

![](252.png)

#### 分段、分页管理的对比

- 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。

  段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。

- 分段对用户是可见的，用户编程时需要显式地给出段名。页的大小固定且由系统决定。

  段的长度却不固定，决定于用户编写的程序。

- 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。

  分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

  ![](253.png)

- 分段比分页更容易实现信息的共享和保护。

  不能被修改的代码称为纯代码或 可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)。

  ![](254.png)

  ![](255.png)

::: info

访问一个逻辑地址需要几次访存？

- 分页（单级页表）：

  - 第一次访存：查内存中的页表
  - 第二次访存：访问目标内存单元

  总共两次访存。

- 分段：

  - 第一次访存：查内存中的段表
  - 第二次访存：访问目标内存单元。

  总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。

:::

### 段页式存储管理 

![](261.png)

#### 分页、分段的优缺点

|          | 优点                                                         | 缺点                                                         |
| :------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高，**不会产生外部碎片**，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                       | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理**会产生外部碎片** |

#### 段页式管理

![](257.png)

在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量

- **段号的位数**决定了每个进程最多可以分几个
- **段页号位数**决定了每个段最大有多少
- **页页内偏移量**决定了页面大小、内存块大小是多少

![](258.png)

为了实现地址变换，系统为每个进程建立一张段表，每个分段有一张页表。

段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。

此外，系统中还应有一个段表寄存器，指出作业的段表始址和段表长度（段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界）。

![](259.png)

::: tip

在一个进程中，段表只有一个，而页表可能有多个。

:::

#### 地址变换

![](260.png)

# 虚拟内存

## 基本概念

![](264.png)

### 传统存储管理方式的特征

![](262.png)

传统存储管理方式的特征、缺点：

- **一次性**：作业必须一次性全部装入内存后才能开始运行。

  这会造成两个问题：

  1. 作业很大时，不能全部装入内存，导致大作业无法运行；
  2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。

- **驻留性**：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。

  事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

### 局部性原理

局部性原理表现在以下两个方面：

1. **时间局部性**

   程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。

2. **空间局部性**

   一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。 

### 虚拟存储器的定义

基于局部性原理，在程序装入时，仅须**将程序当前要运行的少数页面或段先装入内存，而将 其余部分暂留在外存**，就可以让程序开始执行。

在程序执行过程中，当所访问的信息不在内存时，由**操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

若内存空间不够，**操作系统将内存中暂时不使用的内容换出到外存上**，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为**虚拟存储器**。 

 ::: info

之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户透明），给用户的感觉是好像存在一个比实际物理内存大 得多的存储器。但容量大只是一种错觉，是虚的。

:::

### 虚拟存储器的特征

虚拟存储器有以下三个主要特征：

1. **多次性**

   是指**无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行**，即只需将当前要运行的那部分程序和数据装入内存即可开始运行。以后每当要运行到尚未调入的那部分程序时，再将它调入。

   多次性是**虚拟存储器最重要的特征**。

2. **对换性**

   是指**无须在作业运行时一直常驻内存**，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存 （换进）。正是由于对换性，才使得虚拟存储器得以正常运行。 

3. **虚拟性**

   是指**从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量**。这是虚拟存储器所表现出的最重要特征，也是实现虚拟存储器的最重要目标。

### 虚拟内存技术的实现

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。

![](263.png)

## 请求分页管理方式

![](268.png)

为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算 机系统，还需要有页表机制、缺页中断机构和地址变换机构。

### 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要**知道每个页面是否已经调入内存**；如果还没调入，那么也需要**知道该页面在外存中存放的位置**。

当内存空间不够时，要实现“页面置换”，操作系统需要**通过某些指标来决定到底换出哪个页面**；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要**记录各个页面是否被修改的信息**。

![](265.png)

### 缺页中断机构

在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系 统将所缺的页调入内存。

此时应将缺页的进程阻塞（调页完成唤醒），

- 若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项。
- 若内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。 

缺页中断作为中断，同样要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程 序、恢复CPU环境等几个步骤。

::: tip

- 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。
- 一条指令在执行期间，可能产生多次缺页中断。（如将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面并且都没有调入内存，则有可能产生两次中断)

:::

### 地址变换机构

![](266.png)

![](267.png)

::: info

补充：

- 修改访问位和修改位

  只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。

- 启动I/O硬件

  换入/换出页面都需要启动慢速的I/O操作，如果换入/换出太频繁，会有很大的开销。

- 修改页表

  页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。

:::

## 页面置换算法

页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该**追求更少的缺页率**。

![](276.png)

### 最佳置换算法(OPT)

> OPTimal replacement

最佳置换算法选择的**被淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面**，以便保证获得最低的缺页率。

![](269.png)

::: tip

**缺页时未必发生页面置换，若还有可用的空闲内存块就不用进行页面置换。**

:::

最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

### 先进先出置换算法(FIFO)

> First Input First Output

**优先淘汰最早进入内存的页面**，即淘汰在内存中驻留时间最久的页面。

该算法实现简单，只需把已调入内存的页面根据先后次序链接成队列，设置一个指针总是指向最老的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 

![](270.png)

![](271.png)

**只有FIFO算法会产生Belady异常**。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差。

::: info

**Belady异常**：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

:::

### 最近最久未使用置换算法(LRU)

> Least recently used

每次**淘汰的页面是最近最久未使用的页面**。

赋予每个页面对应的页表项中，用**访问字段记录该页面自上次被访问以来所经历的时间t**。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。 

![](273.png)

![](272.png)

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。

### 时钟置换算法(CLOCK)

最佳置换算法性能最好，但无法实现：先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。因此，操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU算法的性能，这类算法都是CLOCK算法的变体。

**时钟置换算法**是一种性能和开销较均衡的算法，又称CLOCK算法，或**最近未用算法**（NRU，NotRecently Used)。

#### 简单的CLOCK置换算法

简单的CLOCK算法实现：

为每个页面设置一个**访问位**，再将内存中的页面都通过链接指针**链接成一个循环队列**。

当某页被访问时，其访问位置为1。

当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为O的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。

![](274.png)



![](275.png)

#### 改进型CLOCK置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。

因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。

::: warning

为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。

:::

算法规则：将所有可能被置换的页面排成一个循环队列

- 第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。（最近没访问，且没修改的页面）
- 第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0。（最近没访问，但修改过的页面）
- 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位。（最近访问过，但没修改的页面）
- 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。 （最近访问过，且修改过的页面）

由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此**改进型CLOCK置换算法**选择一个淘汰页面**最多会进行四轮扫描**。

## 页面分配策略

![](280.png)

### 驻留集

驻留集：指请求分页存储管理中**给进程分配的物理块的集合**。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

- 若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；
- 若驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小

### 内存分配策略

在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。

- **固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，**驻留集大小不变**。
- **可变分配**：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，**驻留集大小可变**。

在进行置换时，也可采取两种策略，即全局置换和局部置换。

- **局部置换**：发生缺页时只能选进程自已的物理块进行置换。
- **全局置换**：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

于是可组合出下面三种适用的策略：

1. **固定分配局部置换**：

   系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。

   缺点：**难以确定应为每个进程分配的物理块数目**。太少会频繁出现缺页中断，太多又会降低CPU和其他资源的利用率。（但采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）

2. **可变分配全局置换**：

   刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。

   采用这种策略时，**只要某进程发生缺页，都将获得新的物理块**，仅当空闲物理块用完时，系统才**选择一个未锁定的页面调出**。被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中的进程拥有的物理块会减少，缺页率会增加**。

3. **可变分配局部置换**：

   刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自已的物理块中选出一个进行换出外存。

   如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

::: tip

全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配，这也就是为什么没有固定分配全局置换。

:::

::: tip

可变分配全局置换：只要缺页就给分配新物理块。

可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块。

:::

### 调入页面的时机

为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：

1. **预调页策略**

   根据局部性原理（主要指空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存。

   这种策略**主要用于进程的首次调入**，由程序员指出应该先调入哪些部分。

2. 请求调页策略

   进程**在运行期间发现缺页时才将所缺页面调入内存**。

   由这种策略调入的页面一定会被访问到，由于每次只能调入一页，而每次调页都要磁盘/O操作，因此**I/O开销较大**。

### 从何处调入页面

请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。 对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：

1. 系统拥有足够的对换区空间

   可以全部从对换区调入所需页面，以提高调页速度。为此， 在进程运行前，需将与该进程有关的文件从文件区复制到对换区。

   ![](277.png)

2. 系统缺少足够的对换区空间

   凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。

   ![](278.png)

3. UNIX方式

   与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。

   ![](279.png)

### 抖动

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种**频繁的页面调度行为**称为**抖动**，或颠簸。

产生抖动的主要原因：进程频繁访问的页面数目高于可用的物理块数（**分配给进程的物理块不够**）

### 工作集

驻留集：指请求分页存储管理中给进程分配的内存块的集合。

工作集：指在某段时间间隔里，进程实际访问页面的集合。

![](281.png)

实际应用中，工作集窗口会设置得很大，即对于局部性好的程序，工作集大小一般会比工作集窗口小很多。

操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。例如：工作集窗口大小为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。

::: tip

**驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页**。

因为工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页，所以为了防止这种抖动现象，一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。

:::

## 内存映射文件

内存映射文件：操作系统向上层程序员提供的功能（系统调用）

- 方便程序员**访问**文件数据
- 方便多个进程**共享**同一个文件

![](282.png)

![](283.png)

![](284.png)



![](285.png)

## 虚拟存储器性能影响因素

- 根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。

  页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。

  页面较大时，虽然可以减少页表长度，但会使页内碎片增大。 

- 分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。可见，此时已没有必要再为它分配更多的物理块，否则也只能是浪费内存空间。

  只要保证活跃页面在内存中，保持缺页率在一个很低的范围即可。 

- 好的页面置换算法可使进程在运行过程中具有较低的缺页率。

  选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。 

- 写回磁盘的频率。换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。

  为此在系统中建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将它们一起写回磁盘，这样就可显著减少磁盘I/O的次数，即减少巳修改页面换出的开销。

  此外，如果有进程在这批数据还未写回磁盘时需要再次访问这些页面，就不需从外存调入，而直接从已修改换出页面链表上获取，这样也可以减少页面从磁盘读入内存的频率，减少页面换进的开销。

## 地址翻译

223
