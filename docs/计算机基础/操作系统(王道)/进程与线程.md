---
title: 进程与线程
index: 2
typora-root-url: ./..\..\..\..\IMG\docs\计算机\操作系统
---

# 前驱图

前驱图是一个**有向无循环图**，可记为DAG，用于**描述进程之间执行的先后顺序**。

- 结点表示进程或程序段
- 有向边表示两个结点直接存在偏序或前趋关系

# 程序执行

## 程序顺序执行

一个较大的程序通常都由若干个程序段组成，程序在执行时必须按照某种先后次序逐个执行，仅当前一操作执行完后，才能执行后继操作。

![](147.png)

## 程序并发执行

采用多道程序技术，将多个程序同时装入内存，使之并发运行。

![](148.png)

特征：

1. 间断性

   并发程序之间相互制约，执行——暂停执行——执行。

2. 失去封闭性

   多个程序共享全机资源，执行状态受外界因素影响。

3. 不可再现性

   程序经过多次执行后，虽然其执行时的环境和初始条件都相同，但得到的结果却各不相同。

# 进程

## 进程的概念

### 进程控制块

系统利用**进程控制块**（Process Control Block，**PCB**）来描述进程的基本情况和运行状态，进而控制和管理进程。

![](43.png)

::: tip 

PCB是进程存在的唯一标志。

:::



### 进程实体

由程序段、相关数据段和PCB三部分构成了**进程实体** （又称**进程映像**）。进程实体反应了进程在某一时刻的状态。

::: tip 

进程映像是静态的，进程则是动态的。

:::

![](44.png)

- 创建进程，实质上是创建进程实体中的PCB；
- 撤销进程，实质上是撤销进程的PCB；

### 进程

典型的定义有：

1. 进程是程序的一次执行过程。
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调 度的一个独立单位。 

了解了进程实体的概念后，我们可以把传统操作系统中的进程定义为：**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**。

## 进程的特征

进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。

进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。

![](45.png)

## 进程的状态与转换

![](51.png)

### 状态

进程通常有以下5种状态，前3种是进程的基本状态，

1. **运行态**

   进程正在处理机上运行。

   ::: info 

   在单处理机中，每个时刻只有一个进程处于运行态。

   :::

   ![](47.png)

2. **就绪态**

   进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。

   ::: info 

   系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 

   :::

3. **阻塞态**，又称等待态。

   进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。

   ::: info 

   系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。

   :::

   ![](48.png)

4. **创建态**

   进程正在被创建，尚未转到就绪态。

   ::: info 

   创建进程需要多个步骤：

   - 首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；
   - 然后为该进程分配运行时所必须的资源；
   - 最后把该进程转入就绪态并插入就绪队列。

   如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。 

   :::

   ![](46.png)

5. **终止态**

   进程从系统中消失，可能是进程正常结束或其他原因退出运行。

   ::: info 

   进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。

   ::: 

   ![](49.png)



::: tip 就绪态和阻塞态的区别

就绪态和等待态是进程生命周期中两个完全不同的状态。

- 就绪态是指进程仅缺少处理器，只要获得处理机资源就立即运行；
- 阻塞态是指进程需要其他资源（除了处理机）或等待某一事件；

:::

### 状态之间的转换

- 就绪态$\to$运行态

  处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片）。

- 运行态$\to$就绪态

  1. 处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。
  2. 当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。 

- 运行态$\to$阻塞态

  进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如 I/O操作的完成）时，它就从运行态转换为阻塞态。

- 阻塞态$\to$就绪态

  进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。

![](50.png)

## 进程的组成

进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。

### 进程控制块（PCB）

PCB是进程实体的一部分，是进程存在的唯一标志。

在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统唯有通过进程的PCB才能感知到该进程的存在。 

PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。

![](52.png)

在一个系统中，通常存在着许多进程的PCB，常用链接方式和索引方式将各进程的PCB组织起来。

- 链接方式

  ![](53.png)

- 索引方式

  ![](54.png)



### 程序段

程序段就是能被进程调度程序调度到CPU执行的程序代码段。

::: tip

程序可被多个进程共享，即多个进程可以运行同一个程序。

:::

### 数据段

一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

## 进程控制

![](61.png)

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。 

在操作系统中，一般把进程控制用的程序段称为原语。

::: info 如何实现原语的“原子性”

原语的执行具有原子性，即执行期间不允许中断。

可以使用“**关中断指令**”和“**开中断指令**”实现。

![](55.png)

![](56.png)

:::

### 进程的创建

![](57.png)

创建新进程的过程如下（创建原语）：

1. 为新进程分配一个唯一的进程标识号，并申请一个空白PCB （PCB是有限的），若申请失败，则创建失败。 
2. 为进程分配其运行所需的资源。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。
3. 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。

::: info

允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。

子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。 

:::

### 进程的终止

![](58.png)

引起进程终止的事件主要有：

1. 正常结束：进程的任务己完成并准备退出运行。
2. 异常结束：进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、 非法指令、特权指令错、运行超时、算术运算错、I/O故障等。
3. 外界干预：指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。 

统终止进程的过程如下（终止原语）： 

1. 根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。 
2. 若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程。 
3. 若该进程还有子孙进程，则应将其所有子孙进程终止。
4. 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
5. 将该PCB从所在队列中删除。

### 进程的阻塞和唤醒

![](59.png)

阻塞原语的执行过程如下：

1. 找到将要被阻塞进程的标识号对应的PCB。
2. 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。
3. 把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程

唤醒原语的执行过程如下：

1. 在该事件的等待队列中找到相应进程的PCB。
2. 将其从等待队列中移出，并置其状态为就绪态。
3. 把该PCB插入就绪队列，等待调度程序调度

::: tip

阻塞原语和唤醒原语是一对作用相反的原语，必须**成对使用**。

如果在某进程中调用了阻塞原语，则必须在与之合作的或其他相关的进程中安排一条相应的唤醒原语，以便唤醒阻塞进程；否则，阻塞进程将会因不能被唤醒而永久地处于阻塞状态。

:::

### 进程的切换

![](60.png)

进程切换是在内核的支持下实现的。可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

**上下文切换**：切换CPU到另一个进程需要**保存当前进程状态**并**恢复另一个进程的状态**的过程。

::: info

**上下文切换只能发生在内核态**，它是多任务操作系统中的一个必需的特性。

::: 

**上下文**：某一时刻CPU寄存器和程序计数器的内容。

**实质**：处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。

上下文切换的**流程**：

1. 挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。 
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 
4. 选择另一个进程执行，并更新其PCB。
5. 跳转到新进程PCB中的程序计数器所指向的位置执行。
6. 恢复处理机上下文。

上下支切换的**消耗**：上下文切换通常是计算密集型的，即需要消耗大量的CPU时间。但当处理器提供多个寄存器组的时候，上下文切换就只需要简单改变当前寄存器组的指针。

::: tip 模式切换

**用户态和内核态之间的切换**称为模式切换，因为没有改变当前的进程。

模式切换与上下文切换是不同的，模式切换时，CPU逻辑上可能还在执行同一进程。

:::

::: tip 调度和切换的区别

- 调度是指决定资源分配给哪个进程的行为，是一种决策行为； 
- 切换是指实际分配的行为，是执行行为。

一般来说，先有资源的调度，然后才有进程的切换。

:::

## 进程的通信

![](69.png)

进程通信：**进程之间的信息交换**。

::: info 为什么进程通信需要操作系统支持

进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现。

![](62.png)

:::

PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。

高级通信方法主要有以下三类。

### 共享存储

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。

![](63.png)

在对共享空间进行写/读操作时，需要使用同步互斥工具，对共享空间的写/读进行控制。

共享存储又分为两种：

1. 低级方式的共享是**基于数据结构**的共享；
2. 高级方式的共享是**基于存储区**的共享；

操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。 

### 消息传递

在消息传递系统中，进程间的数据交换以**格式化的消息**为单位。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

![](64.png)

- **直接通信方式**

  发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。

  ![](65.png)

- **间接通信方式**

  发送进程把消息发送到**某个中间实体**（一般称为**信箱**），接收进程从中间实体取得消息。

  ![](66.png)

### 管道通信

管道通信允许两个进程按生产者-消费者方式进行通信，生产者向管道的一端写，消费者从管道的另一端读。

![](67.png)

数据在管道中是先进先出的。

- 只要管道非空，读进程就能从管道中读出数据。若管道读空，则读进程阻塞，直到写进程往管道中写入新的数据，再将读进程唤醒。

- 只要管道不满，写进程就能往管道中写入数据。若管道写满，则写进程阻塞，直到读进程读出数据，再将写进程唤醒。

- 普通管道只允许单向通信，若要实现父子进程双向通信，则需要定义两个管道。

  ![](68.png)

- 从管道**读数据是一次性操作**，数据一旦被读取，就会彻底消失。因此当多个进程读同一个管道时，可能会错乱，通常采用**一个管道允许多个写进程，一个读进程**的方案解决。

为了协调双方的通信，管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。

# 线程

## 线程的概念

::: info

- 引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。
- 引入线程的目的是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

::: 

线程最直接的理解就是“轻量级进程”，它是一个**基本的CPU执行单元**，也是**程序执行流的最小单元**，由线程ID、程序计数器、寄存器集合和堆栈组成。

![](70.png)

线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。

一个线程可以创建和撤销另一个线程，**同一进程中的多个线程之间可以并发执行**。

由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。 

## 线程与进程的比较

::: info 引入线程机制后的变化

![](71.png)

:::

1. **调度**

   在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。

   在引入线程的操作系统中，线程是独立调度的基本单位， 而**线程切换的代价远低于进程**。

   在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 

2. **并发性**

   在引入线程的操作系统中，

   - 进程之间可以并发执行，
   - 一个进程中的多个线程之间可以并发执行
   - 不同进程中的线程也可以并发执行

3. **拥有资源**

   进程是系统中拥有资源的基本单位，而线程不拥有系统资源，但线程可以访问其隶属进程的系统资源，这主要表现在属于同一进程的所有线程都具有相同的地址空间。

   ::: tip

   若线程也是拥有资源的单位, 则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。

   :::

4. **独立性**

   每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程不可见。

   同一进程中的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。 

5. **系统开销**

   在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源。操作系统为此所付出的开销大于创建或撤销线程时的开销。

   在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。

   由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。 

6. **支持多处理机系统**

   对于传统单线程进程，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。

## 线程的属性

多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。

进程处于“执行”状态，实际上是指该进程中的某线程正在执行。

![](72.png)

## 线程的状态与转换

线程在运行时也具有下面三种基本状态：

- 执行状态：线程己获得处理机而正在运行。
- 就绪状态：线程已具备各种执行条件，只需再获得CPU便可立即执行。
- 阻寒状态：线程在执行中因某事件受阻而处于暂停状态。 

线程这三种基本状态之间的转换和进程基本状态之间的转换是一样的。

![](78.png)

## 线程的组织与控制

### 线程控制块

与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。

![](79.png)

同一进程中的所有线程都完全共享进程的地址空间和全局变量。

各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。

### 线程的创建

线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。

用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。

### 线程的终止

当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。但是有些线程(主要是系统线程)一旦被建立，便一直运行而不会被终止。

通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。 

被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。

## 线程的实现方式

线程的实现可以分为两类：**用户级线程**和**内核级线程**。

内核级线程又称内核支持的线程。

### 用户级线程

在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在用户空间中完成，**内核意识不到线程的存在**。

应用程序可以通过使用**线程库**设计成多线程程序。

![](73.png)

优点：

1. 线程切换不需要转换到内核空间，**节省了模式切换的开销**。
2. 调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程**选择不同的调度算法**。
3. 用户级线程的**实现与操作系统平台无关**，对线程管理的代码是属于用户程序的一部分。

缺点：

1. **系统调用的阻塞问题**：当进程内的一个线程被阻塞时，进程内的所有线程都被阻塞。
2. **不能发挥多处理机的优势**：内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。

### 内核级线程

内核级线程也是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。

内核空间为每个内核级线程设置一个线程控制块，内核根据该控制块感知某线程的存在，并对其加以控制。

![](74.png)

优点：

1. 内核能同时调度同一进程中的多个线程并行执行。
2. 当一个线程被阻塞时，别的线程还可以继续执行。
3. 内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。
4. 内核本身也可采用多线程技术，可以提高系统的执行速度和效率。

缺点：

同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。

### 组合方式

在组合实现方式中，内核支持多个内核级线程的建立、 调度和管理，同时允许用户程序建立、调度和管理用户级线程。

组合方式能结合KLT和 ULT的优点，并且克服各自的不足。

## 多线程模型

有些系统同时支持用户线程和内核线程，由于用户级线程和内核级线程连接方式的不同，从而形成了三种不同的多线程模型。

### 一对一模型

将每个用户级线程映射到一个内核级线程。

优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。

 缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大。

![](75.png)

### 多对一模型

将多个用户级线程映射到一个内核级线程。

优点：线程管理是在用户空间进行的，效率比较高。

缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。

![](76.png)

### 多对多模型

将n个用户线程映射到m个内核级线程上，要求$n\geqslant m$。

既**克服了多对一模型并发度不高的缺点**，又**克服了一对一模型开销太大的缺点**。此外，还拥有上述两种模型各自的优点。

![](77.png)

# 调度

## 调度的基本概念

在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。

处理机调度是**对处理机进行分配**，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。 

::: tip

处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。

:::

## 调度的层次

::: info 什么是作业

![](80.png)

::: 

### 三级调度

![](83.png)

一个作业从提交开始直到完成，往往要经历三级调度：

1. **高级调度（作业调度）**

   按照一定的原则从外存上处于后备队列的作业中挑选一个或多个，给它们分配资源，并建立相应的进程，以使它们获得竞争处理机的权利。

   **每个作业只调入一次、调出一次**，调入时会建立PCB，调出时才撤销PCB。

   多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。

   作业调度就是内存与辅存之间的调度。

2. **中级调度（内存调度）**

   按照某种策略决定哪个处于挂起状态的进程重新调入内存。

   将暂时不能运行的进程调至外存等待，此时进程的状态称为**挂起态**。当它们己具备运行条件且内存空闲时，由中级调度把外存上的那些进程重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。

   中级调度的目的是**提高内存利用率和系统吞吐量**。

   **中级调度发生的频率比高级调度高**。

3. **低级调度（进程调度）**

   按照某种算法从就绪队列中选取一个进程，将处理机分配给它。

   进程调度是**最基本的一种调度**，在各种操作系统中都必须配置这级调度。

   进程调度的**频率很高**，一般几十毫秒一次。

---

::: info 进程的挂起态与七状态模型

![](81.png)

:::

### 三级调度的联系

![](82.png)

## 调度的目标

76

## 调度的实现

### 调度的时机

![](84.png)

![](85.png)

### 调度的切换与过程

进程切换往往在调度完成后立刻发生，它要求保存原进程当前断点的现场信息，恢复被调度进程的现场信息。

![](86.png)

### 进程调度方式

进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。

1. **非抢占调度方式**，又称**非剥夺方式**

   当有更重要或紧迫的进程进入就绪队列时，仍然让当前进程继续执行，直到该进程运行完成或进入阻塞态时，才把处理机分配给其他进程。

   非抢占调度方式的优点是**实现简单**、**系统开销小**，适用于大多数的批处理系统，但它**不能用于分时系统和大多数的实时系统**。

   ---

2. **抢占调度方式**，又称**剥夺方式**

   当一个进程正在处理机上执行时，若有一个更重要或紧迫的进程需要使用处理机，则暂停正在执行的进程，将处理机分配给更重要或紧迫的进程。

   抢占调度方式对**提高系统吞吐率和响应效率**都有明显的好处。适用于分时操作系统、实时操作系统。

### 调度程序（调度器）

![](89.png)

用于调度和分派CPU的组件称为调度程序，它通常由三部分组成：

1. 排队器

   将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。

   每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。

2. 分派器

   依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。

3. 上下文切换器

   在对处理机进行切换时，会发生两对上下文的切换操作：

   - 第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；
   - 第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器；

---

![](87.png)

上图所说的是进程的调度，如果一个系统支持线程，那么调度的对象就是线程了。

![](88.png)

### 闲逛进程

在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程（idle）运行，如果没有其他进程就绪，该进程就一直运行，并在执行过程中测试中断。

特点：

1. 优先级最低
2. 不需要CPU之外的资源，它不会被阻塞

## 调度算法

### 评价指标

![](90.png)

1. CPU利用率

   ![](91.png)

2. 系统吞吐量

   ![](92.png)

3. 周转时间

   ![](93.png)

   ![](94.png)

4. 等待时间

   ![](95.png)

5. 响应时间

   ![](96.png)

### 先来先服务调度算法(FCFS)

> FCFS, First Come First Serve

![](97.png)

FCFS调度算法是一种最简单的调度算法，它**既可用于作业调度，又可用于进程调度**。

- 在作业调度中，算法每次从后备作业队列中选择最先进入该队列的作业。
- 在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程。

FCFS调度算法属于不可剥夺算法。

FCFS调度算法对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此**不能作为分时系统和实时系统的主要调度策略**，但它常被结合在其他调度策略中使用。

FCFS调度算法的特点是算法简单，但效率低；**对长作业比较有利，但对短作业不利**（相对 SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。

![](98.png)

### 短作业优先调度算法(SJF)

> SJF, Shortest Job First

![](103.png)

短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。

- 短作业优先（SJF） 调度算法从后备队列中选择运行时间最短的作业；
- 短进程优先（SPF）调度算法从就绪队列中选择运行时间最短的进程；

缺点：

1. 该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。 甚至有可能导致长作业长期不被调度而产生“饥饿”现象

   ::: tip 死锁和饥饿的区别

   - 死锁是系统环形等待
   - 饥饿是调度策略问题

   :::

2. 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。

3. 由于作业的长短是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。



![](99.png)

![](100.png)

![](101.png)

::: tip 

SJF调度算法的平均等待时间、平均周转时间最少。

:::

![](102.png)

### 优先级调度算法(PR)

![](113.png)

优先级调度算法**既可用于作业调度，又可用于进程调度**。

优先级用于描述作业的紧迫程度，

- 在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的作业。
- 在进程调度中，优先级调 度算法每次从就绪队列中选择优先级最高的进程。

---

根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为如下两种：

1. **非抢占式优先级调度算法**

   当一个进程正在处理机上运行时，即使有某个优先级更高的进程进入就绪队列，仍让正在运行的进程继续运行，直到由于其自身的原因而让出处理机时，才把处理机分配给就绪队列中优先级最高的进程。

   ![](111.png)

2. **抢占式优先级调度算法**

   当一个进程正在处理机上运行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给优先级更高的进程。

   ![](112.png)

---

根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：

1. 静态优先级

   优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。

2. 动态优先级

   在进程运行过程中，根据进程情况的变化动态调整优先级。

::: info 进程优先级的设置参照原则

1. 系统进程$>$用户进程

   系统进程作为系统的管理者，理应拥有更高的优先级。

2. 交互型进程$>$非交互型进程（前台进程$>$后台进程）

   在前台运行的正在和用户交互的进程应该更快速地响应，因此自然需要被优先处理。 

3. I/O型进程$>$计算型进程

   I/O型进程是指会频繁使用I/O设备的进程，计算型进程是指会频繁使用CPU的进程（很少使用I/O设备）。

   将I/O型进程的优先级设置得更高，就更有可能让I/O设备尽早开始工作，进而提升系统的整体效率。

:::

### 高响应比优先调度算法(HRRN)

> HRRN, Highest Response Ratio Next

![](106.png)

高响应比优先调度算法**主要用于作业调度**，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。

每次进行作业调度时，先计算后备 作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。

![](104.png)

- 作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，类似于SJF。
- 要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，类似于FCFS。
- 对于长作业，作业的响应比可以随等待时间的增加而提高， 当其等待时间足够长时，也可获得处理机，克服了“饥饿“现象。

![](105.png)

### 时间片轮转调度算法(RR)

> RR, Round-Robin

![](110.png)

时间片轮转调度算法**主要适用于分时系统**。

系统将所有就绪进程按FCFS策略排成一个就绪队列，调度程序总是选择就绪队列中的第一个进程执行，但仅能运行一个时间片， 如50ms。在使用完一个时间片后，即使进程并未运行完成，它也必须被剥夺处理机给下一个就绪进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。 

在时间片轮转调度算法中，**时间片的大小对系统性能的影响很大**。

- 若**时间片很大**，则所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就**退化为先来先服务调度算法**。 
- 若**时间片很小**，则处理机将在进程间过于频繁地切换，使**处理机的开销增大**，而真正用于运行用户进程的时间将减少。

因此，时间片的大小应选择适当，时间片的长短通常由**系统的响应时间**、**就绪队列中的进程数目**和**系统的处理能力**确定。

![](107.png)

![](108.png)

![](109.png)

### 多级反馈队列调度算法

![](115.png)

多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。

通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。 

![](116.png)

实现思想：

1. 设置多个就绪队列，并为每个队列赋予不同的优先级。

   第1级队列的优先级最高，第2级队列的优先级次之，其余队列的优先级逐个降低。

2. 赋予各个队列的进程运行时间片的大小各不相同。

   优先级越高的队列，每个进程的时间片就越小。

3. 每个队列都采用FCFS算法。

   当新进程进入内存后，首先将它放入第1级队列的末尾，按 FCFS原则等待调度。

   当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。 若在一个时间片结束时尚未完成，调度程序将其转入第2级队列的末尾等待调度；若在第2级队列中运行一个时间片后仍未完成，再将它放入第3级队列……，以此类推。 

   当进程最后被降到第n级队列后，在第n级队列中便采用时间片轮转方式运行。

4. 按队列优先级调度。

   仅当第1级队列为空时，才调度第2级队列中的进程运行；仅当第1〜 i-1级队列均为空时，才会调度第i级队列中的进程运行。

   若处理机正在执行第i级队列中的某进程时，又有新进程进入任何一个优先级较高的队列，此时须立即把正在运行的进程放回到第i级队列的末尾，而把处理机分配给新到的高优先级进程。

> https://www.bilibili.com/video/BV1YE411D7nH?t=1768.3&p=24

![](114.png)

![](117.png)

### 多级队列调度算法

该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可实施不同的调度算法。

同一队列中的进程可以设置不同的优先级，不同的队列本身也可以设置不同的优先级。

![](118.png)

# 同步与互斥

## 同步与互斥的基本概念

![](120.png)

### 临界资源

![](121.png)

**一个时间段内只允许一个进程使用的资源**称为**临界资源**。许多物理设备都属于临界资源，如打印机等。

在每个进程中，**访问临界资源的那段代码**称为**临界区**。

临界资源的访问过程分成4个部分：

1. 进入区：检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。
2. 临界区：进程中访问临界资源的那段代码，又称临界段。
3. 退出区：将正在访问临界区的标志清除。 
4. 剩余区：代码中的其余部分。

### 同步

同步亦称**直接制约关系**。

进程间的直接制约关系源于它们之间的相互合作。 

![](119.png)

### 互斥

互斥也称**间接制约关系**。

当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。 

为了实现对临界资源的互斥访问，应遵循以下准则：

1. 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 
2. 忙则等待：当己有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区。
4. 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。

## 互斥的软件实现方法

![](126.png)

### 单标志法

该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号，即若turn= 0，则允许$P_0$进程进入临界区。

![](122.png)

该算法可确保每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（**违背“空闲让进”**）。

假设此时进入临界区的进程是$P_0$，但$P_0$不访问临界区，那么即使临界区空闲其它进程也无法访问。

### 双标志法先检查

该算法在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。

![](123.png)

优点：不用交替进入，可连续使用；

缺点：$P_i$和$P_j$可能同时进入临界区；

### 双标志法后检查 

![](124.png)

### Peterson 算法

![](125.png)

## 互斥的硬件实现方法

### 中断屏蔽方法

当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法是**关中断**。

因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现。

![](127.png)

### 硬件指令方法

![](130.png)

1. TestAndSet指令

   这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。

   ![](128.png)

2. Swap指令

   该指令的功能是交换两个字(字节 )的内容。

   ![](129.png)

## 互斥锁

解决临界区最简单的工具就是互斥锁（mutex lock）。

一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。 

![](131.png)

互斥锁通常采用硬件机制来实现 。 

互斥锁的主要缺点是**忙等待**，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。

当多个进程共享同一个CPU时，就浪费了CPU周期。因此，**互斥锁通常用于多处理器系统**，一个线程可以在一个处理器上等待，不影响其他线程的执行。

::: tip

需要连续循环忙等待的互斥锁，都可称为自旋锁，如TSL指令、swap指令、但标志法。

:::

![](132.png)

## 信号量

![](137.png)

![](142.png)

信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为“P操作”和"V操作”。

![](133.png)

### 整型信号量

整型信号量被定义为一个用于表示资源数目的整型量S。

该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。

![](134.png)

### 记录型信号量

记录型信号量机制是一种不存在“忙等”现象的进程同步机制。

除了需要一个用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。

![](135.png)

![](136.png)

### 利用信号量实现互斥

![](138.png)

### 利用信号量实现同步

![](139.png)

![](140.png)

### 利用信号量实现前驱关系

![](141.png)

##  用信号量解决经典同步问题

### 生产者-消费者问题

1. 问题

   ![](143.png)

2. 分析

   ![](144.png)

3. 实现 

   ![](145.png)

::: tip 能否改变相邻P、V操作的顺序

![](146.png)

:::

### 多生产者-多消费者问题

1. 问题

   ![](149.png)

2. 分析

   ![](150.png)

3. 实现

   ![](151.png)

::: tip 可不可以不设置互斥信号量

![](152.png)

结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。

原因：问题中的缓冲区大小为1，在任何时候，apple、orange、plate三个同步信号量最多只有一个是1。因此在任何时刻，最多只有一个进程进入临界区。因此若问题中的缓冲区大小大于1，则必须设置一个互斥信号量来保证互斥访问缓冲区。

::: 

![](153.png)

### 吸烟者问题

1. 问题

   ![](154.png)

2. 分析

   ![](155.png)

3. 实现

   ![](156.png)

::: tip 是否需要设置一个专门的互斥信号量

与多生产者-多消费者问题相似，缓冲区的大小为1，同一时刻，四个同步信号量中只有一个的值为1.

:::

### 读者写者问题

1. 问题

   ![](157.png)

2. 分析

   ![](158.png)

3. 实现

   ![](159.png)

   ![](160.png)

![](161.png)

### 哲学界进餐问题

1. 问题

   ![](162.png)

2. 分析

   ![](164.png)

3. 实现 

   ![](167.png)

   ::: 死锁

   ![](163.png)

   ![](166.png)

   :::

![](165.png)

## 管程

![](173.png)

::: info 为什么要引入管程

在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具一一管程。

![](168.png)

::: 

::: info

系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性。

::: 

利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。

::: info

进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。

::: 

这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为**管程**(monitor)。

![](169.png)

当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为**条件变量**(condition)。

一个进程被阻塞的原因可以有多个，因此在管程中可以设置多个条件变量。每个条件变量保存了一个等待队列， 用于记录因该条件变量而阻塞的所有进程。

对条件变量只能进行两种操作，即 wait 和 signal：

- `x.wait`：当x对应的条件不满足时，正在调用管程的进程调用`x.wait`将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。
- `x.signal`：x对应的条件发生了变化，则调用`x.signal`，唤醒一个因x条件而阻塞的进程。

---

![](170.png)

![](171.png)



::: tip Java中类似于管程的机制

![](172.png)

:::

# 死锁

![](177.png)

## 定义

死锁：多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

::: tip 死锁、饥饿、死循环的区别

![](174.png)

:::

## 死锁产生的原因

1. **系统资源的竞争**

   通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。

   **只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的**。

2. **进程推进顺序非法**

   进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。

3. **信号量使用不当**

   进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。

   例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。

![](176.png)

## 死锁产生的必要条件

产生死锁必须**同时满足以下4个条件**，只要其中任意一个条件不成立，死锁就不会发生。

1. **互斥条件**

   进程要求对所分配的资源在一段时间内某资源仅为一个进程所占有。若有其他进程请求该资源，则请求进程只能等待。

2. **不剥夺条件**

   进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。

3. **请求并保持条件**

   进程己经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 

4. **循环等待条件**

   存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

![](175.png)

## 死锁的处理策略

为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或者允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。

1. **死锁预防**

   设置某些限制条件，**破坏产生死锁的4个必要条件**中的一个或几个。 

2. **避免死锁**

   在资源的动态分配过程中，用某种方法**防止系统进入不安全状态**。

3. **死锁的检测及解除**

   **无须采取任何限制性措施**，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。 

::: tip 预防死锁和避免死锁的比较

预防死锁和避免死锁**都属于事先预防策略**

- 预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；
- 避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。

:::

![](178.png)

### 死锁预防

![](183.png)

防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。

1. 破坏互斥条件

   若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问， 如打印机等临界资源只能互斥使用。

   所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。

   ![](179.png)

2. 破坏不剥夺条件

   当一个己保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放己经保持的所有资源，待以后需要时再重新申请。

   ![](180.png)

3. 破坏请求并保持条件

   ![](181.png)

4. 破坏循环等待条件

   ![](182.png)

### 死锁避免

避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。

---

#### 安全状态

**安全状态**，是指系统能按某种进程推进顺序$(P_1,P_2,\cdots,P_n)$为每个进程$P_i$分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。

此时称$P_1,P_2,\cdots,P_n$为**安全序列**。

若系统无法找到一个安全序列，则称系统处于**不安全状态**。 

![](184.png)

![](185.png)

![](186.png)

![](187.png)

---

#### 银行家算法

银行家算法是最著名的死锁避免算法。

思想：

把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。

操作系统按照银行家制定的规则为进程分配资源。

进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

![](188.png)

![](189.png)

![](190.png)

![](191.png)

![](192.png)

![](193.png)

数据结构描述：

1. 可利用资源向量 `Available` 

   含有m个元素的数组，其中每个元素代表一类可用的资源数目。 Available[j] = K表示系统中现有$R_j$类资源K个。 

2. 最大需求矩阵 `Max` 

   $n\times m$矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求。 

   一行代表一个进程，一列代表一类资源。Max[i, j]=K 表示进程 i 需要$R_j$类资源的最 大数目为K。 

3. 分配矩阵 `Allocation` 

   $n\times m$矩阵，定义系统中每类资源当前已分配给每个进程的资源数。 

   Allocation[i, j]=K 表示进程 i 当前已分得$R_j$类资源的数目为K。

4. 需求矩阵 `Need`

    $n\times m$矩阵，表示每个进程接下来最多还需要多少资源。

   Need[i, j]=K 表示进程 i 还需要$R_j$类资源的数目为K。

![](194.png)



![](195.png)

### 死锁检测和解除

![](199.png)

![](196.png)

 系统死锁可利用**资源分配图**来描述。

![](197.png)

简化资源分配图可检测系统状态S是否为死锁状态。简化方法如下：

1. 在资源分配图中，找出既不阻塞又不孤点的进程$P_i$（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于或等于系统中已有的空闲资源数量）。消去它所有的请求边和分配边，使之成为孤立的结点。

   ::: tip 判断某种资源是否有空闲

   用它的资源数量减去它在资源分配图中的出度，例如在上图中，$R_1$的资源数为3，而出度也为3，所以$R_1$没有空闲资源；$R_2$的资源数为2，出度为1，所以$R_2$有一个空闲资源。

   :::

2. 进程$P_i$所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。

   根据1. 中的方法进行一系列简化后，若能消去图中所有的边，则称该图是**可完全简化的**。

S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的，该条件为**死锁定理**。

---

一旦检测出死锁，就应立即采取相应的措施来解除死锁。**死锁解除的主要方法有**：

1. **资源剥夺法**

   挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。 但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。 

2. **撤销进程法**

   强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 

3. **进程回退法**

   让一或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。

![](198.png)
