---
title: 深入了解现代网络浏览器(2)
index: 2
---
::: tip
文章原地址: https://developer.chrome.com/blog/inside-browser-part2/

原文章发表于 2018.9.7，更新于：2018.9.21
:::

## 导航中会发生什么

> What happens in navigation

这是由 4 部分组成的博客系列的第 2 部分，该系列着眼于 Chrome 的内部工作原理。在上一篇文章中，我们研究了不同的进程和线程如何处理浏览器的不同部分。在这篇文章中，我们将更深入地探讨每个进程和线程如何通信以显示网站。

> This is part 2 of a 4 part blog series looking at the inner workings of Chrome. In [the previous post](https://developers.google.com/web/updates/2018/09/inside-browser-part1), we looked at how different processes and threads handle different parts of a browser. In this post, we dig deeper into how each process and thread communicate in order to display a website.

让我们看一下网页浏览的简单用例：您在浏览器中输入一个 URL，然后浏览器从互联网获取数据并显示一个页面。在这篇文章中，我们将重点介绍用户请求网站并且浏览器准备呈现页面的部分 - 也称为导航。

> Let’s look at a simple use case of web browsing: you type a URL into a browser, then the browser fetches data from the internet and displays a page. In this post, we’ll focus on the part where a user requests a site and the browser prepares to render a page - also known as a navigation.

## 它从浏览器进程开始

> It starts with a browser process

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/13.avif)

图 1：顶部是浏览器 UI，底部是包含 UI、网络和存储线程的浏览器进程示意图

> Figure 1: Browser UI at the top, diagram of the browser process with UI, network, and storage thread inside at the bottom

<br/>

正如我们在第 1 部分：CPU、GPU、内存和多进程架构中所介绍的，选项卡之外的所有内容都由浏览器进程处理。浏览器进程具有诸如绘制浏览器按钮和输入字段的 UI 线程，处理网络堆栈以从 Internet 接收数据的网络线程，控制文件访问的存储线程等线程。在地址栏中键入 URL 时，输入由浏览器进程的 UI 线程处理。

> As we covered in [part 1: CPU, GPU, Memory, and multi-process architecture](https://developers.google.com/web/updates/2018/09/inside-browser-part1), everything outside of a tab is handled by the browser process. The browser process has threads like the UI thread which draws buttons and input fields of the browser, the network thread which deals with network stack to receive data from the internet, the storage thread that controls access to the files and more. When you type a URL into the address bar, your input is handled by browser process’s UI thread.

## 简单的导航

> A simple navigation

### 步骤 1：处理输入

> Step 1: Handling input

当用户开始在地址栏中键入内容时，UI 线程询问的第一件事是“这是搜索查询还是 URL？在 Chrome 中，地址栏也是一个搜索输入字段，因此界面线程需要解析并决定是将您发送到搜索引擎还是您请求的网站。

> When a user starts to type into the address bar, the first thing UI thread asks is "Is this a search query or URL?". In Chrome, the address bar is also a search input field, so the UI thread needs to parse and decide whether to send you to a search engine, or to the site you requested.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/14.avif)

图 1：询问输入是搜索查询还是 URL 的 UI 线程

> Figure 1: UI Thread asking if the input is a search query or a URL

<br/>

### 步骤 2：开始导航

> Step 2: Start navigation

当用户按 Enter 键时，UI 线程将启动网络调用以获取网站内容。加载微调器显示在选项卡的一角，网络线程通过适当的协议，如 DNS 查找和为请求建立 TLS 连接。

> When a user hits enter, the UI thread initiates a network call to get site content. Loading spinner is displayed on the corner of a tab, and the network thread goes through appropriate protocols like DNS lookup and establishing TLS Connection for the request.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/15.avif)

图 2：UI 线程与网络线程通信以导航到 mysite.com

> Figure 2: the UI thread talking to the network thread to navigate to mysite.com

<br/>

此时，网络线程可能会收到服务器重定向标头，如 HTTP 301。在这种情况下，网络线程与服务器请求重定向的 UI 线程通信。然后，将启动另一个 URL 请求。

> At this point, the network thread may receive a server redirect header like HTTP 301. In that case, the network thread communicates with UI thread that the server is requesting redirect. Then, another URL request will be initiated.

### 步骤 3：读取响应

> Step 3: Read response

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/16.avif)

图 3：包含内容类型和有效负载（实际数据）的响应标头

> Figure 3: response header which contains Content-Type and payload which is the actual data

<br/>

一旦响应正文（有效负载）开始进入，网络线程会在必要时查看流的前几个字节。响应的内容类型标头应说明它是什么类型的数据，但由于它可能丢失或错误，因此在此处完成 MIME 类型探查。正如源代码中所评论的那样，这是一项“棘手的业务”。您可以阅读注释以了解不同的浏览器如何处理内容类型/有效负载对。

> Once the response body (payload) starts to come in, the network thread looks at the first few bytes of the stream if necessary. The response's Content-Type header should say what type of data it is, but since it may be missing or wrong, [MIME Type sniffing](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types) is done here. This is a "tricky business" as commented in [the source code](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5). You can read the comment to see how different browsers treat content-type/payload pairs.

如果响应是 HTML 文件，那么下一步是将数据传递给渲染器进程，但如果它是一个 zip 文件或其他文件，那么这意味着它是一个下载请求，因此他们需要将数据传递给下载管理器。

> If the response is an HTML file, then the next step would be to pass the data to the renderer process, but if it is a zip file or some other file then that means it is a download request so they need to pass the data to download manager.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/17.avif)

图 4：询问响应数据是否为来自安全站点的 HTML 的网络线程

> Figure 4: Network thread asking if response data is HTML from a safe site

<br/>

这也是安全浏览检查发生的地方。如果域和响应数据似乎与已知的恶意站点匹配，则网络线程会发出警报以显示警告页面。此外，还会进行跨源读取阻塞 （CORB） 检查，以确保敏感的跨站点数据不会进入渲染器进程。

> This is also where the [SafeBrowsing](https://safebrowsing.google.com/) check happens. If the domain and the response data seems to match a known malicious site, then the network thread alerts to display a warning page. Additionally, [Cross Origin Read Blocking](https://www.chromium.org/Home/chromium-security/corb-for-developers) (CORB) check happens in order to make sure sensitive cross-site data does not make it to the renderer process.

### 步骤 4：查找渲染器进程

> Step 4: Find a renderer process

完成所有检查并且网络线程确信浏览器应导航到请求的站点后，网络线程会告知 UI 线程数据已准备就绪。然后，UI 线程找到一个呈现器进程来继续呈现网页。

> Once all of the checks are done and Network thread is confident that browser should navigate to the requested site, the Network thread tells UI thread that the data is ready. UI thread then finds a renderer process to carry on rendering of the web page.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/18.avif)

图 5：网络线程告诉 UI 线程查找渲染器进程

> Figure 5: Network thread telling UI thread to find Renderer Process

<br/>

由于网络请求可能需要几百毫秒才能获得响应，因此应用了优化以加快此过程。当 UI 线程在步骤 2 中向网络线程发送 URL 请求时，它已经知道它们要导航到哪个站点。UI 线程尝试主动查找或启动与网络请求并行的呈现器进程。这样，如果一切按预期进行，则当网络线程接收数据时，渲染器进程已经处于待机位置。如果导航跨站点重定向，则可能不会使用此备用进程，在这种情况下，可能需要其他进程。

> Since the network request could take several hundred milliseconds to get a response back, an optimization to speed up this process is applied. When the UI thread is sending a URL request to the network thread at step 2, it already knows which site they are navigating to. The UI thread tries to proactively find or start a renderer process in parallel to the network request. This way, if all goes as expected, a renderer process is already in standby position when the network thread received data. This standby process might not get used if the navigation redirects cross-site, in which case a different process might be needed.

### 步骤 5：提交导航

> Step 5: Commit navigation

现在数据和呈现器进程已准备就绪，IPC 将从浏览器进程发送到呈现器进程以提交导航。它还传递数据流，以便渲染器进程可以继续接收 HTML 数据。一旦浏览器进程听到呈现器进程中发生了提交的确认，导航就完成了，文档加载阶段开始了。

> Now that the data and the renderer process is ready, an IPC is sent from the browser process to the renderer process to commit the navigation. It also passes on the data stream so the renderer process can keep receiving HTML data. Once the browser process hears confirmation that the commit has happened in the renderer process, the navigation is complete and the document loading phase begins.

此时，地址栏将更新，安全指示器和站点设置 UI 将反映新页面的网站信息。选项卡的会话历史记录将更新，以便后退/前进按钮将逐步浏览刚刚导航到的站点。为了便于在关闭选项卡或窗口时还原选项卡/会话，会话历史记录存储在磁盘上。

> At this point, address bar is updated and the security indicator and site settings UI reflects the site information of the new page. The session history for the tab will be updated so back/forward buttons will step through the site that was just navigated to. To facilitate tab/session restore when you close a tab or window, the session history is stored on disk.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/19.avif)

图 6：浏览器和渲染器进程之间的 IPC，请求呈现页面

> Figure 6: IPC between the browser and the renderer processes, requesting to render the page

<br/>

### 额外步骤：初始加载完成

> Extra Step: Initial load complete

提交导航后，呈现器进程将继续加载资源并呈现页面。我们将在下一篇文章中详细介绍此阶段发生的事情。一旦渲染器进程“完成”渲染，它将 IPC 发送回浏览器进程（这是在页面中的所有帧上触发所有 `onload` 事件并完成执行之后）。此时，UI 线程将停止选项卡上的加载微调器。

> Once the navigation is committed, the renderer process carries on loading resources and renders the page. We will go over the details of what happens at this stage in the next post. Once the renderer process "finishes" rendering, it sends an IPC back to the browser process (this is after all the `onload` events have fired on all frames in the page and have finished executing). At this point, the UI thread stops the loading spinner on the tab.

我说“完成”，因为客户端 JavaScript 仍然可以在此之后加载额外的资源并呈现新的视图。

> I say "finishes", because client side JavaScript could still load additional resources and render new views after this point.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/20.avif)

图 7：IPC 从渲染器到浏览器进程，以通知页面已“加载”

> Figure 7: IPC from the renderer to the browser process to notify the page has "loaded"

<br/>

## 导航到其他站点

> Navigating to a different site

简单的导航完成了！但是，如果用户再次将不同的 URL 放入地址栏会发生什么？好吧，浏览器进程通过相同的步骤导航到不同的站点。但在它这样做之前，它需要检查当前呈现的网站是否关心 `beforeunload` 事件。

> The simple navigation was complete! But what happens if a user puts different URL to address bar again? Well, the browser process goes through the same steps to navigate to the different site. But before it can do that, it needs to check with the currently rendered site if they care about [`beforeunload`](https://developer.mozilla.org/docs/Web/Events/beforeunload) event.

`beforeunload` 可以在您尝试导航离开或关闭选项卡时创建“离开此网站？”警报。选项卡内的所有内容（包括 JavaScript 代码）都由渲染器进程处理，因此当新的导航请求进来时，浏览器进程必须与当前渲染器进程进行检查。

> `beforeunload` can create "Leave this site?" alert when you try to navigate away or close the tab. Everything inside of a tab including your JavaScript code is handled by the renderer process, so the browser process has to check with current renderer process when new navigation request comes in.

::: warning Caution
不要添加无条件的 `beforeunload` 处理程序。它会产生更多的延迟，因为处理程序需要在启动导航之前执行。仅在需要时才应添加此事件处理程序，例如，如果需要警告用户可能会丢失他们在页面上输入的数据。

> Do not add unconditional `beforeunload` handlers. It creates more latency because the handler needs to be executed before the navigation can even be started. This event handler should be added only when needed, for example if users need to be warned that they might lose data they've entered on the page.

:::

<br/>

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/21.avif)

图 8：从浏览器进程到渲染器进程的 IPC，告诉它即将导航到其他站点

> Figure 8: IPC from the browser process to a renderer process telling it that it's about to navigate to a different site

<br/>

如果导航是从渲染器进程启动的（例如用户单击链接或客户端 JavaScript 运行 `window.location = "https://newsite.com"` ），则渲染器进程首先检查 `beforeunload` 个处理程序。然后，它经历与浏览器进程启动的导航相同的过程。唯一的区别是导航请求从渲染器进程启动到浏览器进程。

> If the navigation was initiated from the renderer process (like user clicked on a link or client-side JavaScript has run `window.location = "https://newsite.com"`) the renderer process first checks `beforeunload` handlers. Then, it goes through the same process as browser process initiated navigation. The only difference is that navigation request is kicked off from the renderer process to the browser process.

当新导航到与当前呈现的网站不同的网站时，将调用单独的呈现进程来处理新导航，同时保留当前呈现进程以处理 `unload` 等事件。有关详细信息，请参阅页面生命周期状态概述以及如何使用页面生命周期 API 挂钩到事件。

> When the new navigation is made to a different site than currently rendered one, a separate render process is called in to handle the new navigation while current render process is kept around to handle events like `unload`. For more, see [an overview of page lifecycle states](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events) and how you can hook into events with [the Page Lifecycle API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api).

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/22.avif)

图 9：从浏览器进程到新渲染器进程的 2 个 IPC 告诉渲染页面并告诉旧渲染器进程卸载

> Figure 9: 2 IPCs from a browser process to a new renderer process telling to render the page and telling old renderer process to unload

## 在服务工作者的情况下

> In case of Service Worker

此导航过程的最新更改是引入了服务辅助角色。服务工作进程是一种在应用程序代码中编写网络代理的方法;允许 Web 开发人员更好地控制本地缓存的内容以及何时从网络获取新数据。如果服务工作进程设置为从缓存加载页面，则无需从网络请求数据。

> One recent change to this navigation process is the introduction of [service worker](https://developers.google.com/web/fundamentals/primers/service-workers/). Service worker is a way to write network proxy in your application code; allowing web developers to have more control over what to cache locally and when to get new data from the network. If service worker is set to load the page from the cache, there is no need to request the data from the network.

要记住的重要部分是，服务工作者是在渲染器进程中运行的 JavaScript 代码。但是，当导航请求传入时，浏览器进程如何知道站点具有服务辅助角色？

> The important part to remember is that service worker is JavaScript code that runs in a renderer process. But when the navigation request comes in, how does a browser process know the site has a service worker?

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/23.avif)

图 10：浏览器进程中查找服务工作进程的网络线程作用域

> Figure 10: the network thread in the browser process looking up service worker scope

注册服务工作进程时，服务工作进程的作用域将保留为参考（可以在此服务工作进程生命周期一文中阅读有关作用域的详细信息）。发生导航时，网络线程会根据已注册的服务工作进程范围检查域，如果为该 URL 注册了服务工作进程，则 UI 线程会查找渲染器进程以执行服务工作进程。服务工作进程可以从缓存加载数据，无需从网络请求数据，也可以从网络请求新资源。

> When a service worker is registered, the scope of the service worker is kept as a reference (you can read more about scope in this [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) article). When a navigation happens, network thread checks the domain against registered service worker scopes, if a service worker is registered for that URL, the UI thread finds a renderer process in order to execute the service worker code. The service worker may load data from cache, eliminating the need to request data from the network, or it may request new resources from the network.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/24.avif)

图 11：浏览器进程中的 UI 线程启动渲染器进程来处理服务工作线程;然后，渲染器进程中的工作线程从网络请求数据

> Figure 11: the UI thread in a browser process starting up a renderer process to handle service workers; a worker thread in a renderer process then requests data from the network

## 导航预加载

> Navigation Preload

您可以看到，如果服务工作进程最终决定从网络请求数据，则浏览器进程和呈现器进程之间的这种往返可能会导致延迟。导航预加载是一种通过在服务工作进程启动时并行加载资源来加速此过程的机制。它用标头标记这些请求，允许服务器决定为这些请求发送不同的内容;例如，只是更新的数据而不是完整的文档。

> You can see this round trip between the browser process and renderer process could result in delays if service worker eventually decides to request data from the network. [Navigation Preload](https://developers.google.com/web/updates/2017/02/navigation-preload) is a mechanism to speed up this process by loading resources in parallel to service worker startup. It marks these requests with a header, allowing servers to decide to send different content for these requests; for example, just updated data instead of a full document.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/25.avif)

图 12：浏览器进程中的 UI 线程启动渲染器进程来处理服务工作进程，同时并行启动网络请求

> Figure 12: the UI thread in a browser process starting up a renderer process to handle service worker while kicking off network request in parallel

## 总结

> Wrap-up

在这篇文章中，我们研究了导航过程中会发生什么，以及你的 Web 应用程序代码（如响应标头和客户端 JavaScript）如何与浏览器交互。了解浏览器从网络获取数据的步骤可以更容易理解为什么开发导航预加载等 API。在下一篇文章中，我们将深入探讨浏览器如何评估我们的 HTML/CSS/JavaScript 来呈现页面。

> In this post, we looked at what happens during a navigation and how your web application code such as response headers and client-side JavaScript interact with the browser. Knowing the steps browser goes through to get data from the network makes it easier to understand why APIs like navigation preload were developed. In the next post, we’ll dive into how the browser evaluates our HTML/CSS/JavaScript to render pages.

你喜欢这个帖子吗？如果您对未来的帖子有任何疑问或建议，我很乐意在下面的评论部分或 Twitter 上@kosamari 收到您的来信。

> Did you enjoy the post? If you have any questions or suggestions for the future post, I'd love to hear from you in the comment section below or [@kosamari](https://twitter.com/kosamari) on Twitter.
