---
title: 深入了解现代网络浏览器(3)
index: 3
---

::: tip
文章原地址: https://developer.chrome.com/blog/inside-browser-part3/

原文章发表于 2018.9.20，更新于：2020.8.18
:::

## 渲染器进程的内部工作原理

> Inner workings of a Renderer Process

这是由 4 部分组成的博客系列的第 3 部分，探讨浏览器的工作原理。之前，我们介绍了多进程体系结构和导航流。在这篇文章中，我们将看看渲染器进程内部发生了什么。

> This is part 3 of 4 part blog series looking at how browsers work. Previously, we covered [multi-process architecture](https://developers.google.com/web/updates/2018/09/inside-browser-part1) and [navigation flow](https://developers.google.com/web/updates/2018/09/inside-browser-part2). In this post, we are going to look at what happens inside of the renderer process.

渲染器进程涉及 Web 性能的许多方面。由于渲染器进程内部发生了很多事情，这篇文章只是一个一般的概述。如果您想更深入地了解，Web 基础知识的性能部分提供了更多资源。

> Renderer process touches many aspects of web performance. Since there is a lot happening inside of the renderer process, this post is only a general overview. If you'd like to dig deeper, [the Performance section of Web Fundamentals](https://developers.google.com/web/fundamentals/performance/why-performance-matters/) has many more resources.

## 渲染器进程处理 Web 内容

> Renderer processes handle web contents

渲染器进程负责选项卡内发生的所有事情。在呈现器进程中，主线程处理您发送给用户的大部分代码。有时，如果使用 Web worker 或服务 worker ，则 JavaScript 的某些部分由工作线程处理。合成器和光栅线程也在渲染器进程内运行，以高效、流畅地呈现页面。

> The renderer process is responsible for everything that happens inside of a tab. In a renderer process, the main thread handles most of the code you send to the user. Sometimes parts of your JavaScript is handled by worker threads if you use a web worker or a service worker. Compositor and raster threads are also run inside of a renderer processes to render a page efficiently and smoothly.

渲染器进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。

> The renderer process's core job is to turn HTML, CSS, and JavaScript into a web page that the user can interact with.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/26.avif)

图 1：内部包含主线程、工作线程、合成器线程和栅格线程的渲染器进程

> Figure 1: Renderer process with a main thread, worker threads, a compositor thread, and a raster thread inside

## 解析

> Parsing

### DOM 的构造

> Construction of a DOM

当呈现器进程收到导航的提交消息并开始接收 HTML 数据时，主线程开始分析文本字符串 （HTML） 并将其转换为文档对象模型 （DOM）。

> When the renderer process receives a commit message for a navigation and starts to receive HTML data, the main thread begins to parse the text string (HTML) and turn it into a Document Object Model (DOM).

DOM 是浏览器对页面的内部表示，以及 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。

> The DOM is a browser's internal representation of the page as well as the data structure and API that web developer can interact with via JavaScript.

将 HTML 文档解析为 DOM 由 HTML 标准定义。您可能已经注意到，将 HTML 提供给浏览器永远不会引发错误。例如，缺少结束 `</p>` 标记是有效的 HTML。像 `Hi! <b>I'm <i>Chrome</b>!</i>` 这样的错误标记（b 标签在 i 标签之前关闭）被视为您编写了 `Hi! <b>I'm <i>Chrome</i></b><i>!</i>` 。这是因为 HTML 规范旨在优雅地处理这些错误。如果你好奇这些事情是如何完成的，你可以阅读 HTML 规范的“解析器中的错误处理和奇怪情况的介绍”部分。

> Parsing an HTML document into a DOM is defined by the [HTML Standard](https://html.spec.whatwg.org/). You may have noticed that feeding HTML to a browser never throws an error. For example, missing closing `</p>` tag is a valid HTML. Erroneous markup like `Hi! <b>I'm <i>Chrome</b>!</i>` (b tag is closed before i tag) is treated as if you wrote `Hi! <b>I'm <i>Chrome</i></b><i>!</i>`. This is because the HTML specification is designed to handle those errors gracefully. If you are curious how these things are done, you can read on "[An introduction to error handling and strange cases in the parser](https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser)" section of the HTML spec.

### 子资源加载

> Subresource loading

网站通常使用外部资源，如图像，CSS 和 JavaScript。这些文件需要从网络或缓存加载。主线程可以在解析构建 DOM 时找到它们时逐个请求它们，但为了加快速度，“预加载扫描程序”是并发运行的。如果 HTML 文档中存在类似 `<img>` 或 `<link>` 的内容，则预加载扫描程序会查看 HTML 解析器生成的令牌，并将请求发送到浏览器进程中的网络线程。

> A website usually uses external resources like images, CSS, and JavaScript. Those files need to be loaded from network or cache. The main thread could request them one by one as they find them while parsing to build a DOM, but in order to speed up, "preload scanner" is run concurrently. If there are things like `<img>` or `<link>` in the HTML document, preload scanner peeks at tokens generated by HTML parser and sends requests to the network thread in the browser process.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/27.avif)

图 2：主线程解析 HTML 和构建 DOM 树

> Figure 2: The main thread parsing HTML and building a DOM tree

### JavaScript 可以阻止解析

> avaScript can block the parsing

当 HTML 解析器找到 `<script>` 标记时，它会暂停 HTML 文档的解析，并且必须加载、解析和执行 JavaScript 代码。为什么？因为 JavaScript 可以使用像 `document.write()` 这样的东西来改变文档的形状，这会改变整个 DOM 结构（HTML 规范中的解析模型概述有一个很好的图表）。这就是为什么 HTML 解析器必须等待 JavaScript 运行才能恢复解析 HTML 文档的原因。如果你对 JavaScript 执行中会发生什么感到好奇，V8 团队有关于这个问题的谈话和博客文章。

> When the HTML parser finds a `<script>` tag, it pauses the parsing of the HTML document and has to load, parse, and execute the JavaScript code. Why? because JavaScript can change the shape of the document using things like `document.write()` which changes the entire DOM structure (overview of the parsing model in the HTML spec has a nice diagram). This is why the HTML parser has to wait for JavaScript to run before it can resume parsing of the HTML document. If you are curious about what happens in JavaScript execution, the V8 team has talks and blog posts on this.

## 向浏览器提示您希望如何加载资源

> Hint to browser how you want to load resources

Web 开发人员可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 `document.write()` ，你可以在 `<script>` 标签中添加 `async` 或 `defer` 属性。然后，浏览器异步加载和运行 JavaScript 代码，并且不会阻止解析。如果合适的话，你也可以使用 JavaScript 模块。 <link rel="preload"> 是一种通知浏览器当前导航肯定需要该资源并且您希望尽快下载的方法。您可以在资源优先级 - 让浏览器为您提供帮助中阅读更多相关信息。

> There are many ways web developers can send hints to the browser in order to load resources nicely. If your JavaScript does not use `document.write()`, you can add [`async`](https://developer.mozilla.org/docs/Web/HTML/Element/script#attr-async) or [`defer`](https://developer.mozilla.org/docs/Web/HTML/Element/script#attr-defer) attribute to the `<script>` tag. The browser then loads and runs the JavaScript code asynchronously and does not block the parsing. You may also use [JavaScript module](https://developers.google.com/web/fundamentals/primers/modules) if that's suitable. `<link rel="preload">` is a way to inform browser that the resource is definitely needed for current navigation and you would like to download as soon as possible. You can read more on this at [Resource Prioritization – Getting the Browser to Help You](https://developers.google.com/web/fundamentals/performance/resource-prioritization).

## 样式计算

> Style calculation

拥有 DOM 不足以知道页面的外观，因为我们可以在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点的计算样式。这是关于基于 CSS 选择器应用于每个元素的样式类型的信息。可以在 DevTools 的 `computed` 部分中查看此信息。

> Having a DOM is not enough to know what the page would look like because we can style page elements in CSS. The main thread parses CSS and determines the computed style for each DOM node. This is information about what kind of style is applied to each element based on CSS selectors. You can see this information in the `computed` section of DevTools.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/28.avif)

图 3：主线程解析 CSS 以添加计算样式

> Figure 3: The main thread parsing CSS to add computed style

即使您不提供任何 CSS，每个 DOM 节点都有一个计算样式。 `<h1>` 标记显示大于 `<h2>` 个标记，并为每个元素定义边距。这是因为浏览器具有默认样式表。如果你想知道 Chrome 的默认 CSS 是什么样的，你可以在这里看到源代码。

> Even if you do not provide any CSS, each DOM node has a computed style. `<h1>` tag is displayed bigger than `<h2>` tag and margins are defined for each element. This is because the browser has a default style sheet. If you want to know what Chrome's default CSS is like, [you can see the source code here](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/html/resources/html.css).

## 布局

> Layout

现在，呈现器进程知道文档的结构和每个节点的样式，但这还不足以呈现页面。想象一下，你正试图通过电话向你的朋友描述一幅画。“有一个大红圆圈和一个小蓝色方块”不足以让你的朋友知道这幅画到底是什么样子。

> Now the renderer process knows the structure of a document and styles for each nodes, but that is not enough to render a page. Imagine you are trying to describe a painting to your friend over a phone. "There is a big red circle and a small blue square" is not enough information for your friend to know what exactly the painting would look like.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/29.avif)

图 4：一个人站在一幅画前，电话线连接到另一个人

> Figure 4: A person standing in front of a painting, phone line connected to the other person

布局是查找元素几何形状的过程。主线程遍历 DOM 和计算样式，并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树的结构可能与 DOM 树类似，但它只包含与页面上可见的内容相关的信息。如果应用 `display: none` ，则该元素不是布局树的一部分（但是，布局树中存在具有 `visibility: hidden` 的元素）。同样，如果应用了内容类似于 `p::before{content:"Hi!"}` 的伪类，则该伪类将包含在布局树中，即使该伪类不在 DOM 中也是如此。

> The layout is a process to find the geometry of elements. The main thread walks through the DOM and computed styles and creates the layout tree which has information like x y coordinates and bounding box sizes. Layout tree may be similar structure to the DOM tree, but it only contains information related to what's visible on the page. If `display: none` is applied, that element is not part of the layout tree (however, an element with `visibility: hidden` is in the layout tree). Similarly, if a pseudo class with content like `p::before{content:"Hi!"}` is applied, it is included in the layout tree even though that is not in the DOM.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/30.avif)

图 5：主线程使用计算样式遍历 DOM 树并生成布局树

> Figure 5: The main thread going over DOM tree with computed styles and producing layout tree

<br/>

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/50.gif)

[图 6：由于换行符更改而移动的段落的框布局](https://storage.googleapis.com/web-dev-uploads/video/T4FyVKpzu4WKF1kBNvXepbi08t52/rXSCtc21M00XrRqcw56C.mp4)

> Figure 6: Box layout for a paragraph moving due to line break change

<br/>

确定页面的布局是一项具有挑战性的任务。即使是最简单的页面布局，如从上到下的块流，也必须考虑字体的大小以及在哪里换行，因为这些会影响段落的大小和形状;然后影响下一段需要的位置。

> Determining the Layout of a page is a challenging task. Even the simplest page layout like a block flow from top to bottom has to consider how big the font is and where to line break them because those affect the size and shape of a paragraph; which then affects where the following paragraph needs to be.

CSS 可以使元素浮向一侧、屏蔽溢出项和更改写入方向。可想而知，这个布局阶段有着艰巨的任务。在 Chrome 中，整个工程师团队都在处理布局。如果你想看看他们工作的细节，BlinkOn Conference 的演讲很少被记录下来，而且很有趣。

> CSS can make element float to one side, mask overflow item, and change writing directions. You can imagine, this layout stage has a mighty task. In Chrome, a whole team of engineers works on the layout. If you want to see details of their work, [few talks from BlinkOn Conference](https://www.youtube.com/watch?v=Y5Xa4H2wtVA) are recorded and quite interesting to watch.

## 漆

> Paint

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/31.avif)

图 7：一个人拿着画笔在画布前，想知道他们应该先画一个圆还是先画一个正方形

> Figure 7: A person in front of a canvas holding paintbrush, wondering if they should draw a circle first or square first

拥有 DOM、样式和布局仍然不足以呈现页面。假设您正在尝试复制一幅画。你知道元素的大小、形状和位置，但你仍然需要判断你以什么顺序绘制它们。

> Having a DOM, style, and layout is still not enough to render a page. Let's say you are trying to reproduce a painting. You know the size, shape, and location of elements, but you still have to judge in what order you paint them.

例如，可以为某些元素设置 `z-index` ，在这种情况下，按 HTML 中写入的元素的顺序绘制将导致呈现不正确。

> For example, `z-index` might be set for certain elements, in that case painting in order of elements written in the HTML will result in incorrect rendering.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/32.avif)

图 8：页面元素按 HTML 标记的顺序显示，导致渲染图像错误，因为未考虑 z-index

> Figure 8: Page elements appearing in order of an HTML markup, resulting in wrong rendered image because z-index was not taken into account

在此绘制步骤中，主线程遍历布局树以创建绘制记录。绘画记录是绘画过程的注释，如“先背景，然后是文字，然后是矩形”。如果您使用 JavaScript 绘制了 `<canvas>` 元素，那么您可能熟悉此过程。

> At this paint step, the main thread walks the layout tree to create paint records. Paint record is a note of painting process like "background first, then text, then rectangle". If you have drawn on `<canvas>` element using JavaScript, this process might be familiar to you.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/33.avif)

图 9：主线程遍历布局树并生成绘制记录

> Figure 9: The main thread walking through layout tree and producing paint records

### 更新渲染管线成本高昂

> Updating rendering pipeline is costly

<br/>

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/51.gif)

[图 10：按生成顺序排列的 DOM+样式、布局和绘制树](https://storage.googleapis.com/web-dev-uploads/video/T4FyVKpzu4WKF1kBNvXepbi08t52/d7zOpwpNIXIoVnoZCtI9.mp4)

> Figure 10: DOM+Style, Layout, and Paint trees in order it is generated

<br/>

在渲染管线中要掌握的最重要的事情是，在每一步中，上一个操作的结果都用于创建新数据。例如，如果布局树中的某些内容发生更改，则需要为文档的受影响部分重新生成“绘制”顺序。

> The most important thing to grasp in rendering pipeline is that at each step the result of the previous operation is used to create new data. For example, if something changes in the layout tree, then the Paint order needs to be regenerated for affected parts of the document.

如果要对元素进行动画处理，浏览器必须在每一帧之间运行这些操作。我们的大多数显示器每秒刷新屏幕 60 次 （60 fps）;当您在每一帧中在屏幕上移动内容时，动画在人眼中看起来很流畅。但是，如果动画错过了中间的帧，则页面将显示为“卡顿”。

> If you are animating elements, the browser has to run these operations in between every frame. Most of our displays refresh the screen 60 times a second (60 fps); animation will appear smooth to human eyes when you are moving things across the screen at every frame. However, if the animation misses the frames in between, then the page will appear "janky".

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/34.avif)

图 11：时间轴上的动画帧

> Figure 11: Animation frames on a timeline

即使您的渲染操作跟上屏幕刷新，这些计算也会在主线程上运行，这意味着当您的应用程序运行 JavaScript 时，它可能会被阻止。

> Even if your rendering operations are keeping up with screen refresh, these calculations are running on the main thread, which means it could be blocked when your application is running JavaScript.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/35.avif)

图 12：时间轴上的动画帧，但一个帧被 JavaScript 阻止

> Figure 12: Animation frames on a timeline, but one frame is blocked by JavaScript

您可以将 JavaScript 操作划分为小块，并使用 `requestAnimationFrame()` 安排在每一帧运行时。有关此主题的更多信息，请参阅优化 JavaScript 执行 。你也可以在 Web Workers 中运行 JavaScript 以避免阻塞主线程。

> You can divide JavaScript operation into small chunks and schedule to run at every frame using `requestAnimationFrame()`. For more on this topic, please see [Optimize JavaScript Execution](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution) . You might also run your [JavaScript in Web Workers](https://www.youtube.com/watch?v=X57mh8tKkgE) to avoid blocking the main thread.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/36.avif)

图 13：在带有动画帧的时间轴上运行的较小 JavaScript 块

> Figure 13: Smaller chunks of JavaScript running on a timeline with animation frame

## 合成

> Compositing

### 你会如何画一页？

> How would you draw a page?

<br/>

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/52.gif)

[图 14：朴素栅格化过程的动画](https://storage.googleapis.com/web-dev-uploads/video/T4FyVKpzu4WKF1kBNvXepbi08t52/AiIny83Lk4rTzsM8bxSn.mp4)

> Figure 14: Animation of naive rastering process

<br/>

现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它如何绘制页面？将此信息转换为屏幕上的像素称为光栅化。

> Now that the browser knows the structure of the document, the style of each element, the geometry of the page, and the paint order, how does it draw a page? Turning this information into pixels on the screen is called rasterizing.

也许处理这个问题的一种天真方法是在视口内栅格化部分。如果用户滚动页面，则移动栅格化框架，并通过栅格化更多内容来填充缺失的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器运行一个更复杂的过程，称为合成。

> Perhaps a naive way to handle this would be to raster parts inside of the viewport. If a user scrolls the page, then move the rastered frame, and fill in the missing parts by rastering more. This is how Chrome handled rasterizing when it was first released. However, the modern browser runs a more sophisticated process called compositing.

### 什么是合成

> What is compositing

<br/>

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/53.gif)

[图 15：合成过程的动画](https://storage.googleapis.com/web-dev-uploads/video/T4FyVKpzu4WKF1kBNvXepbi08t52/Aggd8YLFPckZrBjEj74H.mp4)

> Figure 15: Animation of compositing process

<br/>

合成是一种将页面的各个部分分成图层、单独栅格化它们并在称为合成器线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经栅格化，因此所要做的就是合成新帧。动画可以通过移动图层和合成新帧以相同的方式实现。

> Compositing is a technique to separate parts of a page into layers, rasterize them separately, and composite as a page in a separate thread called compositor thread. If scroll happens, since layers are already rasterized, all it has to do is to composite a new frame. Animation can be achieved in the same way by moving layers and composite a new frame.

您可以使用“图层”面板在 DevTools 中查看您的网站如何划分为多个图层。

> You can see how your website is divided into layers in DevTools using Layers panel.

### 划分为层

> Dividing into layers

为了找出哪些元素需要位于哪些层中，主线程遍历布局树以创建层树（此部分在 DevTools 性能面板中称为“更新层树”）。如果页面的某些部分应该是单独的图层（如滑入式侧菜单）没有得到一个，那么您可以通过在 CSS 中使用 `will-change` 属性向浏览器提示。

> In order to find out which elements need to be in which layers, the main thread walks through the layout tree to create the layer tree (this part is called "Update Layer Tree" in the DevTools performance panel). If certain parts of a page that should be separate layer (like slide-in side menu) is not getting one, then you can hint to the browser by using `will-change` attribute in CSS.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/37.avif)

图 16：主线程遍历布局树生成层树

> Figure 16: The main thread walking through layout tree producing layer tree

您可能很想为每个元素提供图层，但跨过多数量的图层进行合成可能会导致操作速度比每帧栅格化页面的小部分慢，因此测量应用程序的呈现性能至关重要。有关该主题的更多信息，请参阅坚持使用仅合成器属性和管理图层计数。

> You might be tempted to give layers to every element, but compositing across an excess number of layers could result in slower operation than rasterizing small parts of a page every frame, so it is crucial that you measure rendering performance of your application. For more about on topic, see S[tick to Compositor-Only Properties and Manage Layer Count](https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count).

### 主线程的光栅和复合

> Raster and composite off of the main thread

创建层树并确定绘制顺序后，主线程会将该信息提交到合成器线程。然后，合成器线程对每个图层进行栅格化。图层可能像页面的整个长度一样大，因此合成器线程将它们划分为切片，并将每个切片发送到栅格线程。栅格线程栅格化每个切片并将其存储在 GPU 内存中。

> Once the layer tree is created and paint orders are determined, the main thread commits that information to the compositor thread. The compositor thread then rasterizes each layer. A layer could be large like the entire length of a page, so the compositor thread divides them into tiles and sends each tile off to raster threads. Raster threads rasterize each tile and store them in GPU memory.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/38.avif)

图 17：创建切片位图并发送到 GPU 的光栅线程

> Figure 17: Raster threads creating the bitmap of tiles and sending to GPU

合成器线程可以确定不同栅格线程的优先级，以便可以首先栅格化视口内（或附近）的事物。图层还具有用于不同分辨率的多个平铺，以处理放大操作等操作。

> The compositor thread can prioritize different raster threads so that things within the viewport (or nearby) can be rastered first. A layer also has multiple tilings for different resolutions to handle things like zoom-in action.

栅格化切片后，合成器线程将收集称为绘制四边形的切片信息，以创建合成器帧。

> Once tiles are rastered, compositor thread gathers tile information called draw quads to create a compositor frame.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/table2_translate.png)

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/table.png)

然后，通过 IPC 将合成器帧提交到浏览器进程。此时，可以从 UI 线程添加另一个合成器帧以进行浏览器 UI 更改，或者从其他渲染器进程添加用于扩展。这些合成器帧被发送到 GPU 以在屏幕上显示。如果出现滚动事件，合成器线程会创建另一个要发送到 GPU 的合成器帧。

> A compositor frame is then submitted to the browser process via IPC. At this point, another compositor frame could be added from UI thread for the browser UI change or from other renderer processes for extensions. These compositor frames are sent to the GPU to display it on a screen. If a scroll event comes in, compositor thread creates another compositor frame to be sent to the GPU.

![](https://cdn.jsdelivr.net/gh/kisssssssss/IMG/docs/WEB/浏览器/39.avif)

图 18：创建合成帧的合成器线程。帧被发送到浏览器进程，然后发送到 GPU

> Figure 18: Compositor thread creating compositing frame. Frame is sent to the browser process then to GPU

合成的好处是它不涉及主线程。合成器线程不需要等待样式计算或 JavaScript 执行。这就是为什么仅合成动画被认为是平滑性能的最佳选择。如果需要再次计算布局或油漆，则必须涉及主线程。

> The benefit of compositing is that it is done without involving the main thread. Compositor thread does not need to wait on style calculation or JavaScript execution. This is why [compositing only animations](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/) are considered the best for smooth performance. If layout or paint needs to be calculated again then the main thread has to be involved.

## 总结

> Wrap Up

在这篇文章中，我们研究了从解析到合成的渲染管线。希望您现在能够阅读有关网站性能优化的更多信息。

> In this post, we looked at rendering pipeline from parsing to compositing. Hopefully, you are now empowered to read more about performance optimization of a website.

在本系列的下一篇文章也是最后一篇文章中，我们将更详细地了解合成器线程，并查看当用户输入 `mouse move` 和 `click` 时会发生什么。

> In the next and last post of this series, we'll look at the compositor thread in more details and see what happens when user input like `mouse move` and `click` comes in.

你喜欢这个帖子吗？如果您对未来的帖子有任何疑问或建议，我很乐意在下面的评论部分或 Twitter 上@kosamari 收到您的来信。

> Did you enjoy the post? If you have any questions or suggestions for the future post, I'd love to hear from you in the comment section below or [@kosamari](https://twitter.com/kosamari) on Twitter.
