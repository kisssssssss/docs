---
title: 深入了解现代网络浏览器(1)
index: 1
---

::: tip
搬运，文章原地址: https://developer.chrome.com/blog/inside-browser-part1/

原文章发表于 2018.9.5，更新于：2018.9.21
:::

## CPU、GPU、内存和多进程架构

> CPU, GPU, Memory, and multi-process architecture

在这个由 4 部分组成的博客系列中，我们将从高级架构到渲染管线的细节来了解 Chrome 浏览器的内部情况。如果您想知道浏览器如何将您的代码变成一个功能性网站，或者您不确定为什么建议使用特定技术来提高性能，那么本系列适合您。

> In this 4-part blog series, we’ll look inside the Chrome browser from high-level architecture to the specifics of the rendering pipeline. If you ever wondered how the browser turns your code into a functional website, or you are unsure why a specific technique is suggested for performance improvements, this series is for you.

作为本系列的第 1 部分，我们将研究核心计算术语和 Chrome 的多进程架构。

> As part 1 of this series, we’ll take a look at core computing terminology and Chrome’s multi-process architecture.

## 计算机的核心是 CPU 和 GPU

> At the core of the computer are the CPU and GPU

为了了解浏览器运行的环境，我们需要了解一些计算机部件及其作用。

> In order to understand the environment that the browser is running, we need to understand a few computer parts and what they do.

### CPU

![](../../../../images/WEB/浏览器/1.avif)

图 1：4 个 CPU 内核就像坐在每张办公桌前处理进来的任务的办公室工作人员

> Figure 1: 4 CPU cores as office workers sitting at each desk handling tasks as they come in

首先是中央处理器 - 或者 CPU。CPU 可以被视为计算机的大脑。CPU 内核，如图所示，就像一个办公室工作人员，当任务进来的时候可以一个接一个地处理许多不同的任务。它可以处理从数学到艺术的所有内容，同时知道如何回复客户电话。过去，大多数 CPU 都是单芯片。一个内核就像另一个 CPU 位于同一个芯片中。在现代硬件中，您通常会获得多个内核，从而为您的手机和笔记本电脑提供更多的计算能力。

> First is the **C**entral **P**rocessing **U**nit - or CPU. The CPU can be considered your computer’s brain. A CPU core, pictured here as an office worker, can handle many different tasks one by one as they come in. It can handle everything from math to art while knowing how to reply to a customer call. In the past most CPUs were a single chip. A core is like another CPU living in the same chip. In modern hardware, you often get more than one core, giving more computing power to your phones and laptops.

### GPU

![](../../../../images/WEB/浏览器/2.avif)

图 2：许多带有扳手的 GPU 内核表明它们处理有限的任务

> Figure 2: Many GPU cores with wrench suggesting they handle a limited task

图形处理单元 - 或者 GPU 是计算机的另一部分。与 CPU 不同，GPU 擅长处理简单的任务，但同时跨多个内核。顾名思义，它最初是为处理图形而开发的。这就是为什么在图形上下文中“使用 GPU”或“GPU 支持”与快速渲染和流畅交互有关的原因。近年来，随着 GPU 加速计算，越来越多的计算仅在 GPU 上成为可能。

> **G**raphics **P**rocessing **U**nit - or GPU is another part of the computer. Unlike CPU, GPU is good at handling simple tasks but across multiple cores at the same time. As the name suggests, it was first developed to handle graphics. This is why in the context of graphics "using GPU" or "GPU-backed" is associated with fast rendering and smooth interaction. In recent years, with GPU-accelerated computing, more and more computation is becoming possible on GPU alone.

当您在计算机或手机上启动应用程序时，CPU 和 GPU 是为应用程序提供支持。通常，应用程序使用操作系统提供的机制在 CPU 和 GPU 上运行。

> When you start an application on your computer or phone, the CPU and GPU are the ones powering the application. Usually, applications run on the CPU and GPU using mechanisms provided by the Operating System.

![](../../../../images/WEB/浏览器/3.avif)

图 3：计算机体系结构的三层。机器硬件在底部，操作系统在中间，应用程序在顶部。

> Figure 3: Three layers of computer architecture. Machine Hardware at the bottom, Operating System in the middle, and Application on top.

## 在进程和线程上执行程序

> Executing program on Process and Thread

![](../../../../images/WEB/浏览器/4.avif)

图 4：进程作为边界框，线程作为在进程内游动的抽象鱼

> Figure 4: Process as a bounding box, threads as abstract fish swimming inside of a process

在深入研究浏览器架构之前要掌握的另一个概念是进程和线程。进程可以描述为应用程序的执行程序。线程是位于进程内部并执行其进程程序的任何部分的线程。

> Another concept to grasp before diving into browser architecture is Process and Thread. A process can be described as an application’s executing program. A thread is the one that lives inside of process and executes any part of its process's program.

启动应用程序时，将创建一个进程。程序可能会创建线程来帮助它工作，但这是可选的。操作系统为进程提供要使用的内存“板”，并且所有应用程序状态都保存在该专用内存空间中。当您关闭应用程序时，该过程也会消失，操作系统会释放内存。

> When you start an application, a process is created. The program might create thread(s) to help it do work, but that's optional. The Operating System gives the process a "slab" of memory to work with and all application state is kept in that private memory space. When you close the application, the process also goes away and the Operating System frees up the memory.

![](../../../../images/WEB/浏览器/5.svg)

图 5：使用内存空间和存储应用程序数据的进程示意图

> Figure 5: Diagram of a process using memory space and storing application data

一个进程可以要求操作系统启动另一个进程来运行不同的任务。发生这种情况时，将为新进程分配内存的不同部分。如果两个进程需要通信，则可以使用进程间通信 （IPC） 来实现。许多应用程序都设计为以这种方式工作，因此，如果工作进程无响应，则可以重新启动它，而无需停止运行应用程序不同部分的其他进程。

> A process can ask the Operating System to spin up another process to run different tasks. When this happens, different parts of the memory are allocated for the new process. If two processes need to talk, they can do so by using Inter Process Communication (IPC). Many applications are designed to work this way so that if a worker process get unresponsive, it can be restarted without stopping other processes which are running different parts of the application.

![](../../../../images/WEB/浏览器/6.svg)

图 6：通过 IPC 通信的单独进程示意图

> Figure 6: Diagram of separate processes communicating over IPC

## 浏览器架构

> Browser Architecture

那么如何使用进程和线程构建 Web 浏览器呢？好吧，它可能是一个具有许多不同线程的进程，也可以是具有几个线程通过 IPC 通信的许多不同进程。

> So how is a web browser built using processes and threads? Well, it could be one process with many different threads or many different processes with a few threads communicating over IPC.

![](../../../../images/WEB/浏览器/7.avif)

图 7：进程/线程图中的不同浏览器体系结构

> Figure 7: Different browser architectures in process/thread diagram

这里要注意的重要一点是，这些不同的体系结构是实现细节。关于如何构建 Web 浏览器没有标准规范。一个浏览器的方法可能与另一个浏览器完全不同。

> The important thing to note here is that these different architectures are implementation details. There is no standard specification on how one might build a web browser. One browser’s approach may be completely different from another.

为了本博客系列，我们将使用下图中描述的 Chrome 的最新架构。

> For the sake of this blog series, we are going to use Chrome’s recent architecture described in the diagram below.

顶部是浏览器进程与处理应用程序不同部分的其他进程协调。对于渲染器进程，将创建多个进程并将其分配给每个选项卡。直到最近，Chrome 还尽可能为每个标签页提供了一个进程;现在，它尝试为每个站点提供自己的进程，包括 iframe（请参[阅站点隔离](https://developer.chrome.com/blog/inside-browser-part1/#site-isolation)）。

> At the top is the browser process coordinating with other processes that take care of different parts of the application. For the renderer process, multiple processes are created and assigned to each tab. Until very recently, Chrome gave each tab a process when it could; now it tries to give each site its own process, including iframes (see [Site Isolation](https://developer.chrome.com/blog/inside-browser-part1/#site-isolation)).

![](../../../../images/WEB/浏览器/8.avif)

图 8：Chrome 的多进程架构示意图。“渲染器进程”下会显示多个图层，表示 Chrome 为每个标签页运行多个渲染器进程。

> Figure 8: Diagram of Chrome’s multi-process architecture. Multiple layers are shown under Renderer Process to represent Chrome running multiple Renderer Processes for each tab.

## 哪个进程控制什么？

> Which process controls what?

下表介绍了每个 Chrome 进程及其控制的内容：

> The following table describes each Chrome process and what it controls:

![](../../../../images/WEB/浏览器/table_translate.png)

![](../../../../images/WEB/浏览器/table.png)

![](../../../../images/WEB/浏览器/9.avif)

图 9：指向浏览器 UI 不同部分的不同进程

> Figure 9: Different processes pointing to different parts of browser UI

还有更多进程，如扩展进程和实用程序进程。如果您想查看 Chrome 中正在运行的进程数量，请点击右上角的选项菜单图标，选择更多工具，然后选择任务管理器。这将打开一个窗口，其中包含当前正在运行的进程列表以及它们使用的 CPU/内存量。

> There are even more processes like the Extension process and utility processes. If you want to see how many processes are running in your Chrome, click the options menu icon more_vert at the top right corner, select More Tools, then select Task Manager. This opens up a window with a list of processes that are currently running and how much CPU/Memory they are using.

## Chrome 中多进程架构的优势

> The benefit of multi-process architecture in Chrome

之前，我提到 Chrome 使用多个渲染器进程。在最简单的情况下，您可以想象每个选项卡都有自己的渲染器进程。假设您打开了 3 个选项卡，每个选项卡由一个独立的渲染器进程运行。如果一个选项卡变得无响应，则可以关闭无响应的选项卡并继续前进，同时保持其他选项卡处于活动状态。如果所有选项卡都在一个进程中运行，则当一个选项卡无响应时，所有选项卡都无响应。这很可悲。

> Earlier, I mentioned Chrome uses multiple renderer process. In the most simple case, you can imagine each tab has its own renderer process. Let’s say you have 3 tabs open and each tab is run by an independent renderer process. If one tab becomes unresponsive, then you can close the unresponsive tab and move on while keeping other tabs alive. If all tabs are running on one process, when one tab becomes unresponsive, all the tabs are unresponsive. That’s sad.

![](../../../../images/WEB/浏览器/10.avif)

图 10：显示运行每个选项卡的多个进程的图表

> Figure 10: Diagram showing multiple processes running each tab

将浏览器的工作分成多个进程的另一个好处是安全性和沙盒。由于操作系统提供了一种限制进程权限的方法，因此浏览器可以从某些功能对某些进程进行沙盒处理。例如，Chrome 浏览器会限制处理任意用户输入的进程（如渲染器进程）的任意文件访问权限。

> Another benefit of separating the browser's work into multiple processes is security and sandboxing. Since operating systems provide a way to restrict processes’ privileges, the browser can sandbox certain processes from certain features. For example, the Chrome browser restricts arbitrary file access for processes that handle arbitrary user input like the renderer process.

由于进程有自己的私有内存空间，因此它们通常包含公共基础架构的副本（例如 Chrome 的 JavaScript 引擎 V8）。这意味着更多的内存使用量，因为它们不能像它们在同一进程中的线程那样共享。为了节省内存，Chrome 对它可以启动的进程数量进行了限制。限制因设备拥有的内存和 CPU 功率而异，但当 Chrome 达到限制时，它会开始在一个进程中运行来自同一站点的多个标签页。

> Because processes have their own private memory space, they often contain copies of common infrastructure (like V8 which is a Chrome's JavaScript engine). This means more memory usage as they can't be shared the way they would be if they were threads inside the same process. In order to save memory, Chrome puts a limit on how many processes it can spin up. The limit varies depending on how much memory and CPU power your device has, but when Chrome hits the limit, it starts to run multiple tabs from the same site in one process.

## 节省更多内存 - Chrome 中的服务化

> Saving more memory - Servicification in Chrome

相同的方法应用于浏览器进程。Chrome 正在进行架构更改，以将浏览器程序的每个部分作为服务运行，从而可以轻松地拆分为不同的进程或聚合为一个进程。

> The same approach is applied to the browser process. Chrome is undergoing architecture changes to run each part of the browser program as a service allowing to easily split into different processes or aggregate into one.

一般的想法是，当 Chrome 在强大的硬件上运行时，它可能会将每个服务拆分为不同的进程，从而提高稳定性，但如果它是在资源受限的设备上，Chrome 会将服务整合到一个进程中，从而节省内存占用。在此更改之前，类似的整合流程以减少内存使用的方法已在 Android 等平台上使用。

> General idea is that when Chrome is running on powerful hardware, it may split each service into different processes giving more stability, but if it is on a resource-constraint device, Chrome consolidates services into one process saving memory footprint. Similar approach of consolidating processes for less memory usage have been used on platform like Android before this change.

![](../../../../images/WEB/浏览器/11.svg)

图 11：Chrome 的服务化示意图，将不同的服务移动到多个进程和单个浏览器进程中

> Figure 11: Diagram of Chrome’s servicification moving different services into multiple processes and a single browser process

## 每帧渲染器进程 - 站点隔离

> Per-frame renderer processes - Site Isolation

站点隔离是 Chrome 中最近引入的一项功能，它为每个跨站点 iframe 运行单独的渲染器进程。我们一直在讨论每个选项卡模型一个渲染器进程，它允许跨站点 iframe 在单个渲染器进程中运行，并在不同站点之间共享内存空间。在同一个渲染器进程中运行 a.com 和 b.com 似乎没问题。同源策略是 Web 的核心安全模型;它确保一个站点在未经同意的情况下无法访问其他站点的数据。绕过此策略是安全攻击的主要目标。进程隔离是分离站点的最有效方法。随着 Meltdown 和 Spectre 的出现，我们需要使用进程来分隔站点变得更加明显。自 Chrome 67 起，桌面设备上默认启用站点隔离，选项卡中的每个跨站点 iframe 都会获得一个单独的渲染器进程。

> [Site Isolation](https://developers.google.com//web/updates/2018/07/site-isolation) is a recently introduced feature in Chrome that runs a separate renderer process for each cross-site iframe. We’ve been talking about one renderer process per tab model which allowed cross-site iframes to run in a single renderer process with sharing memory space between different sites. Running a.com and b.com in the same renderer process might seem okay. The [Same Origin Policy](https://developer.mozilla.org/docs/Web/Security/Same-origin_policy) is the core security model of the web; it makes sure one site cannot access data from other sites without consent. Bypassing this policy is a primary goal of security attacks. Process isolation is the most effective way to separate sites. With [Meltdown and Spectre](https://developers.google.com/web/updates/2018/02/meltdown-spectre), it became even more apparent that we need to separate sites using processes. With Site Isolation enabled on desktop by default since Chrome 67, each cross-site iframe in a tab gets a separate renderer process.

![](../../../../images/WEB/浏览器/12.avif)

图 12：站点隔离图;指向站点内 iframe 的多个呈现器进程

> Figure 12: Diagram of site isolation; multiple renderer processes pointing to iframes within a site

启用站点隔离是一项多年的工程工作。站点隔离并不像分配不同的渲染器进程那么简单;它从根本上改变了 iframe 相互交谈的方式。在 iframe 运行在不同进程的页面上打开 devtools 意味着 devtools 必须实现幕后工作才能使其看起来无缝。即使运行简单的 Ctrl+F 来查找页面中的单词也意味着跨不同的呈现器进程进行搜索。您可以看到浏览器工程师将站点隔离的发布视为重要里程碑的原因！

> Enabling Site Isolation has been a multi-year engineering effort. Site Isolation isn’t as simple as assigning different renderer processes; it fundamentally changes the way iframes talk to each other. Opening devtools on a page with iframes running on different processes means devtools had to implement behind-the-scenes work to make it appear seamless. Even running a simple Ctrl+F to find a word in a page means searching across different renderer processes. You can see the reason why browser engineers talk about the release of Site Isolation as a major milestone!

## 总结

> Wrap-up

在这篇文章中，我们介绍了浏览器架构的高级视图，并介绍了多进程架构的好处。我们还介绍了 Chrome 中的服务化和站点隔离，这与多进程架构密切相关。在下一篇文章中，我们将开始深入研究这些进程和线程之间发生了什么，以便显示网站。

> In this post, we’ve covered a high-level view of browser architecture and covered the benefits of a multi-process architecture. We also covered Servicification and Site Isolation in Chrome that is deeply related to multi-process architecture. In the next post, we’ll start diving into what happens between these processes and threads in order to display a website.

你喜欢这个帖子吗？如果您对未来的帖子有任何疑问或建议，我很乐意在下面的评论部分或 Twitter 上@kosamari 收到您的来信。

> Did you enjoy the post? If you have any questions or suggestions for the future post, I'd love to hear from you in the comment section below or [@kosamari](https://twitter.com/kosamari) on Twitter.
